<!DOCTYPE html>
<html  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  <link rel="icon" href="/img/logo.jpg">
  <title>05.构建块&nbsp; | &nbsp;Java for You</title>
  
  
  <meta property="og:title" content="05.构建块">
  
  
  <meta property="og:url" content="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-%E6%9E%84%E5%BB%BA%E5%9D%97/index.html">
  
  
  <meta property="og:img" content="/img/logo.jpg">
  
  
  <meta property="og:img" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2016-04-29">
  <meta property="og:article:modified_time" content="2020-12-19">
  <meta property="og:article:author" content="蜗牛 Java 之家">
  
  
  <meta property="og:article:tag" content="Java">
  
  <meta property="og:article:tag" content="Java并发">
  
  <meta property="og:article:tag" content="构建块">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  <link rel="prefetch" href="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  


  <!-- 百度站长工具验证 -->
  <meta name="baidu-site-verification" content="code-9cIsKsXy75" />

  <!-- 必应站长工具验证-->
  <meta name="msvalidate.01" content="81AA8F485E800B7335F07A558BE9A636" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22LNC79YC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22LNC79YC');
</script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.jpg" alt="logo">
      
      <span class="navbar-logo-dsc">蜗牛 Java 之家</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/resources" class="navbar-menu-item">
    
    免费资源
    
    </a>
    
    <a href="/tools" class="navbar-menu-item">
    
    免费工具
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      05.构建块
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2016-04-29T04:06:51.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2016-04-29</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/Java并发编程/" class="post-meta-link">Java并发编程</a>
    
    
    
    <span class="dot"></span>
    <span>9.8k 字</span>
    

    <span class="dot"></span>
    <!-- 增加阅读量统计样式代码 -->
    
    <!-- id 将作为查询条件 -->
    <i class="iconfont icon-wodebaobiao" style="margin-right: 2px; font-size: 1.15rem;"></i>
    <span id="/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-%E6%9E%84%E5%BB%BA%E5%9D%97/" class="leancloud_visitors" data-flag-title="05.构建块">
      <em class="post-meta-item-text">阅读量 </em>
      <i class="leancloud-visitors-count"></i>
    </span>

  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Java/" class="post-meta-link">Java</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/Java并发/" class="post-meta-link">Java并发</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/构建块/" class="post-meta-link">构建块</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2><span id="51-同步容器">5.1 同步容器</span></h2><ul>
<li>同步容器类包括两部分：<ul>
<li>Vector和Hashtable，早期JDK的一部分</li>
<li>以上两个的同系容器，在JDK1.2中才被加入的同步包装(wrapper)类<ul>
<li>这些类由Collections.synchronizedXXX工厂方法创建</li>
<li>这些类通过封装它们的状态，并对每一个公共方法进行同步而实现了线程安全，这样一次只有一个线程能访问容器的状态</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3><span id="511-同步容器出现的问题">5.1.1 同步容器出现的问题</span></h3><ul>
<li><p>同步容器都是线程安全的，但对于复合操作，可能需要使用额外的客户端加锁(client-side locking)进行保护。这些复合操作包括：</p>
<ul>
<li>迭代(反复获取元素，直到获得容器中的最后一个元素)</li>
<li>导航(navigation，根据一定的顺序寻找下一个元素)</li>
<li>条件运算，比如”缺少即加入”，检查Map中是否存在关键字K，如果没有，就加入mapping(K,V)。</li>
</ul>
</li>
<li><p>操作Vector的复合操作可能导致混乱的结果</p>
<pre><code>  public static Object getLast(Vector list) &#123;
      int lastIndex = list.size() - 1;
      return list.get(lastIndex);
  &#125;

  public static void deleteLast(Vector list) &#123;
      int lastIndex = list.size() - 1;
      list.remove(lastIndex);
  &#125;</code></pre>
<p>　　多线程环境下getLast方法可能会抛出ArrayIndexOutOfBoundsException异常。所以需要客户端加锁，使getLast和deleteLast成为原子操作。</p>
</li>
<li><p>使用客户端加锁，对Vector进行复合操作</p>
<pre><code>  public static Object getLast(Vector list) &#123;
      synchronized (list) &#123;
          int lastIndex = list.size() - 1;
          return list.get(lastIndex);
      &#125;
  &#125;

  public static void deleteLast(Vector list) &#123;
      synchronized (list) &#123;
          int lastIndex = list.size() - 1;
          list.remove(lastIndex);
      &#125;
  &#125;</code></pre>
</li>
<li><p>迭代不可靠问题同样可以通过在客户端加锁来解决，这要增加一些针对可伸缩性的开销。通过在迭代期间持有Vector锁，我们防止其他线程在迭代期间修改Vector。缺点是，我们同样完全阻止了其他线程在这一期间访问它，这削弱了并发性</p>
</li>
</ul>
<h3><span id="512-迭代器和concurrentmodificationexception">5.1.2 迭代器和ConcurrentModificationException</span></h3><ul>
<li>对Collection进行迭代的标准方式是使用Iterator</li>
<li>循环遍历过程中，其他线程并发修改容器时，使用迭代器不可避免的需要在迭代期间对容器加锁</li>
<li>在设计同步容器返回的迭代器时，并没有考虑到并发修改的问题，它们是“及时失败(fail-fast)”的，意思是当它们察觉容器在迭代开始后被修改，会抛出一个未检查的ConcurrentModificationException</li>
<li>ConcurrentModificationException也可能出现在单线程的代码中；当对象并非通过Interator.remove，而是被直接从容器中删除时，就会出现这个情况</li>
<li>有一些原因造成我们不愿意在迭代期间对容器上锁。其它线程访问容器，必须等待，这个时间有可能很长。</li>
<li>迭代期间对容器加锁的一个替代方法是复制容器。因为复制是线程限制(thread-confined)的，没有其它的线程能够在迭代期间对其进行修改，这样消除了ConcurrentModificationException发生的可能性。(容器仍然需要在复制期间对自己加锁)。复制容器有性能开销。</li>
</ul>
<h3><span id="513-隐藏迭代器">5.1.3 隐藏迭代器</span></h3><ul>
<li><p>迭代隐藏在字符串的拼接中(<strong>不要这么做</strong>)</p>
<pre><code>  public class HiddenIterator &#123;
      @GuardedBy(&quot;this&quot;) private final Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();

      public synchronized void add(Integer i) &#123;
          set.add(i);
      &#125;

      public synchronized void remove(Integer i) &#123;
          set.remove(i);
      &#125;

      public void addTenThings() &#123;
          Random r = new Random();
          for (int i = 0; i &lt; 10; i++)
              add(r.nextInt());
          System.out.println(&quot;DEBUG: added ten elements to &quot; + set);
      &#125;
  &#125;</code></pre>
</li>
<li><p>容器的hashCode和equals方法也会间接地调用迭代。比如当容器本身作为一个元素时，或者作为另一个容器的key时。</p>
</li>
<li><p>containsAll、removeAll、retainAll方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些对迭代的间接调用，都可能会引起ConcurrentModificationException</p>
</li>
</ul>
<h2><span id="52-并发容器">5.2 并发容器</span></h2><ul>
<li><p>Java 5.0通过提供几种并发的容器类来改进同步容器。同步容器通过对容器的所有状态进行串行访问，从而实现了它们的线程安全。代价是削弱了并发性，当多个线程共同竞争容器级的(collection-wide)锁时，吞吐量就会降低</p>
</li>
<li><p>另一方面，并发容器是为多线程并发访问而设计的。</p>
<ul>
<li>Java 5.0 添加了ConcurrentHashMap来替代同步的哈希Map实现；</li>
<li>当多数操作作为读取操作时，CopyOnWriteArrayList是List相应的同步实现。</li>
<li>新的ConcurrentMap接口加入了对常见复合操作的支持，比如，缺少即加入、替换、条件删除</li>
</ul>
</li>
<li><p><strong>用并发容器替换同步容器，这种做法以有很小的风险带来了可扩展性显著的提高。</strong></p>
</li>
<li><p>Java 5.0 同样添加了两个新的容器类型：Queue和BlockingQueue。</p>
<ul>
<li><p>Queue用来临时保存正在等待被进一步处理的一系列元素。JDK的几种实现有：</p>
<ul>
<li>传统的FIFO队列，ConcurrentLinkedQueue</li>
<li>一个(非并发)具有优先级顺序的队列，PriorityQueue</li>
</ul>
</li>
<li><p>Queue的操作不会阻塞；队列为空，获取元素；队列满，插入操作阻塞，直到队列中存在可用空间。用在生产者消费者模式中</p>
</li>
<li><p>正像ConcurrentHashMap作为同步的哈希Map的一个并发替代品，Java 6 中加入了ConcurrentSkipListMap和ConcurrentSkipListSet，用来作为同步的SortedMap和SortedSet的并发替代品</p>
</li>
</ul>
</li>
</ul>
<h3><span id="521-concurrenthashmap">5.2.1 ConcurrentHashMap</span></h3><ul>
<li><p>在ConcurrentHashMap以前，程序使用一个公共锁同步每一个方法，并严格地限制只能有一个线程可以同时访问容器。</p>
</li>
<li><p>而ConcurrentHashMap使用一个更加细化的锁机制，名叫分离锁。</p>
</li>
<li><p>这个机制允许更深层次的共享访问。</p>
<ul>
<li>任意数量的读线程可以并发访问Map</li>
<li>读者和写者也可以并发访问Map</li>
<li>有限数量的写线程还可以并发修改Map</li>
</ul>
</li>
<li><p>结果是，为并发访问带来了更高的吞吐量，同时几乎没有损失单个线程访问的性能</p>
</li>
<li><p>ConcurrentHashMap与其他的并发容器一起，进一步改进了同步容器类：提供不会抛出ConcurrentModificationException的迭代器，因此不需要在容器迭代中加锁。</p>
</li>
<li><p>ConcurrentHashMap返回的迭代器具有弱一致性，而非“及时失败”的。</p>
</li>
<li><p>弱一致性的迭代器可以容许并发修改，当迭代器被创建时，它会遍历已有的元素，并且可以（但不保证）感应到在迭代器被创建后，对容器的修改</p>
</li>
<li><p>对整个Map进行操作的方法，比如size，isEmpty在容器并发特性上被轻微弱化。size值只是估计值，但这些方法在并发环境下几乎没用处，因为它们的目标是运动的。</p>
</li>
<li><p>相反，应该保证对最重要的操作进行性能优化，get、put、remove等<br><br><br><br></p>
</li>
<li><p>同步Map提供的一个特性是为独占的访问加锁，ConcurrentHashMap并没有实现。有必要使用同步Map的情景：</p>
<ul>
<li>原子化的加入一些映射(mapping)</li>
<li>对元素进行若干次迭代，在这期间需要看到元素以同样的顺序出现</li>
</ul>
</li>
<li><p>如何权衡：</p>
<ul>
<li>大多数情况ConcurrentHashMap，带来更好的可伸缩性</li>
<li>程序需要在独占访问中加锁时，使用同步Map</li>
</ul>
</li>
</ul>
<h3><span id="522-map附加的原子操作">5.2.2 Map附加的原子操作</span></h3><ul>
<li>ConcurrentHashMap不能在独占访问中被加锁，所有不能使用客户端加锁来创建新的原子操作。但是一些常见的复合操作，比如“缺少即加入”，“相等便移除(remove-if-equal)”，“相等便替换”，都已被实现为原子操作，并且这些操作已在ConcurrentMap接口中声明。</li>
</ul>
<pre><code>    //ConcurrentMap接口
    public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123;
        //只有当没有匹配到K的值时才插入
        V putIfAbsent(K key, V value);
        //只有当K与V匹配时才移除
        boolean remove(Object key, Object value);
        //只有当K与oldValue匹配时才移除
        boolean replace(K key, V oldValue, V newValue);
        //只有当K匹配某值时才取代
        V replace(K key, V value);
    &#125;</code></pre>
<h3><span id="523-copyonwritearraylist">5.2.3 CopyOnWriteArrayList</span></h3><ul>
<li><p>同步List的一个并发替代品</p>
<ul>
<li>更好的并发性</li>
<li>避免了在迭代期间对容器加锁和复制</li>
</ul>
</li>
<li><p>写入时复制(Copy-on-write)容器的线程安全性来源于这样一个事实，只要在有效的不可变对象被正确发布，那么访问它将不需要更多的同步。在每次修改时，它们会创建并重新发布一个新的容器拷贝，以此来实现可变性。写入时复制(Copy-on-write)容器的迭代器保留一个底层基础数组(the backing array)的引用。这个数组作为迭代器的起点，永远不会被修改，因此对它的同步只不过是为了确保数组内容的可见性。</p>
</li>
<li><p>因此多个线程可以对这个容器进行迭代，并且不会受到另一个或多个想要修改容器的线程带来的干涉。</p>
</li>
<li><p>写入时复制容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素严格与迭代器创建时相一致，不会考虑后续的修改<br><br></p>
</li>
<li><p>每次容器改变时复制基础数组需要一定的开销，特别是当容器比较大的时候；</p>
</li>
<li><p>当对容器迭代操作的频率远远高于对容器修改的频率时，使用写入时复制容器是个合理的选择。</p>
</li>
<li><p>这个准则准确描述了许多事件通知系统：递交一个通知需要迭代已注册的监听器，并调用其中每一个</p>
</li>
<li><p>在多数情况下，注册和注销一个事件监听器的次数要比收到事件通知的次数少很多。</p>
</li>
</ul>
<h2><span id="53-阻塞队列和生产者-消费者模式">5.3 阻塞队列和生产者-消费者模式</span></h2><ul>
<li><p>阻塞队列(Blocking queue)提供了可阻塞的put和take方法，它们与可定时的offer和poll是等价的。</p>
</li>
<li><p>如果Queue满了，put会被阻塞直到空间可用；如果Queue空，take会被阻塞直到有元素可用</p>
</li>
<li><p>Queue的长度可用有限，也可以无限；无限的Queue永远不会充满，所以它的put方法永远不会阻塞。<br><br></p>
</li>
<li><p>阻塞队列支持生产者-消费者模式。一个生产者-消费者设计分离了“识别需要完成的工作”和“执行工作”。</p>
</li>
<li><p>该模式不会发现一个工作便立即处理，而是把工作置入一个任务(to do)清单中，以备后期处理</p>
</li>
<li><p>该模式简化了开发，因为它解除了生产者类和消费者类之间相互依赖的代码。生产者和消费者以不同的或者变化的速度生产和消费着数据，生产者-消费着模式将这些活动解耦，因而简化了工作负荷的管理。</p>
</li>
<li><p>最常见的生产者-消费者设计是将线程池与工作队列相结合</p>
</li>
<li><p>阻塞队列简化了消费者的编码，因为take会保持阻塞直到可用数据出现。</p>
</li>
<li><p>如果生产者产生工作的速度总是比消费者处理的速度快，那么应用程序的工作条目会排在一个没有边界的队列中，最终耗尽内存。</p>
</li>
<li><p>put方法的阻塞特性大大简化了生产者的编码；如果使用一个有界队列，那么当队列充满的时候，生产者就会阻塞，暂不能生成更多的工作，从而给消费者时间来追赶进度。</p>
</li>
<li><p>阻塞队列同样提供了一个offer方法，如果条目不能被加入到队列里，它会返回一个失败状态。这使得你能够创建更多灵活的策略来处理超负荷工作，比如：</p>
<ul>
<li>减轻负载</li>
<li>序列化剩余工作条目并写入硬盘</li>
<li>减少生产者线程</li>
<li>用其他方法遏制生产者线程</li>
</ul>
</li>
<li><p>有界队列是强大的资源管理工具，用来建立可靠的应用程序：</p>
<ul>
<li>它们遏制那些产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮</li>
</ul>
</li>
</ul>
<p><br><br></p>
<ul>
<li>类库中包含一些BlockingQueue的实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但是却拥有比同步List更好的并发性能。</li>
<li>PriorityBlockingQueue是一个按优先级顺序排序的队列。可以比较元素本身的自然顺序(如果实现了Comparable接口)，也可以使用一个Comparator进行排序</li>
<li>SynchronousQueue，不是一个真正的队列，因为它不会为队列元素维护任何存储空间。不过，它维护一个排队的线程清单，这些线程等待把元素加入(enqueue)队列或者（dequeue）队列。<ul>
<li>直接移交工作，减少了生产者和消费者之间移动数据的延迟时间</li>
<li>比如把文件直接递给同事，而不是把文件发送到她的邮箱期待她一会可以得到此文件</li>
<li>没有存储的能力，所以除非另一个线程已经准备好参与移交工作，否则put和take会一直阻止。</li>
<li>SynchronousQueue这类队列只有在消费者充足的时候比较合适，它们总能为下一个任务做好准备</li>
</ul>
</li>
</ul>
<h3><span id="531-实例桌面搜索">5.3.1 实例：桌面搜索</span></h3><ul>
<li><p>有一种类型的程序适合分解为生产者和消费者：扫描本地驱动器并归档文件，为之后的搜索建立索引的代理，这类似与Google Desktop或者Windows索引服务。</p>
<ul>
<li><p>文件查找和建立索引划分给不同的活动</p>
</li>
<li><p>DiskCrawler表现了一个生产者任务，这个任务是搜索一个文件结构，找到符合给定标准的文件并把它们的名称放入工作队列</p>
</li>
<li><p>Indexer展现消费者从队列中取出文件名称并制定索引的任务</p>
<pre><code>  import java.io.File;
  import java.io.FileFilter;
  import java.util.concurrent.*;
  //桌面搜索应用程序中的生产者和消费者
  public class ProducerConsumer &#123;
      static class FileCrawler implements Runnable &#123;
          private final BlockingQueue&lt;File&gt; fileQueue;
          private final FileFilter fileFilter;
          private final File root;

          public FileCrawler(BlockingQueue&lt;File&gt; fileQueue,
                             final FileFilter fileFilter,
                             File root) &#123;
              this.fileQueue = fileQueue;
              this.root = root;
              this.fileFilter = new FileFilter() &#123;
                  public boolean accept(File f) &#123;
                      return f.isDirectory() || fileFilter.accept(f);
                  &#125;
              &#125;;
          &#125;

          private boolean alreadyIndexed(File f) &#123;
              return false;
          &#125;

          public void run() &#123;
              try &#123;
                  crawl(root);
              &#125; catch (InterruptedException e) &#123;
                  Thread.currentThread().interrupt();
              &#125;
          &#125;

          private void crawl(File root) throws InterruptedException &#123;
              File[] entries = root.listFiles(fileFilter);
              if (entries != null) &#123;
                  for (File entry : entries)
                      if (entry.isDirectory())
                          crawl(entry);
                      else if (!alreadyIndexed(entry))
                          fileQueue.put(entry);
              &#125;
          &#125;
      &#125;

      static class Indexer implements Runnable &#123;
          private final BlockingQueue&lt;File&gt; queue;

          public Indexer(BlockingQueue&lt;File&gt; queue) &#123;
              this.queue = queue;
          &#125;

          public void run() &#123;
              try &#123;
                  while (true)
                      indexFile(queue.take());
              &#125; catch (InterruptedException e) &#123;
                  Thread.currentThread().interrupt();
              &#125;
          &#125;

          public void indexFile(File file) &#123;
              // Index the file...
          &#125;;
      &#125;

      private static final int BOUND = 10;
      private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();

      public static void startIndexing(File[] roots) &#123;
          BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(BOUND);
          FileFilter filter = new FileFilter() &#123;
              public boolean accept(File file) &#123;
                  return true;
              &#125;
          &#125;;

          for (File root : roots)
              new Thread(new FileCrawler(queue, filter, root)).start();

          for (int i = 0; i &lt; N_CONSUMERS; i++)
              new Thread(new Indexer(queue)).start();
      &#125;
  &#125;</code></pre>
</li>
</ul>
</li>
<li><p>生产者-消费者模式带来的性能方面的提高</p>
</li>
<li><p>生产者受限于I/O，消费者受限于CPU</p>
</li>
</ul>
<h3><span id="532-连续的线程限制">5.3.2 连续的线程限制</span></h3><ul>
<li>在java.util.concurrent中实现的阻塞队列，全部都包含充分的内部同步，从而能安全地将对象从生产者线程发布到消费者线程。</li>
<li>对于可变对象，生产者-消费者设计和阻塞队列一起，为生产者和消费者之间移交对象所有权提供了**连续的线程限制(serial thread confinement)**。一个线程约束的对象完全由单一线程所有，但是所有权可以通过安全的发布被“转移”，这样其他线程只有唯一一个能够得到访问这个对象的权限，并且保证移交之后源线程不能访问它。</li>
</ul>
<h3><span id="533-双端队列和窃取工作">5.3.3 双端队列和窃取工作</span></h3><ul>
<li>Java 6 同样新增了两个容器类型，Deque和BlockingDeque，它们分别扩展了Queue和BlockingQueue。</li>
<li>Deque是一个双端队列，允许高效地在头和尾分别进行插入和移除。实现类是ArrayDeque和LinkedBlockingDeque</li>
<li>双端队列与一种叫做窃取工作(work stealing)的模式相关联。<ul>
<li>窃取工作中，每一个消费者都有一个自己的双端队列。</li>
<li>如果一个消费者完成了自己双端队列中的全部工作，它可以偷取其他消费者的双端队列中的末尾任务。</li>
<li>因为工作者线程并不会竞争一个共享的任务队列，所以<strong>窃取工作模式</strong>比传统的生产者-消费者设计有更佳的可伸缩性</li>
<li>大多数时候它们访问自己的双端队列，减少竞争</li>
<li>当一个工作者必须要访问另一个队列时，它会从尾部截取，而不是头部，从而进一步降低了对双端队列的争夺</li>
</ul>
</li>
<li>窃取工作适用于解决消费者和生产者同体的问题——当运行到一个任务的某单元时，可能会识别出更多的任务。<ul>
<li>比如，Web Crawler处理一个页面时，通常会发现有更多页面可以搜索。</li>
<li>当双端队列为空时，会去其他队列的队尾寻找新的任务，这样能确保每一个线程都保持忙碌状态。</li>
</ul>
</li>
</ul>
<h2><span id="54-阻塞和可中断的方法">5.4 阻塞和可中断的方法</span></h2><ul>
<li><p>线程可能会因为几种原因被阻塞或暂停：</p>
<ul>
<li>等待I/O操作结束</li>
<li>等待获得一个锁，</li>
<li>等待从Thread.sleep中唤醒</li>
<li>等待另一个线程的计算结果</li>
</ul>
</li>
<li><p>当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态(BLOCKED、WAITING、或是TIMED_WAITING)。</p>
</li>
<li><p>当一个方法能够抛出InterruptedException的时候，是在告诉你这个方法是一个可阻塞方法。</p>
</li>
<li><p>Thread提供了interrupt方法，用来中断一个线程，或者查询某线程是否已经被中断。每一个线程都有一个布尔类型的属性，这个属性代表了线程的中断状态；中断线程时需要设置这个值。</p>
</li>
<li><p>中断是一种<strong>协作机制</strong>。</p>
<ul>
<li>一个线程不能迫使其他线程停止正在做的事情，或者去做其他事情</li>
<li>当线程A中断B时，A仅仅是要求B在达成某个方便停止的关键点时，停止正在做的事情——如果它这样做是正确的。</li>
<li>从时间角度来看，响应中断的阻塞方法，可以更容易地取消耗时的活动。</li>
</ul>
</li>
<li><p>当你在代码中调用了一个会抛出InterruptedException的方法时，你自己的方法也就成为了一个阻塞方法，要为响应中断作好准备。类库代码中有两种基本选择：</p>
<ul>
<li>传递InterruptedException。传递给调用者。</li>
<li>恢复中断。代码是Runnable的一部分，必须捕获InterruptedException，并且在当前线程中通过调用interrupt从中断中恢复，这样调用栈中更高层的代码可以发现中断已经发生。</li>
</ul>
</li>
<li><p><strong>不应该</strong>捕获InterruptedException，但不作任何响应，因为这样会丢失线程中断的证据，从而剥夺了上层栈的代码处理中断的机会。</p>
</li>
<li><p><strong>只有一种</strong>情况允许掩盖中断：你<strong>扩展</strong>了Thread，并因此控制了所有处于调用栈上层的代码。</p>
<pre><code>  //恢复中断状态，避免掩盖中断
  public class TaskRunnable implements Runnable &#123;
      BlockingQueue&lt;Task&gt; queue;

      public void run() &#123;
          try &#123;
              processTask(queue.take());
          &#125; catch (InterruptedException e) &#123;
              // restore interrupted status
              Thread.currentThread().interrupt();
          &#125;
      &#125;

      void processTask(Task task) &#123;
          // Handle the task
      &#125;

      interface Task &#123;
      &#125;
  &#125;</code></pre>
</li>
</ul>
<h2><span id="55-synchronizer">5.5 Synchronizer</span></h2><ul>
<li>Synchronizer是一个对象，它<strong>根据本身的状态</strong>调节线程的控制流。<ul>
<li>阻塞队列可以扮演一个Synchronizer的角色</li>
<li>信号量(semaphore)</li>
<li>关卡(barrier)</li>
<li>闭锁(latch)</li>
</ul>
</li>
</ul>
<h3><span id="551-闭锁">5.5.1 闭锁</span></h3><ul>
<li><p>闭锁是一种Synchronizer，它可以延迟线程的进度直到线程到达**终止(terminal)**状态。</p>
</li>
<li><p>一个闭锁工作起来就像一道大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，允许所有线程通过。</p>
</li>
<li><p>一旦闭锁到达了终点终点状态，它就不能够再改变状态了，所以它会永远爆出敞开状态。</p>
</li>
<li><p>闭锁用来确保特定活动直到其他的活动完成后才发生，比如：</p>
<ul>
<li>确保一个计算不会执行，直到它需要的资源被初始化。一个二元闭锁(两个状态)可以用来表达“资源R已经被初始化”，并且所有需要用到R的活动首先都要在闭锁中等待。</li>
<li>确保一个服务不会开始，直到它依赖的其他服务都已经开始。每一个服务会包含一个相关的二元闭锁；开启服务S会首先等待闭锁S中所依赖的其他服务，在启动结束后，会释放闭锁S，这样所有依赖S的服务也可以开始处理了。</li>
<li>等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。</li>
</ul>
</li>
<li><p>CountDownLatch是一个灵活的闭锁实现，用于上述各种情况</p>
<ul>
<li>允许一个时间集的发生</li>
<li>闭锁的状态包括一个计数器，初始化为一个正数，用来表现需要等待的事件数。</li>
<li>countDown方法对计数器做减操作，表示一个事件已经发生了，而await方法等待计数器达到0，此时所有需要等待的事件都已发生。</li>
<li>如果计数器入口时值为非-，await会一直阻塞直到计数器为0，或者等待线程中断以及超时。</li>
</ul>
</li>
<li><p>TestHarness阐释了闭锁的两种常见用法。</p>
<ul>
<li><p>TestHarness创建了一些线程，并发地执行给定的任务</p>
</li>
<li><p>它使用两个闭锁，一个“开始阀门”和一个“结束阀门”。这个开始阀门将计数器初始化为1.结束阀门将计数器初始化为工作线程的数量。</p>
</li>
<li><p>每一个工作线程要做的第一件事情是等待开始阀门打开；这样能确保直到所有线程都做好准备时，才开始工作。每个线程的最后一个工作是为结束阀门减1：这样做使控制线程有效地等待，直到最后一个工作线程完成任务，这样就能计算整个的用时了。        </p>
<pre><code>  //在时序测试中，使用CountDownLatch来启动和停止线程
  public class TestHarness &#123;
      public long timeTasks(int nThreads, final Runnable task)
              throws InterruptedException &#123;
          final CountDownLatch startGate = new CountDownLatch(1);
          final CountDownLatch endGate = new CountDownLatch(nThreads);

          for (int i = 0; i &lt; nThreads; i++) &#123;
              Thread t = new Thread() &#123;
                  public void run() &#123;
                      try &#123;
                          startGate.await();
                          try &#123;
                              task.run();
                          &#125; finally &#123;
                              endGate.countDown();
                          &#125;
                      &#125; catch (InterruptedException ignored) &#123;
                      &#125;
                  &#125;
              &#125;;
              t.start();
          &#125;

          long start = System.nanoTime();
          startGate.countDown();
          endGate.await();
          long end = System.nanoTime();
          return end - start;
      &#125;
  &#125;</code></pre>
</li>
</ul>
</li>
</ul>
<h3><span id="552-futuretask">5.5.2 FutureTask</span></h3><ul>
<li><p>FutureTask同样可以作为闭锁。（FutureTask的实现描述了一个抽象的可携带结果的计算）</p>
</li>
<li><p>FutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable，并且有3个状态：等待，运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。</p>
</li>
<li><p>Future.get的行为依赖于任务的状态。如果他已经完成，get可以立即得到返回结果，否则会被阻塞直到任务转入完成状态，然后会返回结果或抛出异常。FutureTask把计算的结果从运行计算的线程传送到需要这个结果的线程；FutureTask的规约保证了这种传递建立在结果的安全发布基础之上。</p>
</li>
<li><p>Executor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时计算，而且可以在真正需要计算结果之前就启动它们开始计算。</p>
</li>
<li><p>以下的PreLoader使用了FutureTask来执行一个代价昂贵的计算，结果稍后会被用到；尽早开始计算，你可以减少等待结果所需要花费的时间。</p>
<pre><code>  //使用FutureTask预载稍后需要的数据
  public class Preloader &#123;
      ProductInfo loadProductInfo() throws DataLoadException &#123;
          return null;
      &#125;

      private final FutureTask&lt;ProductInfo&gt; future =
          new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() &#123;
              public ProductInfo call() throws DataLoadException &#123;
                  return loadProductInfo();
              &#125;
          &#125;);
      private final Thread thread = new Thread(future);

      public void start() &#123; thread.start(); &#125;

      public ProductInfo get()
              throws DataLoadException, InterruptedException &#123;
          try &#123;
              return future.get();
          &#125; catch (ExecutionException e) &#123;
              Throwable cause = e.getCause();
              if (cause instanceof DataLoadException)
                  throw (DataLoadException) cause;
              else
                  throw LaunderThrowable.launderThrowable(cause);
          &#125;
      &#125;

      interface ProductInfo &#123;
      &#125;
  &#125;

  class DataLoadException extends Exception &#123; &#125;</code></pre>
</li>
</ul>
<h3><span id="553-信号量">5.5.3 信号量</span></h3><ul>
<li><p>计数信号量（Counting semaphore）用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。</p>
</li>
<li><p>计数信号量可以用来实现资源池或者给一个容器限定边界</p>
</li>
<li><p>一个Semaphore管理一个有效的<strong>许可(permit)集</strong>；许可的初始量通过构造函数传递给Semaphore。活动能够获得许可（只要还有剩余许可），并在使用之后释放许可。如果已经没有可用的许可，那么acquire会被阻塞，直到有可用的为止(或者直到被中断或者操作超时)。release方法向信号量返回一个许可。计算信号量的一种退化形式是二元信号量：一个计数初始值为1的Semaphore。二元信号量可用作**互斥(mutex)**锁，它有不可重入锁的语意；谁拥有这个唯一的许可，就拥有了互斥锁。</p>
</li>
<li><p>信号量可以用来实现资源池，比如数据库连接池。有一个定长的池，当它为空时，你向它请求资源会失败。构建这种池很容易，然而当池为空时，你真正需要做的是<strong>阻塞</strong>它，然后在它不空时，再次解除阻塞。如果你以池的大小初始化一个Semaphore，在你从池中获取资源之前，你应该调用acquire方法获取一个许可，调用release把许可放回资源池。acquire会一直阻塞，直到池不再为空。</p>
</li>
<li><p>可以使用Semaphore把任何容器转化为有界的阻塞容器，像如下的BoundedHashSet所示的一样。信号量被初始化为容器所期望容量的最大值。add操作在向底层容器添加条目之前，需要先获取一个许可。事实上，如果add操作没有能加入任何东西，它会立刻释放一个许可。同样，一个成功的remove操作释放一个许可，使更多的元素能够加入其中。底层的Set实现并不知道边界在哪里；这是由BoundedHashSet控制的。</p>
<pre><code>  //使用信号量来约束容器
  public class BoundedHashSet &lt;T&gt; &#123;
      private final Set&lt;T&gt; set;
      private final Semaphore sem;

      public BoundedHashSet(int bound) &#123;
          this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());
          sem = new Semaphore(bound);
      &#125;

      public boolean add(T o) throws InterruptedException &#123;
          sem.acquire();
          boolean wasAdded = false;
          try &#123;
              wasAdded = set.add(o);
              return wasAdded;
          &#125; finally &#123;
              if (!wasAdded)
                  sem.release();
          &#125;
      &#125;

      public boolean remove(Object o) &#123;
          boolean wasRemoved = set.remove(o);
          if (wasRemoved)
              sem.release();
          return wasRemoved;
      &#125;
  &#125;</code></pre>
</li>
</ul>
<h3><span id="554-关卡">5.5.4 关卡</span></h3><ul>
<li><p>闭锁是一次性使用的对象；一旦进入到最终状态，就不能被重置。</p>
</li>
<li><p>关卡(barrier)类似于闭锁，它们都能够阻塞一组线程，直到某些事件发生。与闭锁不同在于，所有线程必须<strong>同时</strong>到达关卡点，才能继续处理。</p>
<ul>
<li>闭锁等待的是事件</li>
<li>关卡等待的是其他线程</li>
</ul>
</li>
<li><p>关卡实现的协议，就像一些家庭成员指定商场中的集合地点：我们每个人6点在麦当劳见，到了以后不见不散，之后我们再决定接下来做什么。</p>
</li>
<li><p>CyclicBarrier允许一个给定数量的成员多次几种在一个<strong>关卡点</strong>，这在并行迭代算法中非常有用，这个算法会把一个问题拆分成一系列相互独立的子问题。当线程到达关卡点时，调用await，await会被阻塞，直到所有线程都到达关卡点。如果所有线程到达了关卡点，关卡就被成功地突破，这样所有线程都被释放，关卡会重置以备下一次使用。如果对await调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有对await未完成的调用都通过BrokenBarrierException终止。如果成功地通过关卡，await为每一个线程返回唯一的到达索引号，可以用它来“选举”产生一个领导，在下一次迭代中承担一些特殊工作。CyclicBarrier也允许你向构造函数传递一个**关卡行为(barrier action)**；这是一个Runnable，当成功通过关卡的时候，会(在一个子任务线程中)执行，但是在阻塞线程被释放之前是不能执行的。</p>
</li>
<li><p>关卡通常被用来模拟这种情况：</p>
<ul>
<li>一个步骤的计算可以并行完成，但是要求必须完成所有与一个步骤相关的工作后才能进入下一步。</li>
</ul>
</li>
<li><p>以下的CellularAutomata演示了使用关卡来计算一个细胞的自动化模拟，比如Conway’s的生命游戏。</p>
<pre><code>  //在一个细胞的自动系统中用CyclicBarrier协调计算
  public class CellularAutomata &#123;
      private final Board mainBoard;
      private final CyclicBarrier barrier;
      private final Worker[] workers;

      public CellularAutomata(Board board) &#123;
          this.mainBoard = board;
          int count = Runtime.getRuntime().availableProcessors();
          this.barrier = new CyclicBarrier(count,
                  new Runnable() &#123;
                      public void run() &#123;
                          mainBoard.commitNewValues();
                      &#125;&#125;);
          this.workers = new Worker[count];
          for (int i = 0; i &lt; count; i++)
              workers[i] = new Worker(mainBoard.getSubBoard(count, i));
      &#125;

      private class Worker implements Runnable &#123;
          private final Board board;

          public Worker(Board board) &#123; this.board = board; &#125;
          public void run() &#123;
              while (!board.hasConverged()) &#123;
                  for (int x = 0; x &lt; board.getMaxX(); x++)
                      for (int y = 0; y &lt; board.getMaxY(); y++)
                          board.setNewValue(x, y, computeValue(x, y));
                  try &#123;
                      barrier.await();
                  &#125; catch (InterruptedException ex) &#123;
                      return;
                  &#125; catch (BrokenBarrierException ex) &#123;
                      return;
                  &#125;
              &#125;
          &#125;

          private int computeValue(int x, int y) &#123;
              // Compute the new value that goes in (x,y)
              return 0;
          &#125;
      &#125;

      public void start() &#123;
          for (int i = 0; i &lt; workers.length; i++)
              new Thread(workers[i]).start();
          mainBoard.waitForConvergence();
      &#125;

      interface Board &#123;
          int getMaxX();
          int getMaxY();
          int getValue(int x, int y);
          int setNewValue(int x, int y, int value);
          void commitNewValues();
          boolean hasConverged();
          void waitForConvergence();
          Board getSubBoard(int numPartitions, int index);
      &#125;
  &#125;</code></pre>
</li>
<li><p>Exchanger是关卡的另一种形式，它是一种两步关卡，在关卡点会交换数据。当两方进行的活动不对称时，Exchanger是非常有用的，比如当一个线程向缓冲区写入一个数据，这时另一个线程充当消费者使用这个数据：这些线程可以使用Exchanger进行会面，并用完整的缓冲与空缓冲进行交换。当两个线程通过Exchanger交换对象时，交换为双方的对象建立了一个安全的发布。</p>
</li>
<li><p>交换的时机取决于应用程序的响应需求。</p>
<ul>
<li>最简单的方案是当写入任务的缓冲写满时就发生交换，并且当清除任务的缓冲清空后也发生交换；这样做使交换的次数最少，但是如果新数据的到达率不可预测的话，处理一些数据会发生延迟。</li>
<li>另一个方案是，缓冲满了就发生交换，但是当缓冲部分充满却已经存在了特定长的时间时，也会发生交换。</li>
</ul>
</li>
</ul>
<h2><span id="56-为计算结果建立高效-可伸缩的高速缓存">5.6 为计算结果建立高效、可伸缩的高速缓存</span></h2><ul>
<li><p>几乎每一个服务器都使用某种形式的高速缓存。复用已有的计算结果可以缩短等待时间，提高吞吐量，代价是占用更多的内存。</p>
</li>
<li><p>我们将开发一个高效的、可伸缩的高速缓存，为一个昂贵的函数保存计算结果。</p>
</li>
<li><p>让我们从最明显的方案开始——一个简单的HashMap——之后着眼于它在并发方面的劣势，并且讨论如何解决。</p>
</li>
<li><p>以下的Computable&lt;A,V&gt;接口描述了一个功能，输入类型是A，输出结果的类型是V。ExpensiveFunction实现了Computable，需要花很长时间来计算结果，我们喜欢创建一个Computable包装器，使它记住之前的计算结果，并封装缓存步骤(这项技术被称为备忘录memoization)</p>
<pre><code>  //尝试使用HashMap和同步来初始化缓存
  public class Memoizer1 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;
      @GuardedBy(&quot;this&quot;) private final Map&lt;A, V&gt; cache = new HashMap&lt;A, V&gt;();
      private final Computable&lt;A, V&gt; c;

      public Memoizer1(Computable&lt;A, V&gt; c) &#123;
          this.c = c;
      &#125;

      public synchronized V compute(A arg) throws InterruptedException &#123;
          V result = cache.get(arg);
          if (result == null) &#123;
              result = c.compute(arg);
              cache.put(arg, result);
          &#125;
          return result;
      &#125;
  &#125;</code></pre>
</li>
</ul>
<pre><code>    interface Computable &lt;A, V&gt; &#123;
        V compute(A arg) throws InterruptedException;
    &#125;

    class ExpensiveFunction
            implements Computable&lt;String, BigInteger&gt; &#123;
        public BigInteger compute(String arg) &#123;
            // after deep thought...
            return new BigInteger(arg);
        &#125;
    &#125;</code></pre>
<ul>
<li><p>Memoizer1做了第一种尝试：使用HashMap存储前面的计算结果。compute方法首先检查期待的结果是否已经在缓存中，如果有则返回之前计算的数值。否则，会进行计算并返回之前结果存储在HashMap中。</p>
</li>
<li><p>HashMap不是线程安全，所以同步了整个compute方法。这保证了线程安全，但是却带来一个明显的可伸缩性问题：一次只有一个线程能够执行compute。如果另外一个线程正在忙于计算结果，其他调用compute的线程可能被阻塞很长时间。如果有多个线程都在排队等待尚未计算出来的结果，那么事实上，compute可能会比不使用备忘录形式花费更长的时间。这不是我们希望通过缓存得到的性能优化结果。</p>
</li>
<li><p>以下代码用ConcurrentHashMap取代HashMap，改进了这种糟糕的并发行为。</p>
<pre><code>  //用ConcurrentHashMap取代HashMap
  public class Memoizer2 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;
      private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;();
      private final Computable&lt;A, V&gt; c;

      public Memoizer2(Computable&lt;A, V&gt; c) &#123;
          this.c = c;
      &#125;

      public V compute(A arg) throws InterruptedException &#123;
          V result = cache.get(arg);
          if (result == null) &#123;
              result = c.compute(arg);
              cache.put(arg, result);
          &#125;
          return result;
      &#125;
  &#125;</code></pre>
</li>
<li><p>Memoizer2 比 Memoizer1具有更好的并发性：多线程可以真正并发地使用它了。但是作为高速缓存仍然存在缺陷：</p>
<ul>
<li>当两个线程同时调用compute时，存在一个漏洞，会造成它们计算相同的值</li>
</ul>
</li>
<li><p>我们希望无论用什么方法，能够表现出“线程X正在计算f(27)”，这样如果另一个线程到达并查找f(27)时，它能够判断出最有效的方法是等待线程X，直到线程结束，然后动动嘴“嘿，f(27)的结果是多少？”。</p>
</li>
<li><p>有一个类可以做这些事：<strong>FutureTask</strong>。FutureTask代表了一个计算的过程，可能已经结束，也可能正在运行中。FutureTask.get只要结果可用，就会立刻将结果返回；否则它会一直阻塞，直到结果被计算出来，并返回</p>
</li>
<li><p>以下的Memoizer3为缓存的值重新定义可存储Map，用ConcurrentHashMap&lt;A,Future<v>&gt;取代了ConcurrentHashMap&lt;A, V&gt;。Memoizer3首先检查一个相应的计算是否已经开始，(Memoizer2与它相反，它判断计算是否完成)。如果不是，就创建一个FutureTask，把它注册到Map中，并开始计算；如果是，那么它会等待正在进行的计算。结果可能很快就得到，或者正在运算的过程中——但是这对于调用者Future.get来说是透明的。</v></p>
<pre><code>  //用FutureTask记录包装器
  public class Memoizer3 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;
      private final Map&lt;A, Future&lt;V&gt;&gt; cache
              = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();
      private final Computable&lt;A, V&gt; c;

      public Memoizer3(Computable&lt;A, V&gt; c) &#123;
          this.c = c;
      &#125;

      public V compute(final A arg) throws InterruptedException &#123;
          Future&lt;V&gt; f = cache.get(arg);
          if (f == null) &#123;
              Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123;
                  public V call() throws InterruptedException &#123;
                      return c.compute(arg);
                  &#125;
              &#125;;
              FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);
              f = ft;
              cache.put(arg, ft);
              ft.run(); // call to c.compute happens here
          &#125;
          try &#123;
              return f.get();
          &#125; catch (ExecutionException e) &#123;
              throw LaunderThrowable.launderThrowable(e.getCause());
          &#125;
      &#125;
  &#125;</code></pre>
</li>
<li><p>Memoizer3近乎完美，但有个缺陷：</p>
<ul>
<li><p>两个线程可能同时计算相同的值。这个漏洞因为compute中的if代码块是非原子(nonatomic)的检查再运行序列，仍然存在这个可能：</p>
<ul>
<li>两个线程几乎同一时间调用compute计算相同的值，双方都没有在缓存中找到期望的值，并都开始计算。</li>
</ul>
</li>
<li><p>这个问题是因为复合操作(缺少即加入)运行在底层的map中，不能加锁来使它原子化。利用putIfAbsent方法，可消除这个缺陷</p>
<pre><code>  //Memoizer最终实现
  public class Memoizer &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;
      private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache
              = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();
      private final Computable&lt;A, V&gt; c;

      public Memoizer(Computable&lt;A, V&gt; c) &#123;
          this.c = c;
      &#125;

      public V compute(final A arg) throws InterruptedException &#123;
          while (true) &#123;
              Future&lt;V&gt; f = cache.get(arg);
              if (f == null) &#123;
                  Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123;
                      public V call() throws InterruptedException &#123;
                          return c.compute(arg);
                      &#125;
                  &#125;;
                  FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);
                  f = cache.putIfAbsent(arg, ft);
                  if (f == null) &#123;
                      f = ft;
                      ft.run();
                  &#125;
              &#125;
              try &#123;
                  return f.get();
              &#125; catch (CancellationException e) &#123;
                  cache.remove(arg, f);
              &#125; catch (ExecutionException e) &#123;
                  throw LaunderThrowable.launderThrowable(e.getCause());
              &#125;
          &#125;
      &#125;
  &#125;</code></pre>
</li>
</ul>
</li>
<li><p>缓存一个Future而不是一个值，带来了**缓存污染(cache pollution)**的可能性：如果计算被取消或者失败，未来尝试过对这个值进行计算都会表现为取消或者失败。为了避免这个结果Memoizer如果发现计算被取消，就会把Future从缓存中移除；如果发现有RuntimeException，也会移除Future，这样新请求中的计算才有可能成功。Memoizer同样有缓存过期的问题，但是这些可以通过FutureTask的一个子类来完成，它会为每一个结果关联一个过期时间，并周期性地扫描缓存中过期的访问。</p>
</li>
<li><p>使用Memoizer为因式分解的servlet缓存结果</p>
<pre><code>  public class Factorizer extends GenericServlet implements Servlet &#123;
      private final Computable&lt;BigInteger, BigInteger[]&gt; c =
              new Computable&lt;BigInteger, BigInteger[]&gt;() &#123;
                  public BigInteger[] compute(BigInteger arg) &#123;
                      return factor(arg);
                  &#125;
              &#125;;
      private final Computable&lt;BigInteger, BigInteger[]&gt; cache
              = new Memoizer&lt;BigInteger, BigInteger[]&gt;(c);

      public void service(ServletRequest req,
                          ServletResponse resp) &#123;
          try &#123;
              BigInteger i = extractFromRequest(req);
              encodeIntoResponse(resp, cache.compute(i));
          &#125; catch (InterruptedException e) &#123;
              encodeError(resp, &quot;factorization interrupted&quot;);
          &#125;
      &#125;

      void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;
      &#125;

      void encodeError(ServletResponse resp, String errorString) &#123;
      &#125;

      BigInteger extractFromRequest(ServletRequest req) &#123;
          return new BigInteger(&quot;7&quot;);
      &#125;

      BigInteger[] factor(BigInteger i) &#123;
          // Doesn&#39;t really factor
          return new BigInteger[]&#123;i&#125;;
      &#125;
  &#125;</code></pre>
</li>
</ul>
<p></p>


  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/about">白色蜗牛</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-%E6%9E%84%E5%BB%BA%E5%9D%97/">https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/05-%E6%9E%84%E5%BB%BA%E5%9D%97/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/Java并发编程/part-1/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">part_1 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/Java并发编程/04-组合对象/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">04.组合对象 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="vcomments"></div>
  
  <script>
    loadScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js");
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();
      new Valine({
        el: '#vcomments',
        appId: 'Ro9jzghVgwRgtnGQQ99MFbAK-9Nh9j0Va',
        appKey: 'rbA6uGwupFqEcTUAugUoXn2B',
        placeholder: '留下你的足迹吧~也可以加我微信 919201148，互换友链~~~',
        path: window.location.pathname,
        avatar: 'robohash',
        meta: ["nick","mail","link"],
        pageSize: '10',
        lang: '',
        visitor: 'true',
        highlight: true,
        recordIP: false,
        
        
        
        enableQQ: 'false',
        requiredFields: [],
      });
    };
  </script>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.1 同步容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.1 同步容器出现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.2 迭代器和ConcurrentModificationException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.3 隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.2 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.1 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.2 Map附加的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.3 CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.3 阻塞队列和生产者-消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.1 实例：桌面搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.2 连续的线程限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.3 双端队列和窃取工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.4 阻塞和可中断的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.5 Synchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.1 闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.2 FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.3 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.4 关卡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.6 为计算结果建立高效、可伸缩的高速缓存</span></a></li></ol>
</div>

<!-- 百度自动推送链接-->
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/logo.jpg" class="author-img">

<p class="author-name">蜗牛 Java 之家</p>
<p class="author-description">Java 程序员的成长进阶社区</br>(Java for You)。</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>107</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>11</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>118</span>
    <span>标签</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png">
        <i class="iconfont icon-wechat society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/huayonglun/">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="http://weibo.com/huayonglun">
        <i class="iconfont icon-sina society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.1 同步容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.1 同步容器出现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.2 迭代器和ConcurrentModificationException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.3 隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.2 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.1 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.2 Map附加的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.3 CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.3 阻塞队列和生产者-消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.1 实例：桌面搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.2 连续的线程限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.3 双端队列和窃取工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.4 阻塞和可中断的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.5 Synchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.1 闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.2 FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.3 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.4 关卡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.6 为计算结果建立高效、可伸缩的高速缓存</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/教程">
        <div class="categories-list-item">
          教程
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/Java">
        <div class="categories-list-item">
          Java
          <span class="categories-list-item-badge">14</span>
        </div>
      </a>
    
      <a href="/categories/Java并发编程">
        <div class="categories-list-item">
          Java并发编程
          <span class="categories-list-item-badge">18</span>
        </div>
      </a>
    
      <a href="/categories/Linux">
        <div class="categories-list-item">
          Linux
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/spring">
        <div class="categories-list-item">
          spring
          <span class="categories-list-item-badge">21</span>
        </div>
      </a>
    
      <a href="/categories/struts2">
        <div class="categories-list-item">
          struts2
          <span class="categories-list-item-badge">16</span>
        </div>
      </a>
    
      <a href="/categories/夯实基础系列">
        <div class="categories-list-item">
          夯实基础系列
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/思维">
        <div class="categories-list-item">
          思维
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/数据库">
        <div class="categories-list-item">
          数据库
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/算法">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">25</span>
        </div>
      </a>
    
      <a href="/categories/网络">
        <div class="categories-list-item">
          网络
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\Java" title="Java"><div class="tags-list-item">Java</div></a>
    
    <a href="\tags\ssh" title="ssh"><div class="tags-list-item">ssh</div></a>
    
    <a href="\tags\spring" title="spring"><div class="tags-list-item">spring</div></a>
    
    <a href="\tags\Java并发" title="Java并发"><div class="tags-list-item">Java并发</div></a>
    
    <a href="\tags\struts2" title="struts2"><div class="tags-list-item">struts2</div></a>
    
    <a href="\tags\bean" title="bean"><div class="tags-list-item">bean</div></a>
    
    <a href="\tags\树" title="树"><div class="tags-list-item">树</div></a>
    
    <a href="\tags\AOP" title="AOP"><div class="tags-list-item">AOP</div></a>
    
    <a href="\tags\分布式" title="分布式"><div class="tags-list-item">分布式</div></a>
    
    <a href="\tags\链表" title="链表"><div class="tags-list-item">链表</div></a>
    
    <a href="\tags\装配属性" title="装配属性"><div class="tags-list-item">装配属性</div></a>
    
    <a href="\tags\集合" title="集合"><div class="tags-list-item">集合</div></a>
    
    <a href="\tags\二叉树" title="二叉树"><div class="tags-list-item">二叉树</div></a>
    
    <a href="\tags\查找" title="查找"><div class="tags-list-item">查找</div></a>
    
    <a href="\tags\排序" title="排序"><div class="tags-list-item">排序</div></a>
    
    <a href="\tags\同步" title="同步"><div class="tags-list-item">同步</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">

  <!-- 我的公众号 -->
  
  <article class="card card-content toc-card">
    <div style="float: left; ">
      <img class="adv" style="width: 100%; height: 100%; border: solid 1px #ddd;" src="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608142536200-image.png">
    </div>
    <div style="float: left; margin-left: 17px; margin-top: 12px;">
        <div style="font-size: 18px; margin-bottom: 12px;color:#159957;"><b>微信搜一搜: 蜗牛互联网</b></div>
        <small style="font-size: 0.9em;">
          👉「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyboCy8Drh8AWNqE_DUROg">技术干货</a>」每周推送<br>
          👉「<a href="https://java4u.cn/resources/">免费资料</a>」随时领取<br>
          👉「<a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608143152021-image.png">优质社群</a>」随时加入<br>
        </small>
    </div>
    <div style="clear: both;"></div>
    <div style="font-size: 0.8em; margin: 15px 0 15px 0;">
      <a href="" target="_blank" style="color:#159957;font-size: 14px;" rel="noopener noreferrer">扫描上方二维码，关注我的公众号</a>
      <br>
    </div>
  </article>


  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.1 同步容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.1 同步容器出现的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.2 迭代器和ConcurrentModificationException</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.1.3 隐藏迭代器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.2 并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.1 ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.2 Map附加的原子操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.2.3 CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.3 阻塞队列和生产者-消费者模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.1 实例：桌面搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.2 连续的线程限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.3.3 双端队列和窃取工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.4 阻塞和可中断的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.5 Synchronizer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.1 闭锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.2 FutureTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.3 信号量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5.5.4 关卡</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">5.6 为计算结果建立高效、可伸缩的高速缓存</span></a></li></ol>
  </article>
  

  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-15</div>
        <a href="/course/cai_yun_xiao_yi/"><div class="recent-posts-item-content">彩云小译：最佳的网页翻译插件</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-14</div>
        <a href="/course/markmap/"><div class="recent-posts-item-content">最佳的思维导图生成工具： markmap 使用教程</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-13</div>
        <a href="/course/hexo_site_course/"><div class="recent-posts-item-content">建站神器：Hexo+Kaze+Gitee Pages 搭建静态博客网站</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2019-01-24</div>
        <a href="/思维/知识的诅咒：为什么你觉得显而易见，而对方却无法理解/"><div class="recent-posts-item-content">知识的诅咒：为什么你觉得显而易见，而对方却无法理解</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      
      <!-- copyringt-->
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2020
        </span>
        &nbsp;
        <a href="/" class="footer-link">蜗牛 Java 之家 </a>
      </div>

       <!-- copyringt-->
       <div class="footer-dsc">
        <center><span>
        <a href="https://java4u.cn/resources/" target="_blank">Java 程序员最全资源下载</a> - <a href="https://java4u.cn/links/" target="_blank">友情链接</a>
        </span></center>
      </div>
     
    </div>

    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  

  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>