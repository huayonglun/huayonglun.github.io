<!DOCTYPE html>
<html  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  <link rel="icon" href="/img/logo.jpg">
  <title>10.避免活跃度危险&nbsp; | &nbsp;Java for You</title>
  
  
  <meta property="og:title" content="10.避免活跃度危险">
  
  
  <meta property="og:url" content="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%8D%B1%E9%99%A9/index.html">
  
  
  <meta property="og:img" content="/img/logo.jpg">
  
  
  <meta property="og:img" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2016-05-04">
  <meta property="og:article:modified_time" content="2020-12-19">
  <meta property="og:article:author" content="蜗牛 Java 之家">
  
  
  <meta property="og:article:tag" content="Java">
  
  <meta property="og:article:tag" content="Java并发">
  
  <meta property="og:article:tag" content="避免活跃度危险">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  <link rel="prefetch" href="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  


  <!-- 百度站长工具验证 -->
  <meta name="baidu-site-verification" content="code-9cIsKsXy75" />

  <!-- 必应站长工具验证-->
  <meta name="msvalidate.01" content="81AA8F485E800B7335F07A558BE9A636" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22LNC79YC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22LNC79YC');
</script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.jpg" alt="logo">
      
      <span class="navbar-logo-dsc">蜗牛 Java 之家</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/resources" class="navbar-menu-item">
    
    免费资源
    
    </a>
    
    <a href="/tools" class="navbar-menu-item">
    
    免费工具
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      10.避免活跃度危险
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2016-05-04T04:00:00.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2016-05-04</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/Java并发编程/" class="post-meta-link">Java并发编程</a>
    
    
    
    <span class="dot"></span>
    <span>4.7k 字</span>
    

    <span class="dot"></span>
    <!-- 增加阅读量统计样式代码 -->
    
    <!-- id 将作为查询条件 -->
    <i class="iconfont icon-wodebaobiao" style="margin-right: 2px; font-size: 1.15rem;"></i>
    <span id="/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%8D%B1%E9%99%A9/" class="leancloud_visitors" data-flag-title="10.避免活跃度危险">
      <em class="post-meta-item-text">阅读量 </em>
      <i class="leancloud-visitors-count"></i>
    </span>

  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Java/" class="post-meta-link">Java</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/Java并发/" class="post-meta-link">Java并发</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/避免活跃度危险/" class="post-meta-link">避免活跃度危险</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <ul>
<li>安全性和活跃度通常相互牵制。我们使用锁来保证线程安全，但是滥用锁可能引起**锁顺序死锁(lock-ordering deadlock)**。</li>
<li>我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的**资源死锁(resource deadlock)**。</li>
<li>这一章将讲述一些引发活跃度失败的原因，以及避免发生这些失败的方法。</li>
</ul>
<h2><span id="101-死锁">10.1 死锁</span></h2><ul>
<li>经典的“哲学家进餐问题”很好的解释了死锁。</li>
<li>当一个线程永远占有一个锁，而其他线程尝试去获得这个锁，那么它们将永远被阻塞。当线程A占有锁L时，想要获得锁M，但是同时，线程B持有M，并尝试获得L，两个线程将永远等待下去。这种情况是死锁最简单的形式(或称**致命的拥抱,deadly embrace)**，发生在多个线程因为环路的锁依赖关系而永远等待的情况下。(把这些线程假想为有向图的节点，图的边表现了这个关系：线程A等待线程B占有的资源，如果图最后连成了一个环路，那么死锁也就产生了。)</li>
<li>数据库系统的设计就针对了监测死锁，以及从死锁中恢复。一个事务可能需要取得许多锁，并可能一直持有这些锁，直到所有事务提交。如此说来两个事务非常有可能发生死锁，但这却并不常见。数据库服务器当它监测到一个事务集发生了死锁，它会选择牺牲者，使它退出事务。这个牺牲者释放的资源，使得其他事务能够继续进行。应用程序可以重新执行那个被强行退出的事务，现在这个事务可能就能够成功完成了，因为所有跟它竞争资源的事务都已经完成了。</li>
<li>JVM在解决死锁方面与数据库服务不同，当一个Java线程集发生死锁时，这些线程永远不能使用了。恢复应用程序健康的唯一方式就是中止并重启，然后寄希望于不要再发生同样的事情。</li>
<li>死锁出现往往在高负载之下。</li>
</ul>
<h3><span id="1011-锁顺序死锁">10.1.1 锁顺序死锁</span></h3><ul>
<li><p>以下代码的LeftRightDeadlock存在死锁风险。leftRight和rightLeft分别获得left锁和right锁。如果一个线程调用了leftRight，另一个线程调用了rightLeft，那么可能会发生死锁。</p>
<pre><code>  //简单的锁顺序死锁(不要这样做)
  public class LeftRightDeadlock &#123;
      private final Object left = new Object();
      private final Object right = new Object();

      public void leftRight() &#123;
          synchronized (left) &#123;
              synchronized (right) &#123;
                  doSomething();
              &#125;
          &#125;
      &#125;

      public void rightLeft() &#123;
          synchronized (right) &#123;
              synchronized (left) &#123;
                  doSomethingElse();
              &#125;
          &#125;
      &#125;
  &#125;</code></pre>
</li>
<li><p>LeftRightDeadlock发生死锁的原因是:两个线程试图通过<strong>不同的顺序</strong>获得多个相同的锁。如果请求的顺序相同，就不会出现循环的锁依赖现象，也就不会产生死锁了。</p>
<blockquote>
<p>如果所有线程以通过的固定秩序获得锁，程序就不会出现锁顺序死锁问题了。</p>
</blockquote>
</li>
</ul>
<h3><span id="1012-动态的锁顺序死锁">10.1.2 动态的锁顺序死锁</span></h3><ul>
<li><p>以下代码看似无害，它把资金从一个账户转入另一个账户。在执行转账之前要获得Account对象的锁，为了账目的平衡要保证更新操作是原子化的，同时不能破坏固有约束，比如一个账户的余额不能为负数。</p>
<pre><code>  //动态加锁顺序产生的死锁(不要这样做)
  public class DynamicOrderDeadlock &#123;
      // Warning: deadlock-prone!
      public static void transferMoney(Account fromAccount,
                                       Account toAccount,
                                       DollarAmount amount)
              throws InsufficientFundsException &#123;
          synchronized (fromAccount) &#123;
              synchronized (toAccount) &#123;
                  if (fromAccount.getBalance().compareTo(amount) &lt; 0)
                      throw new InsufficientFundsException();
                  else &#123;
                      fromAccount.debit(amount);
                      toAccount.credit(amount);
                  &#125;
              &#125;
          &#125;
      &#125;

      static class DollarAmount implements Comparable&lt;DollarAmount&gt; &#123;
          // Needs implementation

          public DollarAmount(int amount) &#123;
          &#125;

          public DollarAmount add(DollarAmount d) &#123;
              return null;
          &#125;

          public DollarAmount subtract(DollarAmount d) &#123;
              return null;
          &#125;

          public int compareTo(DollarAmount dollarAmount) &#123;
              return 0;
          &#125;
      &#125;

      static class Account &#123;
          private DollarAmount balance;
          private final int acctNo;
          private static final AtomicInteger sequence = new AtomicInteger();

          public Account() &#123;
              acctNo = sequence.incrementAndGet();
          &#125;

          void debit(DollarAmount d) &#123;
              balance = balance.subtract(d);
          &#125;

          void credit(DollarAmount d) &#123;
              balance = balance.add(d);
          &#125;

          DollarAmount getBalance() &#123;
              return balance;
          &#125;

          int getAcctNo() &#123;
              return acctNo;
          &#125;
      &#125;

      static class InsufficientFundsException extends Exception &#123;
      &#125;
  &#125;</code></pre>
</li>
<li><p>如果两个线程同时调用transferMoney，一个从X向Y转账，另一个从Y向X转账，那么就会发生死锁：</p>
<ul>
<li>A:transferMoney(myAccount, yourAccount, 10);</li>
<li>B:transferMoney(yourAccount, myAccount, 20);</li>
</ul>
</li>
<li><p>在偶发的时序中，A会获得myAccount的锁，并等待yourAccount的锁，然而B此时持有yourAccount的锁，正在等待myAccount的锁。</p>
</li>
<li><p>这样的死锁可以通过获得锁时，查看是否嵌套来检查。为了解决这个问题，必须制定锁的顺序，并且在整个应用程序中，获得锁都必须遵守这个既定的顺序。</p>
</li>
<li><p>我们在制定对象顺序的时候，可以使用System.indentityHashCode这样一种方式，它会返回Object.hashCode所返回的值。以下代码为transferMoney的又一个版本，它使用了System.identityHashCode定义了锁的顺序。虽然它带来了一些新的代码，但是它能够减少死锁发生的可能性。</p>
<pre><code>  //制定锁的顺序来避免死锁
  public class InduceLockOrder &#123;
      private static final Object tieLock = new Object();

      public void transferMoney(final Account fromAcct,
                                final Account toAcct,
                                final DollarAmount amount)
              throws InsufficientFundsException &#123;
          class Helper &#123;
              public void transfer() throws InsufficientFundsException &#123;
                  if (fromAcct.getBalance().compareTo(amount) &lt; 0)
                      throw new InsufficientFundsException();
                  else &#123;
                      fromAcct.debit(amount);
                      toAcct.credit(amount);
                  &#125;
              &#125;
          &#125;
          int fromHash = System.identityHashCode(fromAcct);
          int toHash = System.identityHashCode(toAcct);

          if (fromHash &lt; toHash) &#123;
              synchronized (fromAcct) &#123;
                  synchronized (toAcct) &#123;
                      new Helper().transfer();
                  &#125;
              &#125;
          &#125; else if (fromHash &gt; toHash) &#123;
              synchronized (toAcct) &#123;
                  synchronized (fromAcct) &#123;
                      new Helper().transfer();
                  &#125;
              &#125;
          &#125; else &#123;
              synchronized (tieLock) &#123;
                  synchronized (fromAcct) &#123;
                      synchronized (toAcct) &#123;
                          new Helper().transfer();
                      &#125;
                  &#125;
              &#125;
          &#125;
      &#125;

      interface DollarAmount extends Comparable&lt;DollarAmount&gt; &#123;
      &#125;

      interface Account &#123;
          void debit(DollarAmount d);

          void credit(DollarAmount d);

          DollarAmount getBalance();

          int getAcctNo();
      &#125;

      class InsufficientFundsException extends Exception &#123;
      &#125;
  &#125;</code></pre>
</li>
<li><p>若出现哈希冲突，使用加时赛锁，保证一次只有一个线程执行这个有风险的操作以未知的顺序获得锁，从而减少死锁发生的可能性。</p>
</li>
<li><p>如果Account具有唯一的不可变的，并且具有可比性的key，比如账号，那么制定锁的顺序就更加容易了：通过key来排定对象顺序，这样能省去加时赛锁的需要。</p>
</li>
<li><p>死锁在真实的系统中是个很严重的问题。以下代码在大多数系统下都会很快发生死锁。</p>
<pre><code>  //开始一个循环，它在典型条件下制定死锁
  public class DemonstrateDeadlock &#123;
      private static final int NUM_THREADS = 20;
      private static final int NUM_ACCOUNTS = 5;
      private static final int NUM_ITERATIONS = 1000000;

      public static void main(String[] args) &#123;
          final Random rnd = new Random();
          final Account[] accounts = new Account[NUM_ACCOUNTS];

          for (int i = 0; i &lt; accounts.length; i++)
              accounts[i] = new Account();

          class TransferThread extends Thread &#123;
              public void run() &#123;
                  for (int i = 0; i &lt; NUM_ITERATIONS; i++) &#123;
                      int fromAcct = rnd.nextInt(NUM_ACCOUNTS);
                      int toAcct = rnd.nextInt(NUM_ACCOUNTS);
                      DollarAmount amount = new DollarAmount(rnd.nextInt(1000));
                      try &#123;
                          DynamicOrderDeadlock.transferMoney(accounts[fromAcct], accounts[toAcct], amount);
                      &#125; catch (DynamicOrderDeadlock.InsufficientFundsException ignored) &#123;
                      &#125;
                  &#125;
              &#125;
          &#125;
          for (int i = 0; i &lt; NUM_THREADS; i++)
              new TransferThread().start();
      &#125;
  &#125;</code></pre>
</li>
</ul>
<h3><span id="1013-协作对象间的死锁">10.1.3 协作对象间的死锁</span></h3><ul>
<li><p>获取多重的锁并不总是像在LeftRightDeadlock或者transferMoney中那么明显；可能不是在同一个方法中请求两个锁。以下代码中相互协作的类，他可能用于出租车调遣系统。Taxi代表个体出租车，具有位置和方向两个属性；dispatcher代表一组出租车。</p>
<pre><code>  //协作对象间的锁顺序死锁(不要这样做)
  public class CooperatingDeadlock &#123;
      // Warning: deadlock-prone!
      class Taxi &#123;
          @GuardedBy(&quot;this&quot;) private Point location, destination;
          private final Dispatcher dispatcher;

          public Taxi(Dispatcher dispatcher) &#123;
              this.dispatcher = dispatcher;
          &#125;

          public synchronized Point getLocation() &#123;
              return location;
          &#125;

          public synchronized void setLocation(Point location) &#123;
              this.location = location;
              if (location.equals(destination))
                  dispatcher.notifyAvailable(this);
          &#125;

          public synchronized Point getDestination() &#123;
              return destination;
          &#125;

          public synchronized void setDestination(Point destination) &#123;
              this.destination = destination;
          &#125;
      &#125;

      class Dispatcher &#123;
          @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis;
          @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis;

          public Dispatcher() &#123;
              taxis = new HashSet&lt;Taxi&gt;();
              availableTaxis = new HashSet&lt;Taxi&gt;();
          &#125;

          public synchronized void notifyAvailable(Taxi taxi) &#123;
              availableTaxis.add(taxi);
          &#125;

          public synchronized Image getImage() &#123;
              Image image = new Image();
              for (Taxi t : taxis)
                  image.drawMarker(t.getLocation());
              return image;
          &#125;
      &#125;

      class Image &#123;
          public void drawMarker(Point p) &#123;
          &#125;
      &#125;
  &#125;</code></pre>
</li>
<li><p>尽管没有方法显式的获得两个锁，不同的setLocation和getImage的调用者同样可以获得两个锁。如果一个线程调用setLocation作为对GPS接收器更新的响应，它首先更新出租车的位置，然后检查其是否到达了目的地，如果已经到达，那么它会通知Dispatcher，它需要一个新的目标。因为setLocation和notifyAvailable都是synchronized方法，调用setLocation的线程获取了Taxi的锁，然后又获取了Dispatcher的锁(一次一个)。正如在LeftRightDeadlock中发生的，两个锁被两个线程以不同顺序占有，产生死锁风险。</p>
</li>
</ul>
<blockquote>
<p>在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁(产生死锁的风险)，或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程。</p>
</blockquote>
<h3><span id="1014-开放调用">10.1.4 开放调用</span></h3><ul>
<li><p>由于不能知道调用的另一方发生的事情，<strong>在持有锁的时候调用一个外部方法很难进行分析，因此是危险的。</strong></p>
</li>
<li><p>当调用的方法不需要持有锁时，这被称为**开放调用(open call)**，依赖于开放调用的类会具有更好的行为，并且比那些需要获得锁才能调用的方法相比，更容易与其它的类合作。</p>
</li>
<li><p>使用开放调用来避免死锁类似于使用封装来提供线程安全：尽管我们能够保证在没有封装的情况下构建线程安全的程序，但是对一个有效封装的类进行线程安全分析，要比分析没有封装的类容易的多。类似的，分析一个完全依赖于开放调用的程序的程序活跃度，比分析那些非开放调用的程序更简单。尽量让你自己使用开放调用，这要比获得多重锁后识别代码路径更简单，因此可以确保一致的顺序获得锁。</p>
<pre><code>  //使用开放调用来避免协作对象之间的死锁
  class CooperatingNoDeadlock &#123;
      @ThreadSafe
      class Taxi &#123;
          @GuardedBy(&quot;this&quot;) private Point location, destination;
          private final Dispatcher dispatcher;

          public Taxi(Dispatcher dispatcher) &#123;
              this.dispatcher = dispatcher;
          &#125;

          public synchronized Point getLocation() &#123;
              return location;
          &#125;

          public synchronized void setLocation(Point location) &#123;
              boolean reachedDestination;
              synchronized (this) &#123;
                  this.location = location;
                  reachedDestination = location.equals(destination);
              &#125;
              if (reachedDestination)
                  dispatcher.notifyAvailable(this);
          &#125;

          public synchronized Point getDestination() &#123;
              return destination;
          &#125;

          public synchronized void setDestination(Point destination) &#123;
              this.destination = destination;
          &#125;
      &#125;
  &#125;</code></pre>
</li>
</ul>
<blockquote>
<p>在程序中尽量使用开放调用。依赖于开放调用的程序，相比那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度的分析。</p>
</blockquote>
<ul>
<li>重新构建synchronized块有时会使开放调用产生出乎预料的结果，因为它使得一个原子操作变为非原子操作。有时候，这样损失了原子性的操作是完全可以接受的；更新出租车的位置，并通知分派程序这辆车已经准备好随时待命，这两件事并不需要成为原子操作。</li>
<li>但是有时原子性的损失会引发问题，这里你需要使用另一种技术来实现原子性。构建一个并发的对象。这能够防止其他线程尝试进入，这胜于使用锁来避免其他线程进入代码的临界区。</li>
</ul>
<h3><span id="1015-资源死锁">10.1.5 资源死锁</span></h3><ul>
<li>当线程间相互等待对方持有的锁，并且谁都不会释放自己的锁时就会发生死锁，当线程持有和等待的目标变为资源时，会发生与之类似的死锁。</li>
<li>假设你有两个放入池中的资源，比如分别是到两个数据库的连接池。资源池通过信号量实现，当池为空的时候发生阻塞。如果一个任务需要连接到两个数据库，并且两个资源并不是按照相同顺序进行调用的的，线程A可能持有至数据库D1的连接，并等待连接到数据库D2，而线程B持有至D2的连接并等待到D1的连接。</li>
<li>另一种形式的基于资源的死锁是线程饥饿死锁。需要等待其他任务的结果的任务是生成线程饥饿死锁的来源；有界池和相互依赖的任务不能放在一起使用。</li>
</ul>
<h2><span id="102-避免和诊断死锁">10.2 避免和诊断死锁</span></h2><ul>
<li>如果一个程序一次至多获得一个锁，那么就不会产生锁顺序死锁。当然这并不现实。锁的顺序必须是你设计工作的一部分：尽量减少潜在锁之间的交互数量，遵守并文档化该锁顺序协议。</li>
<li>在使用定义良好的锁的程序中，监测代码中死锁自由度的策略分为两个部分：<ul>
<li>首先识别什么地方会获取多个锁，对这些示例进行全局的分析，确保它们锁的顺序在程序中保持一致。</li>
<li>尽可能使用开放调用，这样做能够从根本上简化分析的难度。</li>
</ul>
</li>
</ul>
<h3><span id="1021-尝试定时的锁">10.2.1 尝试定时的锁</span></h3><ul>
<li>另一项监测死锁和从死锁中恢复的技术，是使用每个显式Lock类定时tryLock特性，来替代使用内部锁机制。</li>
<li>在内部锁的机制中，只要没有获得锁，就会永远保持等待，而显式的锁使你能够定义超时的时间，在规定时间之后tryLock还没有获得锁就返回失败。</li>
</ul>
<h3><span id="1022-通过线程转储分析死锁">10.2.2 通过线程转储分析死锁</span></h3><ul>
<li>预防死锁是你面临的最大问题，JVM使用**线程转储(thread dump)**来帮助你识别死锁的发生。线程转储包括<ul>
<li>每个运行中线程的栈追踪信息，</li>
<li>以及与之相似并随之发生的异常。</li>
<li>锁的信息，比如哪个锁由哪个线程获得，其中获得这些锁的栈结构，以及阻塞线程正在等待的锁究竟是哪一个。</li>
</ul>
</li>
</ul>
<h2><span id="103-其他的活跃度危险">10.3 其他的活跃度危险</span></h2><ul>
<li>尽管死锁使我们遇到的最主要的活跃度危险，并发程序中仍然可能遇到一些其他的活跃度危险，包括：饥饿，丢失信号和活锁。</li>
</ul>
<h3><span id="1031-饥饿">10.3.1 饥饿</span></h3><ul>
<li>当线程访问它所需要的资源时却被永久拒绝，以至于不能再继续进行，这样就发生了**饥饿(starvation)**；最常见的引发饥饿的资源是CPU周期。在Java应用程序中，使用线程的优先级不当可能引起饥饿。在锁中执行无终止的构建也可能引起饥饿(无限循环，或者无尽等待资源)，因为其他需要这个锁的线程永远不可能得到它。</li>
<li>线程API定义了是个优先级级别，并对应到操作系统响应的调度优先级中。</li>
</ul>
<blockquote>
<p>抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题，大多数并发应用程序可以对所有线程使用相同的优先级。</p>
</blockquote>
<h3><span id="1032-弱响应性">10.3.2 弱响应性</span></h3><ul>
<li>除饥饿以外的另一个问题是弱响应性，在GUI应用程序中使用的后台线程的情况下，这是很常见的。把耗时任务分载到后台线程中，这样就不会造成用户界面冻结了。</li>
<li>CPU密集型的后台任务会影响响应性，因为它们会与事件线程共同竞争CPU的微周期。</li>
<li>不良的锁管理也可能引起弱响应性。如果一个线程长时间占有一个锁，其他想要访问该容器的线程就必须等待很长事件。</li>
</ul>
<h3><span id="1033-活锁">10.3.3 活锁</span></h3><ul>
<li>**活锁(livelock)**是线程中活跃度失败的另一种形式，尽管没有被阻塞，线程却仍然不能继续，因为它不断重试相同的操作，却总是失败。</li>
<li>活锁通常发生在消息处理应用程序中，如果消息处理失败的话，其中传递消息的底层架构会回退整个事务，并把它置回队首。如果消息处理程序对某种特定类型的消息处理存在bug，每次处理都会失败，那么每一次这个消息都会被从队列中取出，传递到存在问题的处理器，然后发生事务回退。因为这条消息又会到队首，处理器会不断被这样重复调用，并返回重复结果。这就是通常成为**毒药信息(poison message)**的问题。信息处理线程并没有发生阻塞，但是永远都不会前进了。这种形式的活锁通常来源于过渡的的错误恢复代码，误将不可修复的错误当做是可修复的错误。</li>
<li>活锁同样发生在多个相互协作的线程间，当它们为了彼此间响应而修改了状态，使得没有一个线程能够继续前进，那么就发生了活锁。这好比两个过于礼貌的人在半路相遇：他们都避开对方的路，于是在另外一条路上又相遇了。所以就这样不停地一直避让下去了…</li>
<li>解决这些多样的活锁的一种方案是对重试机制引入一些随机性。<ul>
<li>例如，在以太网络上，两个基站尝试使用相同的载波发送数据包，包会发送冲突。基站发现了冲突，并且都在稍后重发。如果它们都非常精确地在一秒后重试，它们又会发送冲突，并不断冲突下去，导致数据包永远不能发送，即使有大量的带宽都是闲置的。</li>
<li>为了避免这种情况发生，我们通过用一个随机组件使它们进行等待。</li>
</ul>
</li>
<li>在并发程序中，通过随机等待和撤回来进行重试能够相当有效地避免活锁的发生。</li>
</ul>
<h2><span id="summary">summary</span></h2><ul>
<li>活跃度失败是很严重的问题，因为除了短时间地中止应用程序，没有任何机制可以恢复这种失败。</li>
<li>最常见的活跃度失败是锁顺序死锁。应该在设计时就避免锁顺序死锁：确保多个线程在获得多个锁时，使用一致的顺序。</li>
<li>最好的解决方法是在程序中使用开放调用。这会大大减少一个线程一次请求多个锁的情况，并且使这样的多重锁请求的发生更加明显。</li>
</ul>
<p></p>


  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/about">白色蜗牛</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%8D%B1%E9%99%A9/">https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/10-%E9%81%BF%E5%85%8D%E6%B4%BB%E8%B7%83%E5%BA%A6%E5%8D%B1%E9%99%A9/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/Java并发编程/11-性能和可伸缩性/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">11.性能和可伸缩性 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/Java并发编程/09-GUI应用程序/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">09.GUI应用程序 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="vcomments"></div>
  
  <script>
    loadScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js");
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();
      new Valine({
        el: '#vcomments',
        appId: 'Ro9jzghVgwRgtnGQQ99MFbAK-9Nh9j0Va',
        appKey: 'rbA6uGwupFqEcTUAugUoXn2B',
        placeholder: '留下你的足迹吧~也可以加我微信 919201148，互换友链~~~',
        path: window.location.pathname,
        avatar: 'robohash',
        meta: ["nick","mail","link"],
        pageSize: '10',
        lang: '',
        visitor: 'true',
        highlight: true,
        recordIP: false,
        
        
        
        enableQQ: 'false',
        requiredFields: [],
      });
    };
  </script>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.1 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.1 锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.2 动态的锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.3 协作对象间的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.4 开放调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.5 资源死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.2 避免和诊断死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.1 尝试定时的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.2 通过线程转储分析死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.3 其他的活跃度危险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.1 饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.2 弱响应性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.3 活锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
</div>

<!-- 百度自动推送链接-->
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/logo.jpg" class="author-img">

<p class="author-name">蜗牛 Java 之家</p>
<p class="author-description">Java 程序员的成长进阶社区</br>(Java for You)。</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>107</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>11</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>118</span>
    <span>标签</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png">
        <i class="iconfont icon-wechat society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/huayonglun/">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="http://weibo.com/huayonglun">
        <i class="iconfont icon-sina society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.1 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.1 锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.2 动态的锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.3 协作对象间的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.4 开放调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.5 资源死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.2 避免和诊断死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.1 尝试定时的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.2 通过线程转储分析死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.3 其他的活跃度危险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.1 饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.2 弱响应性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.3 活锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/教程">
        <div class="categories-list-item">
          教程
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/Java">
        <div class="categories-list-item">
          Java
          <span class="categories-list-item-badge">14</span>
        </div>
      </a>
    
      <a href="/categories/Java并发编程">
        <div class="categories-list-item">
          Java并发编程
          <span class="categories-list-item-badge">18</span>
        </div>
      </a>
    
      <a href="/categories/Linux">
        <div class="categories-list-item">
          Linux
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/spring">
        <div class="categories-list-item">
          spring
          <span class="categories-list-item-badge">21</span>
        </div>
      </a>
    
      <a href="/categories/struts2">
        <div class="categories-list-item">
          struts2
          <span class="categories-list-item-badge">16</span>
        </div>
      </a>
    
      <a href="/categories/夯实基础系列">
        <div class="categories-list-item">
          夯实基础系列
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/思维">
        <div class="categories-list-item">
          思维
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/数据库">
        <div class="categories-list-item">
          数据库
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/算法">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">25</span>
        </div>
      </a>
    
      <a href="/categories/网络">
        <div class="categories-list-item">
          网络
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\Java" title="Java"><div class="tags-list-item">Java</div></a>
    
    <a href="\tags\ssh" title="ssh"><div class="tags-list-item">ssh</div></a>
    
    <a href="\tags\spring" title="spring"><div class="tags-list-item">spring</div></a>
    
    <a href="\tags\Java并发" title="Java并发"><div class="tags-list-item">Java并发</div></a>
    
    <a href="\tags\struts2" title="struts2"><div class="tags-list-item">struts2</div></a>
    
    <a href="\tags\bean" title="bean"><div class="tags-list-item">bean</div></a>
    
    <a href="\tags\树" title="树"><div class="tags-list-item">树</div></a>
    
    <a href="\tags\AOP" title="AOP"><div class="tags-list-item">AOP</div></a>
    
    <a href="\tags\分布式" title="分布式"><div class="tags-list-item">分布式</div></a>
    
    <a href="\tags\链表" title="链表"><div class="tags-list-item">链表</div></a>
    
    <a href="\tags\装配属性" title="装配属性"><div class="tags-list-item">装配属性</div></a>
    
    <a href="\tags\集合" title="集合"><div class="tags-list-item">集合</div></a>
    
    <a href="\tags\二叉树" title="二叉树"><div class="tags-list-item">二叉树</div></a>
    
    <a href="\tags\查找" title="查找"><div class="tags-list-item">查找</div></a>
    
    <a href="\tags\排序" title="排序"><div class="tags-list-item">排序</div></a>
    
    <a href="\tags\同步" title="同步"><div class="tags-list-item">同步</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">

  <!-- 我的公众号 -->
  
  <article class="card card-content toc-card">
    <div style="float: left; ">
      <img class="adv" style="width: 100%; height: 100%; border: solid 1px #ddd;" src="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608142536200-image.png">
    </div>
    <div style="float: left; margin-left: 17px; margin-top: 12px;">
        <div style="font-size: 18px; margin-bottom: 12px;color:#159957;"><b>微信搜一搜: 蜗牛互联网</b></div>
        <small style="font-size: 0.9em;">
          👉「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyboCy8Drh8AWNqE_DUROg">技术干货</a>」每周推送<br>
          👉「<a href="https://java4u.cn/resources/">免费资料</a>」随时领取<br>
          👉「<a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608143152021-image.png">优质社群</a>」随时加入<br>
        </small>
    </div>
    <div style="clear: both;"></div>
    <div style="font-size: 0.8em; margin: 15px 0 15px 0;">
      <a href="" target="_blank" style="color:#159957;font-size: 14px;" rel="noopener noreferrer">扫描上方二维码，关注我的公众号</a>
      <br>
    </div>
  </article>


  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.1 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.1 锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.2 动态的锁顺序死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.3 协作对象间的死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.4 开放调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.1.5 资源死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.2 避免和诊断死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.1 尝试定时的锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.2.2 通过线程转储分析死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">10.3 其他的活跃度危险</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.1 饥饿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.2 弱响应性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10.3.3 活锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
  </article>
  

  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-15</div>
        <a href="/course/cai_yun_xiao_yi/"><div class="recent-posts-item-content">彩云小译：最佳的网页翻译插件</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-14</div>
        <a href="/course/markmap/"><div class="recent-posts-item-content">最佳的思维导图生成工具： markmap 使用教程</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-13</div>
        <a href="/course/hexo_site_course/"><div class="recent-posts-item-content">建站神器：Hexo+Kaze+Gitee Pages 搭建静态博客网站</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2019-01-24</div>
        <a href="/思维/知识的诅咒：为什么你觉得显而易见，而对方却无法理解/"><div class="recent-posts-item-content">知识的诅咒：为什么你觉得显而易见，而对方却无法理解</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      
      <!-- copyringt-->
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2020
        </span>
        &nbsp;
        <a href="/" class="footer-link">蜗牛 Java 之家 </a>
      </div>

       <!-- copyringt-->
       <div class="footer-dsc">
        <center><span>
        <a href="https://java4u.cn/resources/" target="_blank">Java 程序员最全资源下载</a> - <a href="https://java4u.cn/links/" target="_blank">友情链接</a>
        </span></center>
      </div>
     
    </div>

    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  

  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>