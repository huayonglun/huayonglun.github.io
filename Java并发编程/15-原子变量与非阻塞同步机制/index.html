<!DOCTYPE html>
<html  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  <link rel="icon" href="/img/logo.jpg">
  <title>15.原子变量与非阻塞同步机制&nbsp; | &nbsp;Java for You</title>
  
  
  <meta property="og:title" content="15.原子变量与非阻塞同步机制">
  
  
  <meta property="og:url" content="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/index.html">
  
  
  <meta property="og:img" content="/img/logo.jpg">
  
  
  <meta property="og:img" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2016-05-09">
  <meta property="og:article:modified_time" content="2020-12-19">
  <meta property="og:article:author" content="蜗牛 Java 之家">
  
  
  <meta property="og:article:tag" content="Java">
  
  <meta property="og:article:tag" content="Java并发">
  
  <meta property="og:article:tag" content="同步">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  <link rel="prefetch" href="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  


  <!-- 百度站长工具验证 -->
  <meta name="baidu-site-verification" content="code-9cIsKsXy75" />

  <!-- 必应站长工具验证-->
  <meta name="msvalidate.01" content="81AA8F485E800B7335F07A558BE9A636" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22LNC79YC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22LNC79YC');
</script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.jpg" alt="logo">
      
      <span class="navbar-logo-dsc">蜗牛 Java 之家</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/resources" class="navbar-menu-item">
    
    免费资源
    
    </a>
    
    <a href="/tools" class="navbar-menu-item">
    
    免费工具
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<article class="card card-content">
  <header>
    <h1 class="post-title">
      15.原子变量与非阻塞同步机制
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2016-05-09T10:26:31.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2016-05-09</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/Java并发编程/" class="post-meta-link">Java并发编程</a>
    
    
    
    <span class="dot"></span>
    <span>6k 字</span>
    

    <span class="dot"></span>
    <!-- 增加阅读量统计样式代码 -->
    
    <!-- id 将作为查询条件 -->
    <i class="iconfont icon-wodebaobiao" style="margin-right: 2px; font-size: 1.15rem;"></i>
    <span id="/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/" class="leancloud_visitors" data-flag-title="15.原子变量与非阻塞同步机制">
      <em class="post-meta-item-text">阅读量 </em>
      <i class="leancloud-visitors-count"></i>
    </span>

  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Java/" class="post-meta-link">Java</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/Java并发/" class="post-meta-link">Java并发</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/同步/" class="post-meta-link">同步</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <ul>
<li>java.util.concurrent包中的许多类，比如Semaphore和ConcurrentLinkedQueue，都提供了比使用synchronized更好的性能和可伸缩性。这一章，我们来学习这些性能提升的原始来源：原子变量和非阻塞的同步机制。</li>
<li>近来很多关于并发算法的研究都聚集在非阻塞算法上，这种算法使用低层原子化的机器指令取代锁，比如比较并交换，从而保证数据在并发访问下的一致性。非阻塞算法广泛用于操作系统和JVM中的线程和进程调度、垃圾回收以及实现锁和其他并发数据结构。</li>
<li>与基于锁的方案相比，非阻塞算法的设计和实现都要复杂得多，但是它们在可伸缩性或活跃度上占有很大的优势。因为非阻塞算法可以让多个线程在竞争相同资源时不会发生阻塞，所以它能在更精化的层面上调整粒度，并能大大减少调度的开销。</li>
<li>进一步而言，它们对死锁和其他活跃度问题具有免疫性。在基于锁的算法中，如果一个线程在持有锁的时候休眠，或者停滞不前，那么其他线程就都不可能前进了，而非阻塞算法不会受到单个线程失败的影响。</li>
<li>在java 5.0 中，使用<strong>原子变量类</strong>，比如AtomicInteger和AtomicReference，能够高效地构建非阻塞算法。</li>
<li>原子变量提供了与volatile类型变量相同的内存语义，同时还额外支持原子更新——使它们能更加理想地用于计数器、序列发生器和统计数据收集等，另外也比基于锁的方案具有更加出色的可伸缩性。</li>
</ul>
<h2><span id="151-锁的劣势">15.1 锁的劣势</span></h2><ul>
<li><p>使用一致的加锁协议来协调对共享状态的访问，确保无论哪个线程持有守护变量的锁，它们都能独占访问这些变量，并且对变量的任何修改对其他随后获得同一锁的线程都是可见的。</p>
</li>
<li><p>对于基于锁，并且其操作过度细分的类，当频繁地发生锁的竞争时，调度与真正用于工作的开销间的比值会很可观。</p>
</li>
<li><p>volatile变量与锁相比是更轻量的同步机制，因为它们不会引起上下文的切换和线程调度。然而，volatile变量与锁相比有一些局限性：</p>
<ul>
<li>尽管它们提供了相似的可见性保证，但是它们不能用于构建原子化的复合操作。这意味着当一个变量依赖其他变量时，或者当变量的新值依赖于旧值时，是不能用volatile变量的。</li>
<li>它们不能用于实现可靠的通用工具，比如计数器，或互斥体</li>
</ul>
</li>
<li><p>例如，尽管自增操作看起来像是原子操作，事实上有3个独立操作——获取变量当前值，为该值加一，然后写回更新值。为了不丢失更新，整个的读-改-写操作必须是原子的。</p>
</li>
<li><p>加锁的缺点：</p>
<ul>
<li>当一个线程正在等待锁，他不能做任何其他事情。</li>
<li>如果一个线程在持有锁的情况下发生了延迟，那么其他所有需要该锁的线程都不能前进了。</li>
<li>若阻塞线程优先级高，持有锁的线程优先级低，那么持有锁的线程会永久性阻塞。</li>
</ul>
</li>
</ul>
<h2><span id="152-硬件对并发的支持">15.2 硬件对并发的支持</span></h2><ul>
<li>独占锁是一项悲观的技术——它假设最坏情况(如果你不锁门，捣蛋鬼就会闯入，并破坏物品的秩序)，并且会通过获得正确的锁来避免其他线程的打扰，直到作出保证才能继续进行。</li>
<li>对于细粒度的操作，有另外一种选择通常更加有效——<strong>乐观</strong>的解决方法。凭借新的方法，我们可以指望不受打扰地完成更新。这个方法依赖于<strong>冲突监测</strong>，从而能判定更新过程中是否存在来自于其他成员的干涉，在冲突发生的情况下，操作失败，并会重试(也可能不重试)。这个乐观的方案就好比我们常说的：“宽恕比准许更容易”，其中“更容易”意味着“更有效率”。</li>
<li>针对多处理器系统设计的处理器提供了特殊的指令，用来管理并发访问的共享数据。早期处理器具有原子化的<strong>测试并设置(test-and-set)**，</strong>获取并增加(fetch-and-increment)<strong>以及</strong>交换(swap)**指令，这些对于实现互斥已经足够了，并能够用于实现更成熟的并发对象。</li>
<li>如今，几乎所有现代的处理器都具有一些形式的原子化的读-改-写指令，比如<strong>比较并交换(compare-and-swap)**和</strong>加载链接/存储条件**(load-linked/store-conditional)。操作系统和JVM使用这些指令来实现锁和并发的数据结构，但是直到Java 5.0 以前这些还不能直接为Java类所使用。</li>
</ul>
<h3><span id="1521-比较并交换">15.2.1 比较并交换</span></h3><ul>
<li><p>大多数处理器使用的架构方案都实现了**比较并交换(CAS)**指令。</p>
</li>
<li><p>PowerPC用一对指令实现了相同的功能：<strong>链接加载/存储条件</strong>。</p>
</li>
<li><p>CAS有3个操作数——内存位置V、旧的预期值A和新值B。当且仅当V符合旧预期值A时，CAS用新值B原子化地更新V的值；否则它什么都不会做。</p>
</li>
<li><p>CAS是一项乐观技术——它抱着成功的希望进行更新，并且如果另一个线程在上次检查后更新了该变量，它能够发现错误。</p>
<pre><code>  //模拟CAS操作
  @ThreadSafe
  public class SimulatedCAS &#123;
      @GuardedBy(&quot;this&quot;) private int value;

      public synchronized int get() &#123;
          return value;
      &#125;

      public synchronized int compareAndSwap(int expectedValue,
                                             int newValue) &#123;
          int oldValue = value;
          if (oldValue == expectedValue)
              value = newValue;
          return oldValue;
      &#125;

      public synchronized boolean compareAndSet(int expectedValue,
                                                int newValue) &#123;
          return (expectedValue
                  == compareAndSwap(expectedValue, newValue));
      &#125;
  &#125;</code></pre>
</li>
<li><p>使用CAS的典型模式是：首先从V中读取值A，由A生成新值B，然后使用CAS原子化地把V的值由A改成B，并且期间不能有其他线程改变V的值。因为CAS能够发现来自其他线程的干扰，所以即使不使用锁，它也能够解决原子化地实现读-写-改的问题。</p>
</li>
</ul>
<h3><span id="1522-非阻塞计数器">15.2.2 非阻塞计数器</span></h3><ul>
<li><p>以下代码CasCounter利用CAS实现了线程安全的计数器。自增操作遵循了经典形式——取得旧值，根据它计算出新值(加一)，并使用CAS设定新值。如果CAS失败，立即重试该操作。尽管在竞争十分激烈的情况下，更希望等待或者回退，以避免重试造成的活锁，但是，通常反复重试都是合理的策略。</p>
</li>
<li><p>CasCounter不会发生阻塞，如果其他线程同时更新计数器，它会进行数次重试。</p>
<pre><code>  //使用CAS实现的非阻塞计数器
  @ThreadSafe
  public class CasCounter &#123;
      private SimulatedCAS value;

      public int getValue() &#123;
          return value.get();
      &#125;

      public int increment() &#123;
          int v;
          do &#123;
              v = value.get();
          &#125; while (v != value.compareAndSwap(v, v + 1));
          return v + 1;
      &#125;
  &#125;</code></pre>
</li>
<li><p>比较</p>
<ul>
<li>基于CAS的计数器看起来比基于锁的计数器性能差一些；它具有更多的操作和更复杂的控制流，表面看来还依赖于复杂的CAS操作。但是，实际上基于CAS的计数器，性能上远远胜过了基于锁的计数器，即使只有很小的竞争，或者不存在竞争。</li>
</ul>
</li>
<li><p>CAS最重要的缺点是：它强迫调用者处理竞争(通过重试、回退，或者放弃)；然而在锁被获得之前，却可以通过阻塞自动处理竞争。</p>
</li>
</ul>
<h3><span id="1523-jvm对cas的支持">15.2.3 JVM对CAS的支持</span></h3><ul>
<li>在Java 5.0 中，引入了底层的支持，将int、long和对象的引用暴露给CAS操作，并且JVM把它们编译为底层硬件提供的最有效的方法。</li>
<li>在支持CAS的平台上，运行时把它们编排成恰当的(多条)机器指令；在最坏的情况下，如果CAS式的指令不可用，JVM会使用自旋锁。</li>
<li>这些底层的JVM支持，用于那些具有原子化变量的类(java.util.concurrent.atomic中的AtomicXxx)，从而为数字类型和引用类型提供有效的CAS操作；而且，这些原子变量类还用于直接或间接地实现java.util.concurrent中大部分类</li>
</ul>
<h2><span id="153-原子变量类">15.3 原子变量类</span></h2><ul>
<li><p>原子变量比锁更精巧，更轻量，并且在多处理器系统中，对实现高性能的并发代码非常关键。在使用原子变量取代锁的算法中，线程更不易出现延迟，如果它们遇到竞争，也更容易恢复。</p>
</li>
<li><p>原子变量类，提供了广义的volatile变量，以支持原子的、条件的读-写-改操作。AtomicInteger代表一个int值，并提供了get和set方法，它们与读取和写入可变的int有着相同的内存语义。它同样提供了一个compareAndSet方法，以及原子化的插入、递增、递减等方法，这些是为了使用方便。竞争条件下AtomicInteger提供了更好的可伸缩性，因为它可以直接利用硬件对并发的支持。</p>
</li>
<li><p>原子变量类共有12个，分成4组：</p>
<ul>
<li>计量器</li>
<li>域更新器(field updater)</li>
<li>数组</li>
<li>复合变量</li>
</ul>
</li>
<li><p>最常用的原子变量是计量器：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。他们都支持CAS；AtomicInteger和AtomicLong还支持算术运算。</p>
</li>
<li><p>原子化的数组类(只有Integer、Long和Reference版本的可用)，它的元素是可以被原子化地更新的。原子数组类为数组的元素提供了volatile的访问语义，这是普通数组所没有的特性——volatile类型的数组只针对数组的引用具有volatile语义，而不是它的元素。</p>
</li>
</ul>
<h3><span id="1531-原子变量是更佳的volatile">15.3.1 原子变量是“更佳的volatile”</span></h3><ul>
<li>原子化地更新持有上下边界的不变类的引用，来缩小竞争条件。以下代码CasNumberRange使用AtomicReference和IntPair来保持状态；通过使用compareAndSet，它能够避开NumberRange的竞争条件，更新上下界。</li>
</ul>
<pre><code>//使用CAS避免多元的不变约束
@ThreadSafe
    public class CasNumberRange &#123;
    @Immutable
            private static class IntPair &#123;
        // INVARIANT: lower &lt;= upper
        final int lower;
        final int upper;

        public IntPair(int lower, int upper) &#123;
            this.lower = lower;
            this.upper = upper;
        &#125;
    &#125;

    private final AtomicReference&lt;IntPair&gt; values =
            new AtomicReference&lt;IntPair&gt;(new IntPair(0, 0));

    public int getLower() &#123;
        return values.get().lower;
    &#125;

    public int getUpper() &#123;
        return values.get().upper;
    &#125;

    public void setLower(int i) &#123;
        while (true) &#123;
            IntPair oldv = values.get();
            if (i &gt; oldv.upper)
                throw new IllegalArgumentException(&quot;Can&#39;t set lower to &quot; + i + &quot; &gt; upper&quot;);
            IntPair newv = new IntPair(i, oldv.upper);
            if (values.compareAndSet(oldv, newv))
                return;
        &#125;
    &#125;

    public void setUpper(int i) &#123;
        while (true) &#123;
            IntPair oldv = values.get();
            if (i &lt; oldv.lower)
                throw new IllegalArgumentException(&quot;Can&#39;t set upper to &quot; + i + &quot; &lt; lower&quot;);
            IntPair newv = new IntPair(oldv.lower, i);
            if (values.compareAndSet(oldv, newv))
                return;
        &#125;
    &#125;
&#125;</code></pre>
<h3><span id="1532-性能比较锁与原子变量">15.3.2 性能比较：锁与原子变量</span></h3><ul>
<li>伪随机数字生成器(PRNG)</li>
</ul>
<pre><code>    //使用ReentrantLock实现随机数字生成器
    @ThreadSafe
    public class ReentrantLockPseudoRandom extends PseudoRandom &#123;
        private final Lock lock = new ReentrantLock(false);
        private int seed;

        ReentrantLockPseudoRandom(int seed) &#123;
            this.seed = seed;
        &#125;

        public int nextInt(int n) &#123;
            lock.lock();
            try &#123;
                int s = seed;
                seed = calculateNext(s);
                int remainder = s % n;
                return remainder &gt; 0 ? remainder : remainder + n;
            &#125; finally &#123;
                lock.unlock();
            &#125;
        &#125;
    &#125;



    //使用AtomicInteger实现随机数字生成器
    @ThreadSafe
    public class AtomicPseudoRandom extends PseudoRandom &#123;
        private AtomicInteger seed;

        AtomicPseudoRandom(int seed) &#123;
            this.seed = new AtomicInteger(seed);
        &#125;

        public int nextInt(int n) &#123;
            while (true) &#123;
                int s = seed.get();
                int nextSeed = calculateNext(s);
                if (seed.compareAndSet(s, nextSeed)) &#123;
                    int remainder = s % n;
                    return remainder &gt; 0 ? remainder : remainder + n;
                &#125;
            &#125;
        &#125;
    &#125;</code></pre>
<ul>
<li>性能比较</li>
</ul>
<p><img src="http://i.imgur.com/wqx8sBL.png" alt="性能比较" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://i.imgur.com/wqx8sBL.png" class="lozad post-image"></p>
<p><img src="http://i.imgur.com/QCJNXyU.png" alt="中等强度竞争性能比较" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://i.imgur.com/QCJNXyU.png" class="lozad post-image"></p>
<ul>
<li>图15.1和图15.2展示了模拟低级和中级工作强度下，每个迭代的吞吐量。在低级强度的线程本地计算中，锁和原子变量都经历了激烈的竞争；在强化了的线程本地计算后，线程访问锁和原子变量的频率减少了，因而它们的竞争压力也变小减小了。</li>
<li>在激烈竞争下，锁胜过原子变量，但是在真实的竞争条件下，原子变量会胜过锁。这是因为锁通过挂起线程来响应竞争，减少了CPU的利用和共享内存总线上的同步通信量。(这与在生产者-消费者线程中，以阻塞生产者来减小消费者负荷，使它们能够赶上进度的设计是类似的。)从另一方面来看，使用原子变量把竞争管理推回给调用类。与大多数基于CAS的算法相比，AtomicPseudoRandom通过不断反复尝试来响应竞争，这通常是正确的，但是在激烈竞争环境下，会带来更多竞争。</li>
<li><strong>在实践中，原子化的伸缩性比锁更好，因为在典型的竞争级别中，原子性会带来更好的效率。</strong></li>
</ul>
<br>

<ul>
<li>锁与原子化随竞争度的不同，性能发生的改变阐明了各自的优势和劣势。在中低程度的竞争下，原子化提供更好的可伸缩性；在高强度的竞争下，锁能够更好地帮助我们避免竞争。</li>
<li>第三条曲线；使用ThreadLocal的PRNG状态实现PseudoRandom。这个实现方案改变了类的行为——每个线程查看自己私有的伪随机数字序列，而不是所有线程共享同一序列——但是如果能够避免的话，不共享状态的开销会更小。我们能够通过更有效地处理竞争改进可伸缩性，但是真正的可伸缩性完全是通过减少竞争实现的。</li>
</ul>
<h2><span id="154-非阻塞算法">15.4 非阻塞算法</span></h2><ul>
<li>一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法被称为<strong>非阻塞算法</strong></li>
<li>如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为**锁自由(lock-free)**算法。</li>
<li>在线程间使用CAS进行协调，这样的算法如果能够构建正确的话，它既是非阻塞的，又是锁自由的。</li>
<li>非阻塞算法对死锁和优先级倒置有“免疫性”(但它们可能会出现饥饿和活锁，因为它们允许重进入)。</li>
</ul>
<h3><span id="1541-非阻塞栈">15.4.1 非阻塞栈</span></h3><pre><code>//使用Treiber算法的非阻塞栈
@ThreadSafe
    public class ConcurrentStack &lt;E&gt; &#123;
    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();

    public void push(E item) &#123;
        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);
        Node&lt;E&gt; oldHead;
        do &#123;
            oldHead = top.get();
            newHead.next = oldHead;
        &#125; while (!top.compareAndSet(oldHead, newHead));
    &#125;

    public E pop() &#123;
        Node&lt;E&gt; oldHead;
        Node&lt;E&gt; newHead;
        do &#123;
            oldHead = top.get();
            if (oldHead == null)
                return null;
            newHead = oldHead.next;
        &#125; while (!top.compareAndSet(oldHead, newHead));
        return oldHead.item;
    &#125;

    private static class Node &lt;E&gt; &#123;
        public final E item;
        public Node&lt;E&gt; next;

        public Node(E item) &#123;
            this.item = item;
        &#125;
    &#125;
&#125;</code></pre>
<ul>
<li>ConcurrentStack显示了如何使用原子引用来构建栈。栈是Node元素的一个链表，栈顶作为根，每个元素都包含一个值和一个指向下一个元素的链接。</li>
<li>push方法创建一个新的链接节点，该节点的next域指向当前的栈顶，然后使用CAS把这个新节点加入到栈中。如果我们使用栈的时候栈顶元素恰为新加入的节点，那么CAS成功了；如果栈顶元素变化了(因为其他线程在我们开始前插入或移除了元素)，CAS就失败了，push方法会根据当前栈的状态更新节点，反复尝试。在这两种情况下，栈在CAS操作后仍然能够保持一致性。</li>
<li>ConcurrentStack中用到的非阻塞算法，其线程安全性源于：compareAndSet既能提供原子性，又能提供可见性，加锁也同样如此。当一个线程改变栈的状态时，它使用具有与写入volatile变量相同的内存效应的compareAndSet。当线程检查栈的时候，通过调用同一个AtomicReference的get方法来实现，它具有与读取volatile变量相同的内存效应。所以任何线程修改都能够安全地发布给其他正在检查列表状态的线程。并且这个列表通过compareAndSet进行修改，更新top的引用或者因发现其他线程的干扰而失败，这些都是原子化地进行的。</li>
</ul>
<h3><span id="1542-非阻塞链表">15.4.2 非阻塞链表</span></h3><pre><code>//Michael-Scott非阻塞队列算法中的插入
@ThreadSafe
public class LinkedQueue &lt;E&gt; &#123;

    private static class Node &lt;E&gt; &#123;
        final E item;
        final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; next;

        public Node(E item, LinkedQueue.Node&lt;E&gt; next) &#123;
            this.item = item;
            this.next = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(next);
        &#125;
    &#125;

    private final LinkedQueue.Node&lt;E&gt; dummy = new LinkedQueue.Node&lt;E&gt;(null, null);
    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; head
            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);
    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; tail
            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);

    public boolean put(E item) &#123;
        LinkedQueue.Node&lt;E&gt; newNode = new LinkedQueue.Node&lt;E&gt;(item, null);
        while (true) &#123;
            LinkedQueue.Node&lt;E&gt; curTail = tail.get();
            LinkedQueue.Node&lt;E&gt; tailNext = curTail.next.get();
            if (curTail == tail.get()) &#123;
                if (tailNext != null) &#123;
                    // Queue in intermediate state, advance tail
                    tail.compareAndSet(curTail, tailNext);
                &#125; else &#123;
                    // In quiescent state, try inserting new node
                    if (curTail.next.compareAndSet(null, newNode)) &#123;
                        // Insertion succeeded, try advancing tail
                        tail.compareAndSet(curTail, newNode);
                        return true;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;</code></pre>
<h4><span id="图解">图解</span></h4><p><img src="http://i.imgur.com/8oA0uvX.png" alt="队列中有两个元素处于静止状态" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://i.imgur.com/8oA0uvX.png" class="lozad post-image"></p>
<p><img src="http://i.imgur.com/4XMwbMJ.png" alt="插入过程中，状态的变化" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="http://i.imgur.com/4XMwbMJ.png" class="lozad post-image"></p>
<ul>
<li><p>一个链接队列比栈更加复杂，因为它需要支持首尾的快速访问。为了实现，它会维护独，立的队首指针和队尾指针。两个指针初始时都指向队列的末尾结点：当前最后一个元素的next指针，即队尾指针。在成功加入新元素时，两个结点都需要更新——原子化更新。</p>
</li>
<li><p>更新需要注意：</p>
<ul>
<li>第一个成功，第二个失败，队列将处于不一致状态</li>
<li>两个都成功，另一个线程在两个操作之间访问队列</li>
</ul>
</li>
<li><p>我们需要使用几个窍门来完成这项任务。第一个是即使在多步更新中，也要确保数据结构总能处于一致状态。这样，如果线程B到达时发现线程A在更新中，B可以分辨操作已部分完成，并且直到不能立即开始自己的更新。那么B就开始等待(通过反复检查队列状态)直到A完成更新，这样两个线程就不会相互影响了。</p>
</li>
<li><p>这个方法的缺陷是，如果一个线程在更新中失败，就没有线程能够再访问队列了。</p>
</li>
<li><p>为了使其成为非阻塞算法，我们必须保证一个线程的失败，不会阻止其他线程继续前进。因此，第二个诀窍是，确保如果B到达时发现数据结构正在被A修改，在数据结构中应该有足够多的信息，说明需要B来替代A完成更新。如果B“帮助”A完成其操作，那么B可以进行自己的操作，而不用等待A的操作完成。当A恢复后试图完成其操作，会发现B已经替它完成了。</p>
</li>
<li><p>以上的LinkedQueue展示了Michael-Scott的非阻塞链接队列算法的插入部分，它已经用在了ConcurrentLinkedQueue中。在很多队列算法中，一个空队列都有一个“哨兵(sentinel)节点”或者“虚(dummy)节点”，并且队首指针和队尾指针的初始化都指向哨兵节点。队尾指针永远指向哨兵节点(如果队列为空)，也就是队列的最后一个元素，或者(当操作正在更新队列时)指向倒数第二个元素。图15-3阐释了包含两个元素的队列的正常状态，或者说稳定状态。</p>
</li>
<li><p>插入新的元素涉及两个指针的更新。首先通过更新当前队尾元素的next指针把新节点链接到列表队尾；然后释放队尾指针，指向新的最末元素。在这两个操作之间，队列处于中间状态，如图15-4.在第二次更新后，队列再一次处于稳定状态，如图15-5.</p>
</li>
<li><p>要想同时实现两个窍门的方法是：假设队列处于稳定状态，则尾结点的next域指向null，如果队列处于中间状态，tail.next为非空。所以任何线程都能够通过检查tail.next即时地了解队列状态。进一步而言，如果队列处于中间状态，它能够通过推进队尾指针向前移动一个结点把状态恢复为稳定状态，结束任意线程正在插入元素的操作。</p>
</li>
</ul>
<h3><span id="1543-原子化的域更新器">15.4.3 原子化的域更新器</span></h3><pre><code>//在ConcurrentLinkedQueue中使用原子化的域更新器

private static class Node&lt;E&gt; &#123;
    private volatile E item;
    private volatile Node&lt;E&gt; next;

    private static final 
        AtomicReferenceFieldUpdater&lt;Node, Node&gt; 
        nextUpdater =
        AtomicReferenceFieldUpdater.newUpdater
        (Node.class, Node.class, &quot;next&quot;);

    Node(E x) &#123; item = x; &#125;

&#125;</code></pre>
<ul>
<li>原子化的域更新器类(在Integer、Long，以及Reference版本中可用)，代表着已存在的volatile域基于反射的“视图”，使得CAS能够用于已有的volatile域。更新器类没有构造函数；为了创建，你可以调用newUpdater的工厂方法，声明类和域的名称。域更新器类并不依赖特定的实例；它可以用于更新目标类任何实例的目标域。更新器类提供的原子性保护比普通的原子类差一些，因为你不能保证底层的域不被直接修改——compareAndSet和算术方法只在其他线程使用原子化的域更新器方法时保证其原子性。</li>
<li>在ConcurrentLinkedQueue中，更新Node的next域是通过使用nextUpdater的compareAndSet方法实现的。这个有点迂回的方案完全是因性能原因使用的。对于频繁分配的、生命周期短暂的对象，比如队列的链接节点，减少每个Node的AtomicReference创建，对于减少插入操作的开销是非常有效的。</li>
<li>然而，几乎在所有的情况下，普通原子变量表现已经相当不错了——仅仅在很少的情况下需要使用原子化的域更新器。(当你想要保存现有类的串行化形式时，原子化的域更新器会非常有用。)</li>
</ul>
<h3><span id="1544-aba问题">15.4.4 ABA问题</span></h3><ul>
<li>CAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值A和V相等就把B写入V。这个过程是原子性的。</li>
<li>CAS执行结果要么成功要么失败，对于失败的情形下一班采用不断重试。或者放弃。</li>
<li>ABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。</li>
<li>解决ABA问题相对简单的方案：<ul>
<li>更新一对值，包括引用和版本号。</li>
</ul>
</li>
</ul>
<h2><span id="summary">summary</span></h2><ul>
<li>非阻塞算法通过使用低层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些低层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。</li>
<li>非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。</li>
</ul>
<p></p>


  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/about">白色蜗牛</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/">https://java4u.cn/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/15-%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/Java并发编程/16-Java存储模型/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">16.Java存储模型 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/Java并发编程/14-构建自定义的同步工具/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">14.构建自定义的同步工具 </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="vcomments"></div>
  
  <script>
    loadScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js");
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();
      new Valine({
        el: '#vcomments',
        appId: 'Ro9jzghVgwRgtnGQQ99MFbAK-9Nh9j0Va',
        appKey: 'rbA6uGwupFqEcTUAugUoXn2B',
        placeholder: '留下你的足迹吧~也可以加我微信 919201148，互换友链~~~',
        path: window.location.pathname,
        avatar: 'robohash',
        meta: ["nick","mail","link"],
        pageSize: '10',
        lang: '',
        visitor: 'true',
        highlight: true,
        recordIP: false,
        
        
        
        enableQQ: 'false',
        requiredFields: [],
      });
    };
  </script>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.1 锁的劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.2 硬件对并发的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.1 比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.2 非阻塞计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.3 JVM对CAS的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.3 原子变量类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.1 原子变量是“更佳的volatile”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.2 性能比较：锁与原子变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.4 非阻塞算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.1 非阻塞栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.2 非阻塞链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.3 原子化的域更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.4 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
</div>

<!-- 百度自动推送链接-->
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/logo.jpg" class="author-img">

<p class="author-name">蜗牛 Java 之家</p>
<p class="author-description">Java 程序员的成长进阶社区</br>(Java for You)。</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>107</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>11</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>118</span>
    <span>标签</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png">
        <i class="iconfont icon-wechat society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/huayonglun/">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="http://weibo.com/huayonglun">
        <i class="iconfont icon-sina society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.1 锁的劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.2 硬件对并发的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.1 比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.2 非阻塞计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.3 JVM对CAS的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.3 原子变量类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.1 原子变量是“更佳的volatile”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.2 性能比较：锁与原子变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.4 非阻塞算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.1 非阻塞栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.2 非阻塞链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.3 原子化的域更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.4 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/Java">
        <div class="categories-list-item">
          Java
          <span class="categories-list-item-badge">14</span>
        </div>
      </a>
    
      <a href="/categories/Java并发编程">
        <div class="categories-list-item">
          Java并发编程
          <span class="categories-list-item-badge">18</span>
        </div>
      </a>
    
      <a href="/categories/Linux">
        <div class="categories-list-item">
          Linux
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/spring">
        <div class="categories-list-item">
          spring
          <span class="categories-list-item-badge">21</span>
        </div>
      </a>
    
      <a href="/categories/struts2">
        <div class="categories-list-item">
          struts2
          <span class="categories-list-item-badge">16</span>
        </div>
      </a>
    
      <a href="/categories/夯实基础系列">
        <div class="categories-list-item">
          夯实基础系列
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/工具教程">
        <div class="categories-list-item">
          工具教程
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/思维">
        <div class="categories-list-item">
          思维
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/数据库">
        <div class="categories-list-item">
          数据库
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/算法">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">25</span>
        </div>
      </a>
    
      <a href="/categories/网络">
        <div class="categories-list-item">
          网络
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\Java" title="Java"><div class="tags-list-item">Java</div></a>
    
    <a href="\tags\ssh" title="ssh"><div class="tags-list-item">ssh</div></a>
    
    <a href="\tags\spring" title="spring"><div class="tags-list-item">spring</div></a>
    
    <a href="\tags\Java并发" title="Java并发"><div class="tags-list-item">Java并发</div></a>
    
    <a href="\tags\struts2" title="struts2"><div class="tags-list-item">struts2</div></a>
    
    <a href="\tags\bean" title="bean"><div class="tags-list-item">bean</div></a>
    
    <a href="\tags\树" title="树"><div class="tags-list-item">树</div></a>
    
    <a href="\tags\AOP" title="AOP"><div class="tags-list-item">AOP</div></a>
    
    <a href="\tags\分布式" title="分布式"><div class="tags-list-item">分布式</div></a>
    
    <a href="\tags\链表" title="链表"><div class="tags-list-item">链表</div></a>
    
    <a href="\tags\装配属性" title="装配属性"><div class="tags-list-item">装配属性</div></a>
    
    <a href="\tags\集合" title="集合"><div class="tags-list-item">集合</div></a>
    
    <a href="\tags\二叉树" title="二叉树"><div class="tags-list-item">二叉树</div></a>
    
    <a href="\tags\查找" title="查找"><div class="tags-list-item">查找</div></a>
    
    <a href="\tags\排序" title="排序"><div class="tags-list-item">排序</div></a>
    
    <a href="\tags\同步" title="同步"><div class="tags-list-item">同步</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">

  <!-- 我的公众号 -->
  
  <article class="card card-content toc-card">
    <div style="float: left; ">
      <img class="adv" style="width: 100%; height: 100%; border: solid 1px #ddd;" src="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608142536200-image.png">
    </div>
    <div style="float: left; margin-left: 17px; margin-top: 12px;">
        <div style="font-size: 18px; margin-bottom: 12px;color:#159957;"><b>微信搜一搜: 蜗牛互联网</b></div>
        <small style="font-size: 0.9em;">
          👉「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyboCy8Drh8AWNqE_DUROg">技术干货</a>」每周推送<br>
          👉「<a href="https://java4u.cn/resources/">免费资料</a>」随时领取<br>
          👉「<a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608143152021-image.png">优质社群</a>」随时加入<br>
        </small>
    </div>
    <div style="clear: both;"></div>
    <div style="font-size: 0.8em; margin: 15px 0 15px 0;">
      <a href="" target="_blank" style="color:#159957;font-size: 14px;" rel="noopener noreferrer">扫描上方二维码，关注我的公众号</a>
      <br>
    </div>
  </article>


  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.1 锁的劣势</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.2 硬件对并发的支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.1 比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.2 非阻塞计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.2.3 JVM对CAS的支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.3 原子变量类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.1 原子变量是“更佳的volatile”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.3.2 性能比较：锁与原子变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">15.4 非阻塞算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.1 非阻塞栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.2 非阻塞链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link"><span class="toc-text">图解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.3 原子化的域更新器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">15.4.4 ABA问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">summary</span></a></li></ol>
  </article>
  

  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-15</div>
        <a href="/tools-course/cai_yun_xiao_yi/"><div class="recent-posts-item-content">彩云小译：最佳的网页翻译插件</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-14</div>
        <a href="/tools-course/markmap/"><div class="recent-posts-item-content">最佳的思维导图生成工具： markmap 使用教程</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-13</div>
        <a href="/tools-course/hexo_site_course/"><div class="recent-posts-item-content">建站神器：Hexo+Kaze+Gitee Pages 搭建静态博客网站</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2019-01-24</div>
        <a href="/思维/知识的诅咒：为什么你觉得显而易见，而对方却无法理解/"><div class="recent-posts-item-content">知识的诅咒：为什么你觉得显而易见，而对方却无法理解</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      
      <!-- copyringt-->
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2020
        </span>
        &nbsp;
        <a href="/" class="footer-link">蜗牛 Java 之家 </a>
      </div>

       <!-- copyringt-->
       <div class="footer-dsc">
        <center><span>
        <a href="https://java4u.cn/resources/" target="_blank">Java 程序员最全资源下载</a> - <a href="https://java4u.cn/links/" target="_blank">友情链接</a>
        </span></center>
      </div>
     
    </div>

    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  

  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>