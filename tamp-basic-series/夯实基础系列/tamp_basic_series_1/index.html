<!DOCTYPE html>
<html  lang="zh-CN" >
<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" id="theme-color">
  <meta name="description" content="蜗牛 Java 之家 (java4u.cn) 是 Java 程序员的成长进阶社区，致力于为广大学习 Java 的程序员们提供计算机专业相关的经验教程、学习资料和书籍，包括Java、数据库、Linux、网络等学习干货、IT程序员常用软件工具分享、计算机专业经典电子书PDF，帮助 Java 程序员更快入门和提高。">
  <link rel="icon" href="/img/logo.jpg">
  <title>夯实基础系列一：Java 基础总结&nbsp; | &nbsp;Java for You</title>
  
  
  <meta property="og:title" content="夯实基础系列一：Java 基础总结">
  
  
  <meta property="og:url" content="https://java4u.cn/tamp-basic-series/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/tamp_basic_series_1/index.html">
  
  
  <meta property="og:img" content="/img/logo.jpg">
  
  
  <meta property="og:img" content="&lt;h2 id=&#34;前言&#34;&gt;&lt;a href=&#34;#前言&#34; class=&#34;headerlink&#34; title=&#34;前言&#34;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;大学期间接触 Java 的时间也不短了，不论学习还是实习，都让我发觉基础的重要性。互联网发展太快了，各种框架各种技术更新迭代的速度非常快，可能你刚好掌握了一门技术的应用，它却已经走在淘汰的边缘了。&lt;/p&gt;
&lt;p&gt;而学习新技术总要付出一定的时间成本，那么怎么降低时间成本呢？那就是打好基础，技术再怎么革新，底层的东西也很少会变动，牢固的基础会帮助你在各种新技术的学习中游刃有余，快速上手。&lt;/p&gt;
&lt;p&gt;因为我选择的方向是后台开发，所以谈谈我认为的基础有哪些。其他方向肯定也有自己的体系，从低层到高层，可以自己摸索。后台的话，我觉得网络知识，各种协议，web 知识，数据库知识，Linux 基本操作以及自己选择的后台语言知识，这些是最基础最需要牢固掌握的。&lt;/p&gt;
&lt;p&gt;所以从今天起，会出一系列与后台基础相关的博文，一是对自己过去学习的一个总结，二是分享出来，希望可以帮助到需要的人。&lt;/p&gt;">
  
  
  <meta property="og:type" content="article">
  <meta property="og:article:published_time" content="2016-08-27">
  <meta property="og:article:modified_time" content="2020-12-19">
  <meta property="og:article:author" content="蜗牛 Java 之家">
  
  
  <meta property="og:article:tag" content="Java">
  
  <meta property="og:article:tag" content="基础">
  
  
  
  
  <script>
    // control reverse button
    var reverseDarkList = {
      dark: 'light',
      light: 'dark'
    };
    var themeColor = {
      dark: '#1c1c1e',
      light: '#fff'
    }
    // get the data of css prefers-color-scheme
    var getCssMediaQuery = function() {
      return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    };
    // reverse current darkmode setting function
    var reverseDarkModeSetting = function() {
      var setting = localStorage.getItem('user-color-scheme');
      if(reverseDarkList[setting]) {
        setting = reverseDarkList[setting];
      } else if(setting === null) {
        setting = reverseDarkList[getCssMediaQuery()];
      } else {
        return;
      }
      localStorage.setItem('user-color-scheme', setting);
      return setting;
    };
    // apply current darkmode setting
    var setDarkmode = function(mode) {
      var setting = mode || localStorage.getItem('user-color-scheme');
      if(setting === getCssMediaQuery()) {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[setting];
      } else if(reverseDarkList[setting]) {
        document.documentElement.setAttribute('data-user-color-scheme', setting);
        document.getElementById('theme-color').content = themeColor[setting];
      } else {
        document.documentElement.removeAttribute('data-user-color-scheme');
        localStorage.removeItem('user-color-scheme');
        document.getElementById('theme-color').content = themeColor[getCssMediaQuery()];
      }
    };
    setDarkmode();
  </script>
  <script>
    function loadScript(url, cb) {
      var script = document.createElement('script');
      script.src = url;
      if (cb) script.onload = cb;
      script.async = true;
      document.body.appendChild(script);
    }
  </script>
  
  <link rel="preload" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css" as="style" >
  <link rel="preload" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css" as="style" >
  
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.js" as="script">
  <link rel="preload" href="/js/lib/lightbox/baguetteBox.min.css" as="style" >
  
  
  <link rel="preload" href="/js/lib/lozad.min.js" as="script">
  
  
  
  
  
  <link rel="prefetch" href="//cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-svg.js" as="script">
  
  
  
  <link rel="prefetch" href="https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js" as="script">
  
  
  
  
<link rel="stylesheet" href="/css/main.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1946621_i1kgafibvw.css">

  
  
<link rel="stylesheet" href="//at.alicdn.com/t/font_1952792_89b4ac4k4up.css">

  
  
<link rel="stylesheet" href="/js/lib/lightbox/baguetteBox.min.css">

  
  
  
  


  <!-- 百度站长工具验证 -->
  <meta name="baidu-site-verification" content="code-9cIsKsXy75" />

  <!-- 必应站长工具验证-->
  <meta name="msvalidate.01" content="81AA8F485E800B7335F07A558BE9A636" />

  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-C22LNC79YC"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-C22LNC79YC');
</script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <div class="wrapper">
    
    <nav class="navbar">
  <div class="navbar-logo">
    <span class="navbar-logo-main">
      
      <img class="navbar-logo-img" src="/img/logo.jpg" alt="logo">
      
      <span class="navbar-logo-dsc">蜗牛 Java 之家</span>
    </span>
  </div>
  <div class="navbar-menu">
    
    <a href="/" class="navbar-menu-item">
    
    首页
    
    </a>
    
    <a href="/resources" class="navbar-menu-item">
    
    免费资源
    
    </a>
    
    <a href="/tools" class="navbar-menu-item">
    
    免费工具
    
    </a>
    
    <a href="/categories" class="navbar-menu-item">
    
    分类
    
    </a>
    
    <a href="/links" class="navbar-menu-item">
    
    友链
    
    </a>
    
    <a class="navbar-menu-item darknavbar" id="dark"><i class="iconfont icon-weather"></i></a>
    <a class="navbar-menu-item searchnavbar" id="search"><i class="iconfont icon-search" style="font-size: 1.2rem; font-weight: 400;"></i></a>
  </div>
</nav>
    
    <div id="local-search" style="display: none;">
      <input class="navbar-menu-item" id="search-input" placeholder="请输入搜索内容...">
      <div id="search-content"></div>
    </div>
    
    <div class="section-wrap">
      <div class="container">
        <div class="columns">
          <main class="main-column">
<div class="image-wrapper">
  <img src="/img/logo.jpg" data-src="/img/logo.jpg"
    srcset="data:image/svg+xml,%3Csvg%20xmlns=&#39;http://www.w3.org/2000/svg&#39;%20viewBox=&#39;0%200%20300%20300&#39;%3E%3C/svg%3E"
    class="image lozad"
    alt="thumbnail"
  >
</div>

<article class="card card-content">
  <header>
    <h1 class="post-title">
      夯实基础系列一：Java 基础总结
    </h1>
  </header>
  <div class="post-meta post-show-meta">
    <time datetime="2016-08-27T04:26:08.000Z">
      <i class="iconfont icon-calendar" style="margin-right: 2px;"></i>
      <span>2016-08-27</span>
    </time>
    
    <span class="dot"></span>
    
    <a href="/categories/tamp-basic-series/" class="post-meta-link">夯实基础系列</a>
    
    
    
    <span class="dot"></span>
    <span>5.3k 字</span>
    

    <span class="dot"></span>
    <!-- 增加阅读量统计样式代码 -->
    
    <!-- id 将作为查询条件 -->
    <i class="iconfont icon-wodebaobiao" style="margin-right: 2px; font-size: 1.15rem;"></i>
    <span id="/tamp-basic-series/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/tamp_basic_series_1/" class="leancloud_visitors" data-flag-title="夯实基础系列一：Java 基础总结">
      <em class="post-meta-item-text">阅读量 </em>
      <i class="leancloud-visitors-count"></i>
    </span>

  </div>
  
  <div class="post-meta post-show-meta" style="margin-top: -10px;">
    <div style="display: flex; align-items: center;">
      <i class="iconfont icon-biaoqian" style="margin-right: 2px; font-size: 1.15rem;"></i>
      
      
        <a href="/tags/Java/" class="post-meta-link">Java</a>
      
      
      <span class="dot"></span>
      
        <a href="/tags/basic/" class="post-meta-link">基础</a>
      
    </div>
  </div>
  
  </header>
  <div id="section" class="post-content">
    <h2><span id="前言">前言</span></h2><p>大学期间接触 Java 的时间也不短了，不论学习还是实习，都让我发觉基础的重要性。互联网发展太快了，各种框架各种技术更新迭代的速度非常快，可能你刚好掌握了一门技术的应用，它却已经走在淘汰的边缘了。</p>
<p>而学习新技术总要付出一定的时间成本，那么怎么降低时间成本呢？那就是打好基础，技术再怎么革新，底层的东西也很少会变动，牢固的基础会帮助你在各种新技术的学习中游刃有余，快速上手。</p>
<p>因为我选择的方向是后台开发，所以谈谈我认为的基础有哪些。其他方向肯定也有自己的体系，从低层到高层，可以自己摸索。后台的话，我觉得网络知识，各种协议，web 知识，数据库知识，Linux 基本操作以及自己选择的后台语言知识，这些是最基础最需要牢固掌握的。</p>
<p>所以从今天起，会出一系列与后台基础相关的博文，一是对自己过去学习的一个总结，二是分享出来，希望可以帮助到需要的人。</p>
<a id="more"></a>

<h2><span id="概要">概要</span></h2><p>Java 基础我做了 10 个方面的总结，包括基本概念，面向对象，关键字，基本类型与运算，字符串与数组，异常处理，Java 平台与内存管理，分布式 Java 应用，多线程，IO。以下对这些内容做一些简单的总结，同时我也有完整的思维导图，博客上不方便展示，若有需要，请关注微信公众号<strong>蜗牛互联网</strong>，后台回复 Java 即可获取。</p>
<p><img src="https://gitee.com/java4u/resources/raw/master/2020-12-19/1608391756099-image.png" alt="Java 基础大纲" srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/2020-12-19/1608391756099-image.png" class="lozad post-image"></p>
<h2><span id="细节">细节</span></h2><h3><span id="1-基本概念">1. 基本概念</span></h3><h5><span id="11-语言特点">1.1 语言特点</span></h5><ul>
<li><p>纯面向对象</p>
</li>
<li><p>平台无关性</p>
</li>
<li><p>内置类库</p>
</li>
<li><p>支持 web</p>
</li>
<li><p>安全性</p>
<ul>
<li>防止代码攻击</li>
</ul>
</li>
<li><p>健壮性</p>
<ul>
<li>强类型机制</li>
<li>垃圾回收器</li>
<li>异常处理</li>
<li>安全检查机制</li>
</ul>
</li>
<li><p>去除 C++ 中难以理解易混淆的特性</p>
</li>
</ul>
<h5><span id="12-与-c-比较">1.2 与 C++ 比较</span></h5><ul>
<li>解释编译混合型语言，执行速度慢，跨平台</li>
<li>纯面向对象，只有类，不存在全局变量或全局函数</li>
<li>无指针，无多继承，可多实现</li>
<li>垃圾回收器自动管理内存</li>
</ul>
<h5><span id="13-main函数知识">1.3 main函数知识</span></h5><ul>
<li>Java 程序入口方法</li>
<li>可由 final，synchronized 修饰，不能用 abstract</li>
</ul>
<h5><span id="14-java程序初始化顺序">1.4 Java程序初始化顺序</span></h5><ul>
<li>静态优于非静态</li>
<li>父类优于子类</li>
<li>按照成员变量的定义顺序</li>
<li>总共 10 个</li>
</ul>
<h5><span id="15-作用域与可见性">1.5 作用域与可见性</span></h5><ul>
<li>静态变量属于类</li>
<li>局部变量属于花括号</li>
<li>成员变量看下一条</li>
<li>public、protected、default、private 可见性依次递减</li>
</ul>
<h5><span id="16-构造函数">1.6 构造函数</span></h5><ul>
<li>与类名相同，无返回值</li>
<li>可重载，不能被继承，即不能被覆盖</li>
<li>参数个数任意</li>
<li>伴随 new 一起调用，为系统调用</li>
<li>完成对象的初始化工作</li>
<li>子类可通过 super 显式调用父类。父类没有提供无参，子类必须显式调用</li>
<li>未定义，默认无参，修饰符取决于类修饰符</li>
</ul>
<h5><span id="17-标识接口">1.7 标识接口</span></h5><ul>
<li>无任何方法声明</li>
<li>表示实现它的类属于一个特定的类型</li>
</ul>
<h5><span id="18-clone-方法">1.8 clone 方法</span></h5><ul>
<li>实现 Cloneable 接口</li>
<li>重写 Object 类中的 clone()</li>
<li>clone() 中调用 super.clone()</li>
<li>把浅复制引用指向新的克隆体</li>
</ul>
<h5><span id="19-反射">1.9 反射</span></h5><ul>
<li>定义：允许程序在运行时进行自我检查，也允许对其内部成员进行操作</li>
<li>功能<ul>
<li>得到一个对象所属的类</li>
<li>获取一个类的所有成员和方法</li>
<li>运行时创建对象</li>
<li>在运行时调用对象的方法</li>
</ul>
</li>
<li>获取类的方式<ul>
<li>class.forName(“类路径”)</li>
<li>类名.class</li>
<li>实例.getClass()</li>
</ul>
</li>
</ul>
<h5><span id="110-创建对象的四种方式">1.10 创建对象的四种方式</span></h5><ul>
<li>new</li>
<li>反射机制</li>
<li>clone()</li>
<li>反序列化</li>
</ul>
<h5><span id="111-package-作用">1.11 package 作用</span></h5><ul>
<li>提供多层命名空间，解决命名冲突</li>
<li>对类按功能进行分类，使项目组织更加清晰</li>
</ul>
<h3><span id="2-面向对象">2. 面向对象</span></h3><h5><span id="21-与面向过程区别">2.1 与面向过程区别</span></h5><ul>
<li>层次逻辑关系不同。<ul>
<li>面向对象是通过类的层次结构来体现类之间的继承与发展</li>
<li>面向过程是通过模块的层次结构概括模块与模块间的关系与功能</li>
</ul>
</li>
<li>数据处理方式不同与控制程序方式不同<ul>
<li>面向对象是数据与操作封装成一个整体，通过事件驱动来激活和运行程序</li>
<li>面向过程是数据单独存储，控制程序方式上按照设计调用或返回程序</li>
</ul>
</li>
</ul>
<h5><span id="22-特性">2.2 特性</span></h5><ul>
<li>抽象</li>
<li>继承</li>
<li>多态</li>
<li>封装</li>
</ul>
<h5><span id="23-这种开发方式优点">2.3 这种开发方式优点</span></h5><ul>
<li>开发效率高。代码重用</li>
<li>保证软件的鲁棒性。经过长期测试的已有代码</li>
<li>保证软件的高可维护性。设计模式成熟</li>
</ul>
<h5><span id="24-继承">2.4 继承</span></h5><ul>
<li>单继承</li>
<li>只能继承父类的非私有成员变量和方法</li>
<li>同名成员变量，子类覆盖，不会继承</li>
<li>相同函数签名，子类覆盖，不会继承</li>
</ul>
<h5><span id="25-组合和继承区别">2.5 组合和继承区别</span></h5><ul>
<li>组合：在新类中创建原有类的对象。has a</li>
<li>继承是    is a</li>
</ul>
<h5><span id="26-多态">2.6 多态</span></h5><ul>
<li>方法重载<ul>
<li>编译时多态</li>
</ul>
</li>
<li>方法覆盖<ul>
<li>运行时多态</li>
</ul>
</li>
<li>成员变量无多态概念</li>
</ul>
<h5><span id="27-覆盖和重载区别">2.7 覆盖和重载区别</span></h5><ul>
<li>子父类关系，垂直；同类方法间关系，水平</li>
<li>一对方法发生关系；多个方法发生关系</li>
<li>参数列表相同；参数列表不同</li>
<li>调用的方法根据对象的类型决定；根据调用时的实参表决定方法体</li>
</ul>
<h5><span id="28-抽象类与接口异同">2.8 抽象类与接口异同</span></h5><p>同</p>
<ul>
<li>不能被实例化</li>
<li>接口的实现类实现了接口，抽象类的子类实现了方法，才能被实例化</li>
</ul>
<p>异</p>
<ul>
<li>接口只能定义方法，不能实现；抽象类可以有定义和实现</li>
<li>接口需要被实现；抽象类需要被继承</li>
<li>接口强调特定功能的实现；抽象类强调所属关系</li>
<li>接口成员变量默认为 public static final，成员方法 public abstract</li>
<li>抽象类变量默认 default，方法不能用 private、static、synchronized、native 修饰</li>
</ul>
<h5><span id="29-内部类">2.9 内部类</span></h5><ul>
<li>静态内部类<ul>
<li>static 修饰</li>
<li>只能访问外部类中的 static 数据</li>
</ul>
</li>
<li>成员内部类<ul>
<li>与实例绑定</li>
<li>不可定义静态属性和方法</li>
<li>外部实例化后，该内部类才能被实例化</li>
</ul>
</li>
<li>局部内部类<ul>
<li>代码块内</li>
<li>不能被 public、protected、private 以及 static 修饰</li>
<li>只能访问 final 局部变量</li>
</ul>
</li>
<li>匿名内部类<ul>
<li>无类名</li>
<li>无构造函数，必须继承或实现其他类</li>
<li>原则<ul>
<li>无构造函数</li>
<li>无静态成员，方法和类</li>
<li>不能是 public、protected、private、static</li>
<li>只能创建匿名内部类的一个实例</li>
<li>new 后面有继承或实现</li>
<li>特殊的局部内部类</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><span id="210-如何获取父类类名">2.10 如何获取父类类名</span></h5><ul>
<li>利用反射：obj.getClass().getSuperClass().getName()</li>
<li>不使用 super.getClass() 原因：该方法在 Object 中为 final 与 native，子类不能覆盖，返回此 Object 运行时类</li>
</ul>
<h5><span id="211-this">2.11 this</span></h5><ul>
<li>指向当前实例对象</li>
<li>区分成员变量与方法形参</li>
</ul>
<h5><span id="212-super">2.12 super</span></h5><ul>
<li>访问父类成员变量或方法</li>
<li>子类同名会覆盖，访问父类只能通过 super</li>
<li>子类构造函数需显示调用父类构造函数时，super() 必须为构造函数的第一条语句</li>
</ul>
<h3><span id="3-关键字">3. 关键字</span></h3><h5><span id="31-变量命名">3.1 变量命名</span></h5><ul>
<li>英文字母</li>
<li> 数字</li>
<li> _和$</li>
<li> 不能包含空白字符</li>
<li> 首字符不能为数字</li>
<li> 保留字不能做标识符</li>
<li> 区分大小写</li>
</ul>
<h5><span id="32-assert">3.2 assert</span></h5><ul>
<li>软件调试 </li>
<li>运行时开启        -ea</li>
</ul>
<h5><span id="33-static">3.3 static</span></h5><ul>
<li>特定类的统一存储空间，类绑定</li>
<li>成员变量：属于类，内存中只有一个复制</li>
<li>成员方法：调静态数据。可实现单例模式</li>
<li>代码块：初始化静态变量，只被执行一次</li>
<li>内部类：不能与外部类重名，只能访问外部类静态数据(包括私有)</li>
</ul>
<h5><span id="34-switch">3.4 switch</span></h5><ul>
<li>多分支选择</li>
<li>整型或字符类型变量或整数表达式</li>
<li>Java 7 开始支持 String。原理是 String 的 hashCode() 返回的 int 类型值匹配</li>
</ul>
<h5><span id="35-volatile">3.5 volatile</span></h5><ul>
<li>保证线程间的可见性</li>
<li>从内存中取数据，而不是缓存</li>
<li>不保证原子性</li>
</ul>
<h5><span id="36-instanceof">3.6 instanceof</span></h5><ul>
<li>二元运算符</li>
<li>判断一个引用类型的变量所指向的对象是否是一个类的实例</li>
<li>即左边对象是否是右边类的实例</li>
</ul>
<h5><span id="37-strictfp">3.7 strictfp</span></h5><ul>
<li>精确浮点</li>
<li>确保浮点运算的准确性</li>
<li>若不指定，结果依赖于虚拟机平台</li>
<li>指定后依赖于统一标准，保证各平台的一致性</li>
</ul>
<h5><span id="38-null">3.8 null</span></h5><ul>
<li>不是合法的 Object 实例</li>
<li>无内存</li>
<li>表明该引用目前没有指向任何对象</li>
</ul>
<h3><span id="4-基本类型与运算">4. 基本类型与运算</span></h3><h5><span id="41-基本数据类型">4.1 基本数据类型</span></h5><ul>
<li>int长度<ul>
<li>byte(8 bit)</li>
<li>short(16 bit)</li>
<li>int(32 bit)</li>
<li>long(64 bit)</li>
</ul>
</li>
<li>float长度<ul>
<li>单精度(32 bit float)</li>
<li>双精度(64 bit double)</li>
</ul>
</li>
<li>boolean 类型变量的取值<ul>
<li>true</li>
<li>false</li>
</ul>
</li>
<li>char数据类型:Unicode字符(16 bit)</li>
<li>void:java.lang.Void 无法直接对其进行操作</li>
</ul>
<h5><span id="42-不可变类">4.2 不可变类</span></h5><ul>
<li>实例创建后，值不可变</li>
<li>所有的基本类型的包装类+String</li>
<li>优点<ul>
<li>使用简单</li>
<li>线程安全</li>
<li>节省内存</li>
</ul>
</li>
<li>缺点:会因为值的不同而产生新的对象，导致无法预料的问题</li>
</ul>
<h5><span id="43-类型转换">4.3 类型转换</span></h5><ul>
<li><p>隐式类型转换</p>
<ul>
<li>低精度到高精度</li>
<li>byte-&gt;short-&gt;char-&gt;int-&gt;long-&gt;float-&gt;double</li>
</ul>
</li>
<li><p>显式类型转换</p>
<ul>
<li>反之</li>
<li>可能会损失精度</li>
</ul>
</li>
<li><p>类型自动转换</p>
<ul>
<li>低到高</li>
<li>char 类型会转换为其对应的 ASCII 码</li>
<li>byte、char、short 参与运算自动转为 int，但”+=”，不转</li>
<li>基本数据类型与 boolean 不能相互转换</li>
<li>多种类型混合运算，自动转成容量最大类型</li>
</ul>
</li>
<li><p>运算符优先级</p>
<pre><code>  点    ()    []</code></pre>
<p>  ​    +(正)    -(负)        ++    –    ~    !<br>  ​    *    /    %<br>  ​    +(加)    -(减)<br>  ​    &lt;&lt;    &gt;&gt;    &gt;&gt;&gt;<br>  ​    &lt;    &lt;=    &gt;    &gt;=    instanceof<br>  ​    ==    !=<br>  ​    &amp;<br>  ​    |<br>  ​    ^<br>  ​    &amp;&amp;<br>  ​    ||<br>  ​    ?:<br>  ​    =    +=    -=    *=    /=    %=    &amp;=       |=    ^=    ~=    &lt;&lt;=    &gt;&gt;=    &gt;&gt;&gt;=</p>
</li>
</ul>
<h3><span id="5-字符串与数组">5. 字符串与数组</span></h3><h5><span id="51-字符串创建与存储机制">5.1 字符串创建与存储机制</span></h5><ul>
<li>堆</li>
<li>常量池</li>
<li>new String(“abc”) 创建 1 个或 2 个对象</li>
</ul>
<h5><span id="52-equals和hashcode区别">5.2 ==、equals和hashCode区别</span></h5><ul>
<li> ==    比较引用，内存</li>
<li> 未覆盖，同 ==；比较内容</li>
<li> hashCode鉴定对象是否相等，返回整数</li>
</ul>
<h5><span id="53-stringstringbufferstringbuilder">5.3 String,StringBuffer,StringBuilder</span></h5><ul>
<li>String:不可变，执行效率最低</li>
<li>StringBuffer:可修改，线程安全，效率较高</li>
<li>StringBuilder:可修改，线程不安全，效率最高</li>
</ul>
<h5><span id="54-其他">5.4 其他</span></h5><ul>
<li>数组初始化方式</li>
<li>length 属性和 length() 方法</li>
</ul>
<h3><span id="6-异常处理">6. 异常处理</span></h3><h5><span id="61-finally-块执行时机">6.1 finally 块执行时机</span></h5><ul>
<li>若 try 中有 return，在 return 前</li>
<li>若 try-finally 或 catch-finally 中都有 return，finally 会覆盖</li>
</ul>
<h5><span id="62-finally-代码块不是一定会被执行">6.2 finally 代码块不是一定会被执行</span></h5><ul>
<li>程序进入try之前出现异常</li>
<li>try 中调用System.exit(0)</li>
</ul>
<h5><span id="63-error">6.3 Error</span></h5><p>严重错误，不可恢复</p>
<h5><span id="64-exception">6.4 Exception</span></h5><ul>
<li>可恢复，编译器可捕捉</li>
<li>检查性异常<ul>
<li>IO</li>
<li>SQL</li>
</ul>
</li>
<li>运行时异常<ul>
<li>JVM处理</li>
<li>NullPointException</li>
<li>ClassCastException</li>
<li>ArrayIndexOutOfBoundsException</li>
</ul>
</li>
<li>出现异常后，一直往上层抛，直到遇到处理代码或最上层</li>
<li>多态。若先捕获基类，再捕获子类。子类处理代码将永远不会得到执行</li>
</ul>
<h3><span id="7-java-平台与内存管理">7. Java 平台与内存管理</span></h3><h5><span id="71-java-平台与其他语言平台的区别">7.1 Java 平台与其他语言平台的区别</span></h5><ul>
<li>纯软件，包括 JVM 与 JAVA API</li>
<li>JVM 虚拟，不跨平台</li>
</ul>
<h5><span id="72-java-代码的执行">7.2 JAVA 代码的执行</span></h5><ul>
<li>代码编译为 class：sun jdk 中 javac</li>
<li>装载 class：ClassLoader</li>
<li>执行 class<ul>
<li>解释执行</li>
<li>编译执行<ul>
<li>client compiler</li>
<li>server compiler</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><span id="73-java-源码编译机制">7.3 java 源码编译机制</span></h5><ul>
<li>词法分析器组件：Token 流</li>
<li>语法分析器组件：语法树</li>
<li>语义分析器组件：注解语法树<ul>
<li>将语法树中的名字、表达式等元素与变量、方法、类型等联系到一起</li>
<li>检查变量使用前是否已声明</li>
<li>推导泛型方法的类型参数</li>
<li>检查类型匹配性</li>
<li>进行常量折叠</li>
<li>检查所有语句都可到达</li>
<li>检查变量的确定性赋值</li>
<li>解除语法糖</li>
<li>将泛型 JAVA 转成普通 Java</li>
<li>检查所有 checked exception 都被捕获或抛出</li>
<li>将含语法糖的语法树转成简单语法树 eg:foreach，自动折叠</li>
</ul>
</li>
<li>代码生成器组件：字节码</li>
</ul>
<h5><span id="74-类加载机制">7.4 类加载机制</span></h5><ul>
<li>装载：全限定名+类加载器加载类</li>
<li>链接<ul>
<li>校验<ul>
<li>格式不符，抛 VerifyError</li>
<li>加载引用的类失败：抛 NoClassDefFoundError</li>
</ul>
</li>
<li>准备：静态变量默认初始化</li>
<li>解析：属性、方法验证(可选)</li>
</ul>
</li>
<li>初始化(不是类加载必须触发的)<ul>
<li>静态初始化代码</li>
<li>构造器代码</li>
<li>静态属性初始化</li>
<li>触发时机<ul>
<li>调用了 new</li>
<li>反射调用了类中的方法</li>
<li>子类调用了初始化</li>
<li>JVM 启动过程中指定的初始化类<ul>
<li>Bootstrap Class Loader：$JAVA_HOME/jre/lib/rt.jar</li>
<li>Extension Class Loader：$JAVA_HOME/jre/lib/ext/*.jar</li>
<li>System Class Loader：$CLASSPATH</li>
<li>User Defined Class Loader</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><span id="75-类执行机制">7.5 类执行机制</span></h5><ul>
<li><p>解释执行</p>
<ul>
<li>JVM 字节码为中间代码，由 JVM 在运行期对其解释并执行<ul>
<li>invokestatic</li>
<li>invokevirtual</li>
<li>invokeinterface</li>
<li>invokespecial</li>
</ul>
</li>
<li>基于栈<ul>
<li>代码紧凑，体积小</li>
<li>线程创建后，产生 PC 和 Stack</li>
<li>指令解释执行</li>
<li>栈顶缓存：栈顶值缓存在寄存器上</li>
<li>部分栈帧共享</li>
</ul>
</li>
</ul>
</li>
<li><p>编译执行</p>
<ul>
<li>client compiler<ul>
<li>轻量级，占内存少</li>
<li>方法内联</li>
<li>去虚拟化</li>
<li>冗余消除</li>
</ul>
</li>
<li>server compiler<ul>
<li>重量级，占内存多</li>
<li>逃逸分析是 C2 进行很多优化的基础</li>
<li>标量替换：用标量替换聚合量</li>
<li>栈上分配<ul>
<li>若对象未逃逸，C2 会选择在栈上直接创建Point对象实例，而不是在堆上</li>
<li>栈上分配更快速，对象易回收</li>
</ul>
</li>
<li>同步消除：如果发现同步的对象未逃逸，那也没有同步的必要。C2 会去掉同步代码块</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><span id="76-内存空间">7.6 内存空间</span></h5><ul>
<li>方法区：类信息，线程共享</li>
<li>堆<ul>
<li>对象实例+数组</li>
<li>分代管理<ul>
<li>新生代</li>
<li>旧生代</li>
</ul>
</li>
</ul>
</li>
<li>本地方法栈：支持 native 方法，Sun JDK 的实现中本地方法栈和 JVM 方法栈是同一个</li>
<li>PC 寄存器：线程私有</li>
<li>JVM 方法栈：线程私有</li>
</ul>
<h5><span id="77-内存分配">7.7 内存分配</span></h5><ul>
<li>Java 对象，堆上分配，分配需加锁，开销大</li>
<li>当堆上空间不足–&gt;GC–&gt;仍不足–&gt;抛 OutOfMemory</li>
<li>Sun JDK 为新创建的线程在 Eden 上分配 TLAB</li>
<li>多个小对象比大对象分配更高效</li>
<li>基于逃逸分析直接从栈上分配</li>
</ul>
<h5><span id="78-内存回收">7.8 内存回收</span></h5><ul>
<li>收集器<ul>
<li>引用计数收集器<ul>
<li>计数器增减有消耗</li>
<li>不适合循环引用</li>
</ul>
</li>
<li>跟踪收集器<ul>
<li>集中式管理</li>
<li>全局记录数据的引用状态</li>
<li>从根集合扫描对象，可能会造成应用程序暂停</li>
<li>三种实现算法<ul>
<li>复制<ul>
<li>适用于回收空间中存活对象较少</li>
<li>缺点：需要增加一块空的内存空间及进行对象的移动</li>
</ul>
</li>
<li>标记-清除：会产生内存碎片</li>
<li>标记-压缩：不产生内存碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Sun JDK 中可用 GC<ul>
<li>新生代<ul>
<li>串行 GC(Serial GC)：复制算法<ul>
<li>Minor GC</li>
<li>强软弱虚</li>
</ul>
</li>
<li>并行回收 GC(Parrallel Scavenge)：扫描复制多线程</li>
<li>并行 GC(ParNew)：配合旧生代 CMS</li>
</ul>
</li>
<li>旧生代和持久代可用GC<ul>
<li>串行：标记压缩+清除</li>
<li>并行：标记压缩</li>
<li>并发：CMS<ol>
<li>标记：暂停</li>
<li>并发标记：恢复，轮询着色对象，以标记它们</li>
<li>重新标记：暂停</li>
<li>并发收集：恢复</li>
</ol>
</li>
<li>CMS 内存回收易产生碎片，但是它提供了整理碎片的功能</li>
<li>浮动垃圾：CMS 回收时产生应该回收但要等到下次 CMS 才能被回收掉的对象</li>
</ul>
</li>
</ul>
</li>
<li>Full GC<ul>
<li>对新生代旧生代及持久代都进行的 GC</li>
<li>触发的四种情况<ul>
<li>旧生代空间不足</li>
<li>持久代空间满</li>
<li>CMS GC 出现 promotion failed 和 concurrent mode failure</li>
<li>统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5><span id="79-内存泄露">7.9 内存泄露</span></h5><ul>
<li>一个不再被程序使用的对象或变量还在内存中占有存储空间</li>
<li>符合垃圾回收标准<ul>
<li>对象赋空值 null</li>
<li>给对象赋予新值，重新分配了内存空间</li>
</ul>
</li>
<li>泄露的两种情况<ul>
<li>堆中申请的空间没有被释放</li>
<li>对象不再被使用，但仍然存活在内存中</li>
</ul>
</li>
<li>泄露原因<ul>
<li>静态集合类</li>
<li>各种连接</li>
<li>监听器</li>
<li>变量不合理的作用域</li>
<li>单例模式</li>
</ul>
</li>
</ul>
<h3><span id="8-分布式-java-应用">8. 分布式 Java 应用</span></h3><h5><span id="81-基于消息方式实现系统间的通信">8.1 基于消息方式实现系统间的通信</span></h5><ul>
<li>TCP/IP+BIO<ul>
<li>socket.setSoTimeOut() 设置等待响应的超时时间</li>
<li>一连接一线程</li>
<li>缺点：无论连接是否真实，都要创建线程</li>
<li>BIO下服务器端所能支撑的连接数目有限</li>
</ul>
</li>
<li>TCP/IP+NIO<ul>
<li>Channel<ul>
<li>SocketChannel：建立连接，监听事件，操作读写</li>
<li>ServerSocketChannel：监听端口，监听连接事件</li>
</ul>
</li>
<li>Selector：获取是否要处理的事件</li>
<li>Buffer：存放处理的数据</li>
<li>NIO    Reactor 模式，通过注册感兴趣的事件及扫描是否有感兴趣的事件发生，从而做出相应的动作</li>
<li>多个请求，连接复用</li>
<li>只有在有真实的请求时，才会创建线程</li>
<li>一请求一线程</li>
</ul>
</li>
<li>UDP/IP+BIO<ul>
<li>DatagramSocket：负责监听端口，读写数据</li>
<li>DatagramPacket：作为数据流对象进行传输</li>
</ul>
</li>
<li>UDP/IP+NIO<ul>
<li>DatagramChannel：监听端口，进行读写</li>
<li>ByteBuffer：数据流传输</li>
</ul>
</li>
<li>NIO好处：只在有流要读取或可写入流时才做出相应的 IO 操作，而不像 BIO 方式阻塞当前线程</li>
</ul>
<h5><span id="82-基于远程调用方式实现系统间的通信">8.2 基于远程调用方式实现系统间的通信</span></h5><ul>
<li>远程调用方式<ul>
<li>系统间通信和系统内一样</li>
<li>让使用者感觉调用远程同调用本地一样</li>
</ul>
</li>
<li>基于 Java 自身技术<ul>
<li>RMI：客户端代理，stub，封装对象，序列化为流，TCP/IP BIO，Skeleton，反序列化，获取对象实例，调用</li>
<li>WebService<ol>
<li>服务端的服务生成 WSDL 文件</li>
<li>将应用+WSDL 文件放入 HTTP 服务器</li>
<li>借用 Java 辅助工具根据 WSDL 文件生成客户端 stub 代码</li>
<li>stub 将产生的对象请求信息封装为标准化的 SOAP 格式数据，并发请求到服务器端</li>
<li>服端在接收到 SOAP 格式数据时进行转化，反射调用相应的 Java 类</li>
<li>SOAP 优点支持跨语言，缺点对复杂对象结构难支持</li>
</ol>
</li>
</ul>
</li>
</ul>
<h5><span id="83-基于开源框架">8.3 基于开源框架</span></h5><ul>
<li>Spring RMI</li>
</ul>
<h3><span id="9-多线程">9. 多线程</span></h3><h5><span id="91-线程资源同步机制">9.1 线程资源同步机制</span></h5><ul>
<li>JVM 保证以下操作顺序<ul>
<li>同一线程操作</li>
<li>对于 main Memory 上的同一个变量的操作</li>
<li>对于加了锁的 main Memory 上的对象操作</li>
</ul>
</li>
<li>为避免资源操作的脏数据问题，JVM 提供了<ul>
<li>synchronized</li>
<li>volatile</li>
<li>lock/unlock</li>
<li>目的是控制资源竞争</li>
</ul>
</li>
</ul>
<h5><span id="92-线程交互机制">9.2 线程交互机制</span></h5><ul>
<li>基于 Object 的 wait/notify/notifyAll<ul>
<li>为避免假唤醒，需要 double check</li>
<li>调用对象的 wait–&gt;wait sets—&gt;释放锁—&gt;其他线程 notify—-&gt;wait sets—-&gt;执行此对象线程—&gt;删除 sets中此线程</li>
</ul>
</li>
<li>基于 JDK 5 并发包，支持线程交互<ul>
<li>Semphore 的 acquire，release</li>
<li>Condition 的 await，signal</li>
<li>CountDownLatch 的 await 和 countDown</li>
</ul>
</li>
</ul>
<h5><span id="93-线程状态">9.3 线程状态</span></h5><ul>
<li>New</li>
<li>Runnable </li>
<li>Running</li>
<li>Wait</li>
<li>TimedWait</li>
<li>Blocked</li>
<li>Terminated</li>
</ul>
<h5><span id="94-sleep-与-wait-方法的区别">9.4 sleep() 与 wait() 方法的区别</span></h5><ul>
<li>sleep<ul>
<li>暂停一段时间执行</li>
<li>Thread 的静态方法</li>
<li>不释放锁</li>
<li>需要捕获异常</li>
</ul>
</li>
<li>wait<ul>
<li>使线程暂停执行</li>
<li>Object 方法，用于线程间通信</li>
<li>释放锁</li>
</ul>
</li>
</ul>
<h5><span id="95-守护线程">9.5 守护线程</span></h5><ul>
<li>后台提供服务</li>
<li>用户线程全部终止，只剩下守护线程时，JVM 就会退出</li>
<li>调用 start() 之前，调用线程对象的 setDaemon(true)</li>
</ul>
<h5><span id="96-join">9.6 join</span></h5><ul>
<li>调用该方法的线程在执行完 run() 后，再执行 join 方法后面的代码</li>
<li>线程合并，实现同步功能</li>
</ul>
<h3><span id="10-io">10. IO</span></h3><h5><span id="101-流本质">10.1 流本质</span></h5><ul>
<li>数据传输</li>
</ul>
<h5><span id="102-流分类">10.2 流分类</span></h5><ul>
<li>字节流:不使用缓存</li>
<li>字符流<ul>
<li>码表映射</li>
<li>使用缓存</li>
</ul>
</li>
</ul>
<h5><span id="103-装饰者模式">10.3 装饰者模式</span></h5><ul>
<li>运行时动态给对象增加额外的职责</li>
<li>是你还有你，一切拜托你</li>
<li>FilterInputStream</li>
</ul>
<h5><span id="104-java-socket">10.4 Java Socket</span></h5><ul>
<li>ServerSocket server = new ServerSocket(2000);</li>
<li>Socker socket = server.accept();</li>
<li>客户端：Socket socket = new Socket(“localhost”,2000);</li>
</ul>
<h5><span id="105-nio">10.5 NIO</span></h5><ul>
<li>Channel–Selector–Buffer</li>
<li>反应器模式</li>
</ul>
<h5><span id="106-序列化">10.6 序列化</span></h5><ul>
<li>对象持久化方式</li>
<li>解决在对对象流进行读写操作时引发的问题</li>
<li>对象写进流里进行网络传输，保存到文件，数据库</li>
</ul>
<h5><span id="107-如何实现序列化">10.7 如何实现序列化</span></h5><ul>
<li>实现 Serializable 接口</li>
<li>使用 FileOutputStream 来构造 ObjectOutputStream 对象</li>
<li>使用该对象的 writeObject(obj) 方法将对象写出</li>
<li>要恢复时，使用对应的输入流</li>
</ul>
<h5><span id="108-序列化特点">10.8 序列化特点</span></h5><ul>
<li>一个类能被序列化，它的子类也能被序列化</li>
<li>static 代表类成员，transient 代表临时数据。均不能被序列化</li>
<li>序列化影响性能，需要才使用</li>
<li>需要通过网络来发送对象，或对象的状态需要被持久化到数据库或文件中</li>
<li>序列化能实现深复制，即可以复制引用的对象</li>
</ul>
<h5><span id="109-反序列化">10.9 反序列化</span></h5><ul>
<li>将流转化为对象</li>
<li>UID 最好自己定义。优点<ul>
<li>提高程序运行效率。省去计算过程</li>
<li>提高程序不同平台兼容性。不同计算方式，反序列化失败</li>
<li>增强程序各个版本的可兼容性。加入新属性，默认UID变化</li>
</ul>
</li>
</ul>
<h5><span id="1010-外部序列化">10.10 外部序列化</span></h5><ul>
<li>实现 Externalizable 接口控制</li>
</ul>
<p></p>


<hr>
<p><img  srcset="data:image/svg+xml,%3Csvg%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%20300%20300'%3E%3C/svg%3E" data-src="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png" class="lozad post-image"src="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png"></p>

  </div>
  <div>
  
  <div class="post-note note-warning copyright" style="margin-top: 42px">
    <p><span style="font-weight: bold;">作者：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/about">白色蜗牛</a></p>
    <p><span style="font-weight: bold;">文章链接：</span><a target="_blank" rel="nofollow noopener noreferrer" href="https://java4u.cn/tamp-basic-series/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/tamp_basic_series_1/">https://java4u.cn/tamp-basic-series/%E5%A4%AF%E5%AE%9E%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97/tamp_basic_series_1/</a></p>
    <p><span style="font-weight: bold;">版权声明：</span>本博客所有文章除特别声明外，均采用<a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">CC BY-NC-SA 4.0 协议</a>。转载请注明出处！</p>
  </div>
  
  </div>
</article>
<div class="nav">
  
  <div class="nav-item-prev">
    <a href="/tamp-basic-series/夯实基础系列/tamp_basic_series_2/" class="nav-link">
      <i class="iconfont icon-left nav-prev-icon"></i>
      <div>
        <div class="nav-label">上一篇</div>
        
        <div class="nav-title">夯实基础系列二：网络知识总结 </div>
        
      </div>
    </a>
  </div>
  
  
  <div class="nav-item-next">
    <a href="/Java/Java/并发包之CopyOnWriteArrayList/" class="nav-link">
      <div>
        <div class="nav-label">下一篇</div>
        
        <div class="nav-title">并发包之 CopyOnWriteArrayList </div>
        
      </div>
      <i class="iconfont icon-right nav-next-icon"></i>
    </a>
  </div>
  
</div>

<div class="card card-content comment-card" style="margin-top: 16px;">
  <div class="comment-card-title">评论</div>
  
  <div id="vcomments"></div>
  
  <script>
    loadScript("https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js");
    var oldLoadVa = window.onload;
    window.onload = function () {
      oldLoadVa && oldLoadVa();
      new Valine({
        el: '#vcomments',
        appId: 'Ro9jzghVgwRgtnGQQ99MFbAK-9Nh9j0Va',
        appKey: 'rbA6uGwupFqEcTUAugUoXn2B',
        placeholder: '留下你的足迹吧~也可以加我微信 919201148，互换友链~~~',
        path: window.location.pathname,
        avatar: 'robohash',
        meta: ["nick","mail","link"],
        pageSize: '10',
        lang: '',
        visitor: 'true',
        highlight: true,
        recordIP: false,
        
        
        
        enableQQ: 'false',
        requiredFields: [],
      });
    };
  </script>

</div>

<div class="card card-content toc-card" id="mobiletoc">
  <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.1 语言特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.2 与 C++ 比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.3 main函数知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.4 Java程序初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.5 作用域与可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.6 构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.7 标识接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.8 clone 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.9 反射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.10 创建对象的四种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.11 package 作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.1 与面向过程区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.2 特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.3 这种开发方式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.4 继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.5 组合和继承区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.6 多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.7 覆盖和重载区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.8 抽象类与接口异同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.9 内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.10 如何获取父类类名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.11 this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.12 super</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3. 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.1 变量命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.2 assert</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.3 static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.4 switch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.5 volatile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.6 instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.7 strictfp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.8 null</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">4. 基本类型与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.1 基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.2 不可变类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.3 类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5. 字符串与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.1 字符串创建与存储机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.2 &#x3D;&#x3D;、equals和hashCode区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.3 String,StringBuffer,StringBuilder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.4 其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.1 finally 块执行时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.2 finally 代码块不是一定会被执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.3 Error</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.4 Exception</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">7. Java 平台与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.1 Java 平台与其他语言平台的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.2 JAVA 代码的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.3 java 源码编译机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.4 类加载机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.5 类执行机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.6 内存空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.7 内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.8 内存回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.9 内存泄露</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8. 分布式 Java 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.1 基于消息方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.2 基于远程调用方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.3 基于开源框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">9. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.1 线程资源同步机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.2 线程交互机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.3 线程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.4 sleep() 与 wait() 方法的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.5 守护线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.6 join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10. IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.1 流本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.2 流分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.3 装饰者模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.4 Java Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.5 NIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.6 序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.7 如何实现序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.8 序列化特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.9 反序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.10 外部序列化</span></a></li></ol></li></ol></li></ol></li></ol>
</div>

<!-- 百度自动推送链接-->
<script>
  (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
      }
      else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
  })();
  </script>
  </main>
          <aside class="left-column">
            
            <div class="card card-author">
              
<img src="/img/logo.jpg" class="author-img">

<p class="author-name">蜗牛 Java 之家</p>
<p class="author-description">Java 程序员的成长进阶社区</br>(Java for You)。</p>
<div class="author-message">
  <a class="author-posts-count" href="/archives">
    <span>107</span>
    <span>文章</span>
  </a>
  <a class="author-categories-count" href="/categories">
    <span>11</span>
    <span>分类</span>
  </a>
  <a class="author-tags-count" href="/tags">
    <span>118</span>
    <span>标签</span>
  </a>
</div>

<div class="author-card-society">
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/global/gh_woniu.png">
        <i class="iconfont icon-wechat society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="https://github.com/huayonglun/">
        <i class="iconfont icon-github society-icon"></i>
      </a>
    </div>
  
    <div class="author-card-society-icon">
      <a target="_blank" rel="noopener" href="http://weibo.com/huayonglun">
        <i class="iconfont icon-sina society-icon"></i>
      </a>
    </div>
  
</div>

            </div>
            
            <div class="sticky-tablet">
  
  
  <article class="display-when-two-columns spacer">
    <div class="card card-content toc-card">
      <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.1 语言特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.2 与 C++ 比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.3 main函数知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.4 Java程序初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.5 作用域与可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.6 构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.7 标识接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.8 clone 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.9 反射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.10 创建对象的四种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.11 package 作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.1 与面向过程区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.2 特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.3 这种开发方式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.4 继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.5 组合和继承区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.6 多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.7 覆盖和重载区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.8 抽象类与接口异同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.9 内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.10 如何获取父类类名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.11 this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.12 super</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3. 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.1 变量命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.2 assert</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.3 static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.4 switch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.5 volatile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.6 instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.7 strictfp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.8 null</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">4. 基本类型与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.1 基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.2 不可变类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.3 类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5. 字符串与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.1 字符串创建与存储机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.2 &#x3D;&#x3D;、equals和hashCode区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.3 String,StringBuffer,StringBuilder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.4 其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.1 finally 块执行时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.2 finally 代码块不是一定会被执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.3 Error</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.4 Exception</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">7. Java 平台与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.1 Java 平台与其他语言平台的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.2 JAVA 代码的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.3 java 源码编译机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.4 类加载机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.5 类执行机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.6 内存空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.7 内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.8 内存回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.9 内存泄露</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8. 分布式 Java 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.1 基于消息方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.2 基于远程调用方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.3 基于开源框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">9. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.1 线程资源同步机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.2 线程交互机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.3 线程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.4 sleep() 与 wait() 方法的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.5 守护线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.6 join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10. IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.1 流本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.2 流分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.3 装饰者模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.4 Java Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.5 NIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.6 序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.7 如何实现序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.8 序列化特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.9 反序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.10 外部序列化</span></a></li></ol></li></ol></li></ol></li></ol>
    </div>
  </article>
  
  
  <article class="card card-content categories-widget">
    <div class="categories-card">
  <div class="categories-header"><i class="iconfont icon-fenlei" style="padding-right: 2px;"></i>分类</div>
  <div class="categories-list">
    
      <a href="/categories/Java">
        <div class="categories-list-item">
          Java
          <span class="categories-list-item-badge">14</span>
        </div>
      </a>
    
      <a href="/categories/Java并发编程">
        <div class="categories-list-item">
          Java并发编程
          <span class="categories-list-item-badge">18</span>
        </div>
      </a>
    
      <a href="/categories/Linux">
        <div class="categories-list-item">
          Linux
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
      <a href="/categories/spring">
        <div class="categories-list-item">
          spring
          <span class="categories-list-item-badge">21</span>
        </div>
      </a>
    
      <a href="/categories/struts2">
        <div class="categories-list-item">
          struts2
          <span class="categories-list-item-badge">16</span>
        </div>
      </a>
    
      <a href="/categories/夯实基础系列">
        <div class="categories-list-item">
          夯实基础系列
          <span class="categories-list-item-badge">4</span>
        </div>
      </a>
    
      <a href="/categories/工具教程">
        <div class="categories-list-item">
          工具教程
          <span class="categories-list-item-badge">3</span>
        </div>
      </a>
    
      <a href="/categories/思维">
        <div class="categories-list-item">
          思维
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/数据库">
        <div class="categories-list-item">
          数据库
          <span class="categories-list-item-badge">2</span>
        </div>
      </a>
    
      <a href="/categories/算法">
        <div class="categories-list-item">
          算法
          <span class="categories-list-item-badge">25</span>
        </div>
      </a>
    
      <a href="/categories/网络">
        <div class="categories-list-item">
          网络
          <span class="categories-list-item-badge">1</span>
        </div>
      </a>
    
  </div>
</div>
  </article>
  
  <article class="card card-content tags-widget">
    <div class="tags-card">
  <div class="tags-header"><i class="iconfont icon-biaoqian" style="padding-right: 2px;"></i>热门标签</div>
  <div class="tags-list">
    
    <a href="\tags\Java" title="Java"><div class="tags-list-item">Java</div></a>
    
    <a href="\tags\ssh" title="ssh"><div class="tags-list-item">ssh</div></a>
    
    <a href="\tags\spring" title="spring"><div class="tags-list-item">spring</div></a>
    
    <a href="\tags\Java并发" title="Java并发"><div class="tags-list-item">Java并发</div></a>
    
    <a href="\tags\struts2" title="struts2"><div class="tags-list-item">struts2</div></a>
    
    <a href="\tags\bean" title="bean"><div class="tags-list-item">bean</div></a>
    
    <a href="\tags\树" title="树"><div class="tags-list-item">树</div></a>
    
    <a href="\tags\AOP" title="AOP"><div class="tags-list-item">AOP</div></a>
    
    <a href="\tags\分布式" title="分布式"><div class="tags-list-item">分布式</div></a>
    
    <a href="\tags\链表" title="链表"><div class="tags-list-item">链表</div></a>
    
    <a href="\tags\装配属性" title="装配属性"><div class="tags-list-item">装配属性</div></a>
    
    <a href="\tags\集合" title="集合"><div class="tags-list-item">集合</div></a>
    
    <a href="\tags\二叉树" title="二叉树"><div class="tags-list-item">二叉树</div></a>
    
    <a href="\tags\查找" title="查找"><div class="tags-list-item">查找</div></a>
    
    <a href="\tags\排序" title="排序"><div class="tags-list-item">排序</div></a>
    
    <a href="\tags\同步" title="同步"><div class="tags-list-item">同步</div></a>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
          <aside class="right-column">
            <div class="sticky-widescreen">

  <!-- 我的公众号 -->
  
  <article class="card card-content toc-card">
    <div style="float: left; ">
      <img class="adv" style="width: 100%; height: 100%; border: solid 1px #ddd;" src="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608142536200-image.png">
    </div>
    <div style="float: left; margin-left: 17px; margin-top: 12px;">
        <div style="font-size: 18px; margin-bottom: 12px;color:#159957;"><b>微信搜一搜: 蜗牛互联网</b></div>
        <small style="font-size: 0.9em;">
          👉「<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/OyboCy8Drh8AWNqE_DUROg">技术干货</a>」每周推送<br>
          👉「<a href="https://java4u.cn/resources/">免费资料</a>」随时领取<br>
          👉「<a target="_blank" rel="noopener" href="https://gitee.com/java4u/resources/raw/master/2020-12-17/1608143152021-image.png">优质社群</a>」随时加入<br>
        </small>
    </div>
    <div style="clear: both;"></div>
    <div style="font-size: 0.8em; margin: 15px 0 15px 0;">
      <a href="" target="_blank" style="color:#159957;font-size: 14px;" rel="noopener noreferrer">扫描上方二维码，关注我的公众号</a>
      <br>
    </div>
  </article>


  
  
  <article class="card card-content toc-card">
    <div class="toc-header"><i class="iconfont icon-menu" style="padding-right: 2px;"></i>目录</div>
<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">概要</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-text">细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">1. 基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.1 语言特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.2 与 C++ 比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.3 main函数知识</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.4 Java程序初始化顺序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.5 作用域与可见性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.6 构造函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.7 标识接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.8 clone 方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.9 反射</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.10 创建对象的四种方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">1.11 package 作用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">2. 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.1 与面向过程区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.2 特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.3 这种开发方式优点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.4 继承</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.5 组合和继承区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.6 多态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.7 覆盖和重载区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.8 抽象类与接口异同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.9 内部类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.10 如何获取父类类名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.11 this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">2.12 super</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">3. 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.1 变量命名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.2 assert</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.3 static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.4 switch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.5 volatile</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.6 instanceof</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.7 strictfp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">3.8 null</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">4. 基本类型与运算</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.1 基本数据类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.2 不可变类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">4.3 类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">5. 字符串与数组</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.1 字符串创建与存储机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.2 &#x3D;&#x3D;、equals和hashCode区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.3 String,StringBuffer,StringBuilder</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">5.4 其他</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">6. 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.1 finally 块执行时机</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.2 finally 代码块不是一定会被执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.3 Error</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">6.4 Exception</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">7. Java 平台与内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.1 Java 平台与其他语言平台的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.2 JAVA 代码的执行</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.3 java 源码编译机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.4 类加载机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.5 类执行机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.6 内存空间</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.7 内存分配</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.8 内存回收</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">7.9 内存泄露</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">8. 分布式 Java 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.1 基于消息方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.2 基于远程调用方式实现系统间的通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">8.3 基于开源框架</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">9. 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.1 线程资源同步机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.2 线程交互机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.3 线程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.4 sleep() 与 wait() 方法的区别</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.5 守护线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">9.6 join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-text">10. IO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.1 流本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.2 流分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.3 装饰者模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.4 Java Socket</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.5 NIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.6 序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.7 如何实现序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.8 序列化特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.9 反序列化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link"><span class="toc-text">10.10 外部序列化</span></a></li></ol></li></ol></li></ol></li></ol>
  </article>
  

  
  <article class="card card-content">
    <div class="recent-posts-card">
  <div class="recent-posts-header"><i class="iconfont icon-wenzhang_huaban" style="padding-right: 2px;"></i>最近文章</div>
  <div class="recent-posts-list">
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-15</div>
        <a href="/tools-course/工具教程/cai_yun_xiao_yi/"><div class="recent-posts-item-content">彩云小译：最佳的网页翻译插件</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-14</div>
        <a href="/tools-course/工具教程/markmap/"><div class="recent-posts-item-content">最佳的思维导图生成工具： markmap 使用教程</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2020-12-13</div>
        <a href="/tools-course/工具教程/hexo_site_course/"><div class="recent-posts-item-content">建站神器：Hexo+Kaze+Gitee Pages 搭建静态博客网站</div></a>
      </div>
    
      <div class="recent-posts-item">
        <div class="recent-posts-item-title">2019-01-24</div>
        <a href="/思维/思维/知识的诅咒：为什么你觉得显而易见，而对方却无法理解/"><div class="recent-posts-item-content">知识的诅咒：为什么你觉得显而易见，而对方却无法理解</div></a>
      </div>
    
  </div>
</div>
  </article>
  
  
</div>
          </aside>
        </div>
      </div>
    </div>
  </div>
  
  <footer class="footer">
  <div class="footer-container">
    <div>
      
      <!-- copyringt-->
      <div class="footer-dsc">
        <span>Copyright ©
          
          2020 -
          
          2020
        </span>
        &nbsp;
        <a href="/" class="footer-link">蜗牛 Java 之家 </a>
      </div>

       <!-- copyringt-->
       <div class="footer-dsc">
        <center><span>
        <a href="https://java4u.cn/resources/" target="_blank">Java 程序员最全资源下载</a> - <a href="https://java4u.cn/links/" target="_blank">友情链接</a>
        </span></center>
      </div>
     
    </div>

    
    
    
    
      <div class="footer-dsc">
        
        本站总访问量<span id="busuanzi_value_site_pv"></span>次
        
        
        <span>&nbsp;|&nbsp;</span>
        
        
        本站总访客数<span id="busuanzi_value_site_uv"></span>次
        
      </div>
      
    
</footer>
  <a role="button" id="scrollbutton" class="basebutton"  aria-label="回到顶部">
  <i class="iconfont icon-arrowleft button-icon"></i>
</a>
<a role="button" id="menubutton" class="basebutton">
  <i class="iconfont icon-menu button-icon"></i>
</a>
<a role="button" id="popbutton" class="basebutton" aria-label="控制中心">
  <i class="iconfont icon-expand button-icon"></i>
</a>
<a role="button" id="darkbutton" class="basebutton darkwidget" aria-label="夜色模式">
  <i class="iconfont icon-weather button-icon"></i>
</a>
<a role="button" id="searchbutton" class="basebutton searchwidget" aria-label="搜索">
  <i class="iconfont icon-search button-icon"></i>
</a>

  
  
  

  
  
  <script>
  var addImgLayout = function () {
    var img = document.querySelectorAll('.post-content img');
    var i;
    for (i = 0; i < img.length; i++) {
      var wrapper = document.createElement('a');
      wrapper.setAttribute('href', img[i].getAttribute('data-src'));
      wrapper.setAttribute('aria-label', 'illustration');
      wrapper.style.cssText = 'width: 100%; display: flex; justify-content: center;';
      if (img[i].alt) wrapper.dataset.caption = img[i].alt;
      wrapper.dataset.nolink = true;
      img[i].before(wrapper);
      wrapper.append(img[i]);
      var divWrap = document.createElement('div');
      divWrap.classList.add('gallery');
      wrapper.before(divWrap);
      divWrap.append(wrapper);
    }
    baguetteBox.run('.gallery');
  }
</script>
<script>loadScript("/js/lib/lightbox/baguetteBox.min.js", addImgLayout)</script>
  
  
  
<script src="/js/main.js"></script>

  
  <script>loadScript("/js/lib/busuanzi.min.js")</script>
  
  
  <script>
    var addLazyload = function () {
      var observer = lozad('.lozad', {
        load: function (el) {
          el.srcset = el.getAttribute('data-src');
        },
        loaded: function (el) {
          el.classList.add('loaded');
        }
      });
      observer.observe();
    }
  </script>
  <script>loadScript("/js/lib/lozad.min.js", addLazyload)</script>
  
  
</body>

</html>