[{"title":"彩云小译：最佳的网页翻译插件","url":"https://java4u.cn/tools-course/工具教程/cai_yun_xiao_yi/","content":"前言当你浏览一些国外网站的时候，看到英文会不会头大？\n英文不好的你可能就直接关闭页面了，当然也有朋友硬着头皮去翻译，不过大多数人的操作就是，复制一段内容，粘贴到翻译网站搞明白原文意思，然后再复制粘贴，如此循环往复，直到读懂页面内容。\n但这样操作一是 比较麻烦 ，二是 影响阅读体验 。\n那么有没有一个工具，能帮助我们加载网站页面的时候就能看到翻译后的内容，最好原内容也不要替换掉，这样遇到不通顺的地方也可以人肉校准。\n\n我今天看资料的时候，就发现了这么一款工具，非常简单好用，接下来就介绍下它。\n工具介绍这个神器是一个谷歌浏览器扩展插件，名字叫 彩云小译 。它能够通过双语对照的方式进行网页翻译，可以一键高效的让你获得母语级阅读体验。\n以下是这个插件截图和相关设置。\n\n可以看到，它像很多同类插件一样支持划词翻译，同时提供语音朗读。\n\n不过它的杀手锏是网页翻译。会识别英语和日语，手动或自动翻译成中文。喜欢自动翻译的话，设置里打个勾就行。翻译字幕默认显示也提供「双语对照」、「只显示原文」和「只显示译文」三种设置。你可以按需配置，我比较喜欢双语对照模式，如下图。\n\n工具使用有条件科学上网的朋友，可以直接在 chrome 网上应用商店搜索 彩云小译 ，添加至 chrome 即可使用。\n另外一部分朋友就需要下载插件源文件，打开谷歌浏览器的开发者模式，将源文件拖入该地址下：chrome://extensions/  ，安装即可使用。\n需要插件源文件的朋友，可以后台回复 chrome_plugin_cyxy 获取下载链接。\n这里也有官方发布的安装和使用的短视频。\n这款工具简单又好用吧，如果对你有用的话，可以给我点个赞，分享给身边朋友，非常感谢读者朋友，也欢迎关注我，我会分享更多优质原创内容。\n\n\n","categories":["工具教程"],"tags":["实用工具","教程","翻译","chrome 插件"]},{"title":"最佳的思维导图生成工具： markmap 使用教程","url":"https://java4u.cn/tools-course/工具教程/markmap/","content":"前言相信很多程序员朋友都有在用 Markdown 吧，我是大三找实习工作的时候接触到的，简历就是用 Markdown 写的。\nMarkdown 的好处是专注码字的同时还能兼顾排版，不用像 word 那样文本加个粗都需要移动下鼠标，体验非常好。\n它的缺点就是可视化能力很弱，这就降低了信息的传播效率，毕竟人对于图像化内容的接收程度要强于文本。\n可视化表达方面，思维导图就很不错。它作为一种图象化工具，通过层级式发散式地组织主题，帮助我们更好的记忆、学习和思考。\n但在过去，这两类工具是各自独立的，也就是你写完 Markdown 文本，想要可视化地传达一些重点给读者，就需要重新录入下思维导图，因此比较繁琐，这也是我不怎么用思维导图的原因。\n不过最近我发现一款很好用的工具，可以很好的解决上边的问题，在此分享给大家。以下是本文的重点内容对应的思维导图，就是用这款工具生成的。\n\n工具介绍这款工具叫 markmap。\nmarkmap 可以将 Markdown 语法的文本通过思维导图的方式进行可视化。以下是官网截图，markmap 这个名字来自 markdown 的前半部分 和 mindmap 的后半部分，slogan 是 Visualize your Markdown with mindmaps 。\n\n工具使用在线版如果你不想安装任何东西，那可以直接浏览器（建议 chrome 浏览器）上访问 https://markmap.js.org/repl 即可仿照官网模板进行转换，如下图。左边录入 Markdown 文本，右边会实时展示出思维导图。\n\nMarkdown 语法中的链接，加粗，删除线，斜体，单行代码，代码块，数学公式，转换成思维导图都有相应的视图效果。而且支持下载生成动态化的 html 文件以及 svg 文件。\n动态化效果如下图，可以折叠和打开。\n\n离线版如果你想拥有更好的使用体验，并且希望在断网的情况下也能够使用，那我推荐你下面这种方案。\n在 Visual Studio Code 上安装 markmap 插件，如下图。\n\n编辑 Markdown 文本，文件名以 .mm.md 结尾即可使用，并且可以点击右下角「export」按钮导出动态的 html 文件。\n\n这款工具简单又好用吧，如果对你有用的话，可以给我点个赞，分享给身边朋友，非常感谢读者朋友，也欢迎关注我，我会分享更多优质原创内容。\n\n\n","categories":["工具教程"],"tags":["实用工具","教程","思维导图","Markdown"]},{"title":"建站神器：Hexo+Kaze+Gitee Pages 搭建静态博客网站","url":"https://java4u.cn/tools-course/工具教程/hexo_site_course/","content":"前言建网站本身是一个很大的工程，涉及前端页面的搭建，网站数据的存储，还要购置服务器资源，甚至是后期的维护，过程相当繁琐。\n不过如果仅仅是想搭建个人的网站，写写博客，想要美观，又不想操心太多和写博客无关的事情。那么，Hexo + Kaze + Gitee Pages 的方式就很适合你。\n本文就讲下如何借助这三样免费的技术或服务，来搭建一个可访问的静态博客网站。\n\nHexo 简介Hexo 是什么？Hexo 是一个快速，简单且功能强大的博客框架。如果你用 Markdown 写博客，Hexo 可以在几秒内生成带有精美主题的静态文件。\nHexo 安装前置要求\nNode.js（版本 10.13 以上，建议使用 12.0 以上版本）\nGit\n\n安装 Git\nWindows：下载并安装 git。\nMac：使用 Homebrew 安装。\nLinux（Ubuntu，Debian）： sudo apt-get install git-core \nLinux（Fedora，Red Hat，CentOS）： sudo yum install git-core \n\n安装 Node.jsNode.js 为大多数平台提供了 官方安装程序。\n替代安装方法：\n\nWindows：使用 nvs 安装它。\nMac：使用 Homebrew 安装。\nLinux（基于DEB / RPM）：与 NodeSource 一起安装。\n其他：通过相应的软件包管理器进行安装。请参阅 Node.js 提供的指南。\n\n安装 Hexo用 npm 安装 Hexo。\nnpm install -g hexo-cli\n\n\n\n使用以下指令查看是否安装成功。\nhexo version\n\n\n\n如果你想卸载 Hexo，使用以下指令：\nnpm uninstall -g hexo-cli \n\n\n\n运行 hexo安装后，你可以通过 hexo &lt;command&gt; 运行 Hexo。比如通过 hexo help 指令来获取使用帮助。\nhexo help\n\n\n帮助里提到 hexo init 命令可以创建一个新的 Hexo 文件夹，这个文件夹其实就是利用 Hexo 生成的站点信息了。接下来讲下怎么建站。\nHexo 建站初始化操作使用  hexo init &lt;folder&gt; 指令就可以在指定文件夹下建立站点信息，我一般用域名做名称，如下：\nhexo init java4u.cn\n\n\n\n站点初始化中：\n\n站点初始化完成，会生成指定的文件夹：\n\n目录结构进入该站点，我们看下目录结构，如下：\n\n这些文件有着各自的职责：\n\n_config.landscape.yml：自定义的主题配置文件，此处的 landscape 是默认主题。配置其他主题可以参考这种方式。\n_config.yml：站点全局的配置文件。\nnode_modules：node 模块文件夹。包含可执行文件和依赖的资源。\npackage-lock.json：node_modules 文件中所有模块的版本信息，模块来源。\npackage.json：Hexo 框架的基本参数信息以及它所依赖的插件。\nscaffolds：scaffolds 原意是脚手架，这里可以理解为模板文件夹。当你创建新的文章时，Hexo 会根据该文件夹下的对应文件进行初始化构建。\nsource：资源文件夹。这里是你放自己资源比如博文和图片的地方。 _posts 文件夹下的 Markdown 和 HTML 文件会被解析并放到 public 文件夹下。其他文件或文件夹，如果开头命名不是 _ (下划线)，也都会被拷贝过去。\nthemes：主题文件夹。Hexo 会根据主题来生成静态页面。\n\n基于这样的结构，Hexo 就具备了生成静态网站的能力。\n本地启动我们先本地启动，看下实际效果。输入以下命令：\nhexo server\n\n\n\n\n\nHexo 会启动服务，将默认生成的网站运行在本机的 4000 端口上，可以直接访问 http://localhost:4000 就能看到网站首页，它基于默认主题生成，同时有一篇默认文章。\n\n这个页面只是官方提供的一个样例，看到它就意味着你本地环境跑通了。我们可以通过修改配置的方式，对页面相关元素做调整。\n核心配置以下是我们需要了解或者修改的配置信息。\npackage.json这个文件列出了 Hexo 的基本参数信息以及它所依赖的插件。可以看到，EJS，Stylus 和 Markdown 渲染器都是默认安装的。\n&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;hexo generate&quot;,    &quot;clean&quot;: &quot;hexo clean&quot;,    &quot;deploy&quot;: &quot;hexo deploy&quot;,    &quot;server&quot;: &quot;hexo server&quot;  &#125;,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^5.0.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,    &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^2.0.0&quot;,    &quot;hexo-server&quot;: &quot;^2.0.0&quot;,    &quot;hexo-theme-landscape&quot;: &quot;^0.0.3&quot;  &#125;&#125;\n\n\n\n\n如果后边要切换主题，记得把最后一个默认的主题依赖删除掉。\n\n_config.yml可设置网站、网址、目录、文章、分类&amp;标签、日期/时间格式、分页和扩展等信息。\n网站\n\n\n\n参数\n描述\n\n\n\ntitle\n网站标题\n\n\nsubtitle\n网站副标题\n\n\ndescription\n网站描述，用于 SEO\n\n\nkeywords\n网站的关键词，支持多个关键词。\n\n\nauthor\n文章作者。\n\n\nlanguage\n网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 zh-Hans和 zh-CN。\n\n\ntimezone\n网站时区。Hexo 默认使用您电脑的时区。请参考 时区列表 进行设置，如 America/New_York, Japan, 和 UTC 。一般的，对于中国大陆地区可以使用 Asia/Shanghai。\n\n\nURL\n\n\n\n参数\n描述\n默认值\n\n\n\nurl\n网址, must starts with http:// or https://\nhttp://example.com\n\n\nroot\n网站根目录，如果放子目录，设置 /blog/ \n/\n\n\npermalink\n文章的 永久链接 格式\n:year/:month/:day/:title/\n\n\npermalink_defaults\n永久链接中各部分的默认值\n\n\n\npretty_urls\n改写 permalink 的值来美化 URL\n\n\n\npretty_urls.trailing_index\n是否在永久链接中保留尾部的 index.html，设置为 false 时去除\ntrue\n\n\npretty_urls.trailing_html\n是否在永久链接中保留尾部的 .html, 设置为 false 时去除 (对尾部的 index.html无效)\ntrue\n\n\n目录\n\n\n\n参数\n描述\n默认值\n\n\n\nsource_dir\n资源文件夹，这个文件夹用来存放内容。\nsource\n\n\npublic_dir\n公共文件夹，这个文件夹用于存放生成的站点文件。\npublic\n\n\ntag_dir\n标签文件夹\ntags\n\n\narchive_dir\n归档文件夹\narchives\n\n\ncategory_dir\n分类文件夹\ncategories\n\n\ncode_dir\nInclude code 文件夹，source_dir 下的子目录\ndownloads/code\n\n\ni18n_dir\n国际化（i18n）文件夹\n:lang\n\n\nskip_render\n跳过指定文件的渲染。匹配到的文件将会被不做改动地复制到 public 目录中。\n\n\n\n文章\n\n\n\n参数\n描述\n默认值\n\n\n\nnew_post_name\n新文章的文件名称\n:title.md\n\n\ndefault_layout\n预设布局\npost\n\n\nauto_spacing\n在中文和英文之间加入空格\nfalse\n\n\ntitlecase\n把标题转换为 title case\nfalse\n\n\nexternal_link\n在新标签中打开链接\ntrue\n\n\nexternal_link.enable\n在新标签中打开链接\ntrue\n\n\nexternal_link.field\n对整个网站（site）生效或仅对文章（post）生效\nsite\n\n\nexternal_link.exclude\n需要排除的域名。主域名和子域名如 www 需分别配置\n[]\n\n\nfilename_case\n把文件名称转换为 (1) 小写或 (2) 大写\n0\n\n\nrender_drafts\n显示草稿\nfalse\n\n\npost_asset_folder\n启动 Asset 文件夹\nfalse\n\n\nrelative_link\n把链接改为与根目录的相对地址，建议使用绝对地址。\nfalse\n\n\nfuture\n显示未来的文章\ntrue\n\n\nhighlight\n代码块的设置, see Highlight.js section for usage guide\n\n\n\nprismjs\n代码块的设置, see PrismJS section for usage guide\n\n\n\n分类 &amp; 标签\n\n\n\n参数\n描述\n默认值\n\n\n\ndefault_category\n默认分类\nuncategorized\n\n\ncategory_map\n分类别名\n\n\n\ntag_map\n标签别名\n\n\n\n日期/时间格式\nHexo 使用 Moment.js 来解析和显示时间。\n\n\n\n参数\n描述\n默认值\n\n\n\ndate_format\n日期格式\nYYYY-MM-DD\n\n\ntime_format\n时间格式\nHH:mm:ss\n\n\nupdated_option\n当 Front Matter 中没有指定 updated 时 updated 的取值，支持 mtime(文件最后修改时间)，date(使用 date 的值)，empty(不指定)\nmtime\n\n\n分页\n\n\n\n参数\n描述\n默认值\n\n\n\nper_page\n每页显示的文章量 (0 = 关闭分页功能)\n10\n\n\npagination_dir\n分页目录\npage\n\n\n扩展\n【主题】\n\n\n\n参数\n描述\n默认值\n\n\n\ntheme\n当前主题名称。值为false时禁用主题\nlandscape\n\n\ntheme_config\n主题的配置文件。在这里放置的配置会覆盖主题目录下的 _config.yml 中的配置\n无初始配置\n\n\ndeploy\n部署部分的设置\n\n\n\nmeta_generator\nMeta generator 标签。 值为 false 时 Hexo 不会在头部插入该标签\ntrue\n\n\n【部署】\n配置如下：\ndeploy:  type: git  repo: &lt;repository url&gt; #https:&#x2F;&#x2F;bitbucket.org&#x2F;JohnSmith&#x2F;johnsmith.bitbucket.io  branch: [branch]  message: [message]\n\n\n\n\n\n\n参数\n描述\n默认\n\n\n\nrepo\n库（Repository）地址\n\n\n\nbranch\n分支名称\ngh-pages (GitHub) coding-pages (Coding.net) master (others)\n\n\nmessage\n自定义提交信息\nSite updated: &#123;&#123; now('YYYY-MM-DD HH:mm:ss') &#125;&#125;)\n\n\ntoken\nOptional token value to authenticate with the repo. Prefix with $ to read token from environment variable\n\n\n\n常用指令创建文章使用以下指令：\nhexo new &quot;test&quot;\n\n\n\n或者简写：\nhexo n &quot;test&quot;\n\n\n\n运行服务器输入以下命令以启动服务器，您的网站会在 http://localhost:4000 下启动。在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。\nhexo server\n\n\n\n或者简写：\nhexo s\n\n\n\n生成静态文件hexo generate\n\n\n\n或者简写\nhexo g\n\n\n\n监视文件变动立即重新生成。该操作会阻塞命令。\nhexo g --watch\n\n\n\n生成完毕后自动部署网站。\nhexo generate --deploy\n\n\n\n部署Hexo 提供了快速方便的一键部署功能，让你只需一条命令就能将网站部署到服务器上。\nhexo deploy\n\n\n\n或者简写为：\nhexo d\n\nHexo 主题为什么选择 KazeHexo 默认主题为 landscape，但我觉得不够美观，这里推荐 kaze ,它有以下特性：\n\n响应式设计，适配桌面端、平板、手机等各种设备\n\n前端性能优化，加载快速，眨眼之间即可加载完成\n\n图片懒加载，应用懒加载技术加快页面的生成速度\n资源压缩，提升本地资源请求速度\n精简设计，不包含 Jquery 等额外库\n\n\n支持侧边栏小组件，例如最近文章，作者卡片\n\n暗黑模式，享受黑夜的魅力\n\n代码高亮，支持 prismjs\n\n公式渲染，支持 katex 和 mathjax\n\n评论系统，集成 valine、gitalk 和 livere\n\n访问量统计和谷歌分析支持\n\n\n安装 Kaze在 your site/themes 下输入\ncd themesgit clone https:&#x2F;&#x2F;github.com&#x2F;theme-kaze&#x2F;hexo-theme-Kaze.git\n\n\n\n安装成功后，会生出目录：hexo-theme-Kaze。\n修改站点配置文件 _config.yml 下的主题值为：hexo-theme-Kaze。\n\n用 hexo server 启动 Hexo 服务看下效果。\n\n会看到已经生成了默认的主题，只是很多东西都没有，需要改造一下。\n主题配置可在该主题目录下的 _config.yml 文件里配置。\n主题颜色在 color 中进行配置，以下是默认值。\ncolor:  text-color: &quot;#3c4858&quot;  text-strong-color: &quot;#2f3d4e&quot;  text-light-color: &quot;#909faf&quot;  divider-color: &quot;#e6e8ee&quot;  title-color: &quot;#475b6d&quot;  link-color: &quot;#3273dc&quot;  link-hover-color: &quot;#6596e5&quot;  info-text-color: &quot;#909faf&quot;  widget-background-color: &quot;#fff&quot;  body-background-color: &quot;#f2f5f8&quot;  border-color: &quot;#e1e4e9&quot;  pre-color: &quot;#2d2d2d&quot;  code-color: &quot;#50687c&quot;  code-background-color: &quot;#e9eaf0&quot;\n\n\n\n\n\n字号与字体在 font 中进行配置，以下是默认值。\nfont:  font-size: 16px # global font-size  font-family: &#39;-apple-system,BlinkMacSystemFont,&quot;Segoe UI&quot;,&quot;Helvetica Neue&quot;,&quot;PingFang SC&quot;,&quot;Microsoft YaHei&quot;,sans-serif&#39; # global font-family\n\n站点访问量统计访问量统计目前仅支持不蒜子，默认关闭，可统计站点总访问量和总访客数。\nfooter:  #------------------------  # pv &#x2F; uv statistics config  #------------------------  statistics:    enable: false    type: busuanzi # now version only supports busuanzi    pv:      enable: true      style: 本站总访问量&#123;&#125;次 # the style will be shown as $1&#123;pv&#125;$2    uv:      enable: true      style: 本站总访客数&#123;&#125;次 # the style will be shown as $1&#123;uv&#125;$2\n\n\n\n数据分析analytics:  enable: false  type: google # google  google:    id:\n\nenable 开启分析支持（默认关闭）\ntype&#96; 目前仅支持 &#96;google\n\ngoogle.id 有关谷歌分析的具体使用说明和 id 使用可以参考谷歌文档\n首页文章头图在文章 Front-matter 中 banner_img 可以设置首页头图\n小组件widgets:  showWidgetsMobiles: &quot;none&quot;\n\nshowWidgetsMobiles : 在窄屏幕上是否显示小组件，none 关闭（默认），flex 开启\n关于关于页面需要自行创建，在站点 source 中新建 about 文件夹并在文件夹内创建 index.md，该文件至少需要包含\n# at $&#123;yoursite&#125;&#x2F;about&#x2F;index.md---title: 关于layout: about---\n\n社交链接在 about 下的 social_links中进行配置，主题图标依赖于 iconfont，内置了一部分社交图标，你可以自定义其他icon文件或者解决方案来添加自定义图标。\nabout:  description: description  social_links:    - &#123; icon: icon-github, link:  https:&#x2F;&#x2F;xxx&#125;    # - &#123; icon: icon, link: your link &#125;\n\n\n友链友链格式按如下填写即可生成友链页面\nlinks:  example-name-1:     url: https:&#x2F;&#x2F;example.com    avatar: https:&#x2F;&#x2F;example.com&#x2F;avatar.jpg  example-name-2:     url: https:&#x2F;&#x2F;example.com    avatar: https:&#x2F;&#x2F;example.com&#x2F;avatar.jpg\n\n文章页搜索功能search:  enable: true  path: search.json  field: posts  searchContent: true\n\n\nenable 开启搜索功能（默认开启）\npath 文件名称（暂无用处）\nfield 需要搜索的范围，支持 posts | pages | all\nsearchContent 搜索文件是否包含正文内容（不建议开启，包含所有文章内容这样会使得搜索文件异常巨大）替代方案是搜索分类标签或使用algolia等第三方搜索服务（Todo）\n\n目录主题目录通过Hexo原生函数生成，具体可参见 文档\ntoc:  showListNumber: false  maxDepth: 6  minDepth: 1\n\nshowListNumber 是否生成编号\nmaxDepth TOC最大深度\nminDepth TOC最小深度\n代码高亮参见代码 高亮文档\n数学公式主题支持 mathjax 和 katex 两种渲染引擎，具体参见 相关文档\ncopyrightcopyright:  enable: true  writer: # if writer is empty we will use config.author as writer  declare: 本博客所有文章除特别声明外，均采用&lt;a target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot; href&#x3D;&quot;https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;deed.zh&quot;&gt;CC BY-NC-SA 4.0 协议&lt;&#x2F;a&gt;。转载请注明出处！  style: warning\n\nenable 开起版权说明（默认开启）\nwriter&#96; 作者id，如果不填则会使用主题配置&#96;author&#96;或站点配置&#96;author\n\ndeclare 版权声明具体内容，支持 html 语句\nstyle 声明内容样式，与 note 样式相同\n版权内容有三部分：作者、文章链接、版权声明\n作者使用 writer 参数，文章链接基于站点配置文件中url参数生成，版权声明使用 declare 参数\nFront-matterbanner_img设置文章与首页头图\nbanner_img_set在图片加载时预先加载的图片，可以设置为 loading 图或缩略图等\nexcerpt为文章设置在首页显示的简介，还可以通过 &lt;!--more--&gt; 来控制显示\n评论支持 valine，gitalk 和 livere\n具体设置可参考主题配置文档说明和相关评论插件文档\n字数统计主题集成 hexo-wordcount 插件，在主题配置文件中设置\nwordcount:  enable: true\n\n开启（默认开启）\n图片画廊图片画廊功能基于 fslightbox，在主题配置文件中设置\nfslightbox:  enable: true\n\n开启（默认开启）\n标签插件主题集成了一些标签方便书写\nnote在 markdown 文件中如下书写即可\n&#123;% note style %&#125;...markdown content&#123;% endnote %&#125;\n\n有五种样式可以选择，primary，success，info，warning，danger\n\n备案信息您可以在主题配置文件内增加您的备案信息。\nfooter:  #------------------------  # 备案配置  # 请将公安备案的缩略图置于 $&#123;yoursite&#125;&#x2F;img&#x2F;beian.png  RecordInfo: &quot;&quot; # &#39;某ICP备xxx号&#39;  govRecordInfo: &quot;&quot; # &#39;某公网安备xxx号&#39;  govRecordUrl: &quot;&quot; # 公网安备案信息地址  #------------------------\n\n\n\n站点托管为什么选择 Gitee PagesGitHub 和 Gitee 都提供免费的静态网页托管服务。我们可以使用 GitHub Pages 或 Gitee Pages 托管博客、项目官网等静态网页，这样就省去了购买服务器的钱，也不需要耗费太多精力维护。\nGitHub Pages 使用很广泛，我之前也用过，不过访问不够稳定，会影响页面加载速度。Gitee 是国内版的 GitHub，访问速度优秀，并且国内发展势头不错，因此我选取 Gitee Pages 来托管我的网站。\n建立仓库申请一个 Gitee 账号，创建一个新的仓库，仓库名尽量和账号名一致，这样可以避免一些因为路径引发的问题。\n\n然后在仓库首页服务一栏开启 Gitee Pages 服务。\n\n开启后，你就拥有了专属的二级域名网址。\n注意：仓库内容有变化，需要手动触发更新，页面才能真正生效。\n连接仓库\n安装 hexo-deployer-git。\n\nnpm install hexo-deployer-git --save\n\n\n\n\n\n修改配置。\n\ndeploy:  type: git  repo: git@gitee.com:java4u&#x2F;java4u.git\n\n注意上面的 repo 地址并不是仓库的地址，而是你下载/克隆项目时弹出的那个地址，type 如果是 git 就选择 SSH。\n\n\n生成/添加 SSH 公钥\n\nGitee 、GitHub 提供了基于 SSH 协议的 Git 服务，在使用 SSH 协议访问仓库仓库之前，需要先配置好账户/仓库的 SSH 公钥。\n先看下自己有没有配置过用户名和邮箱：\ngit config --global user.name git config --global user.email\n\n\n如果没有就做下配置：\n# 设置邮箱git config --global user.email *********@qq.com # 设置用户名git config --global user.name &#39;****&#39;\n\n然后本地生成 SSH 公钥，邮箱为刚配置好的账户：\nssh-keygen -t rsa -C yong__1994@163.com\n\n生成后可查看 SSH 公钥：\ncat ~&#x2F;.ssh&#x2F;id_rsa.pub\n\n复制公钥去 Gitee 粘贴，添加。\n\n测试是否连接成功：\nssh -T git@gitee.com\n\n\n上传仓库执行部署命令，即可将本地资源上传远程仓库。\nhexo d\n\n\n\n手动更新远程仓库虽然可以看到提交记录，但静态网站不会感知到实时变更，需要去 Gitee Pages 服务页面做下更新。\n\n稍等片刻，访问 https://java4u.gitee.io/ 即可看到 Hexo 结合 kaze 主题搭建的静态网站。\n\n\n\n","categories":["工具教程"],"tags":["实用工具","教程","建站"]},{"title":"知识的诅咒：为什么你觉得显而易见，而对方却无法理解","url":"https://java4u.cn/思维/思维/知识的诅咒：为什么你觉得显而易见，而对方却无法理解/","content":"01\n你知道「知识的诅咒」吗？\n如果你是位老师，在给学生讲课的时候，是否有过这种感受，你觉得显而易见的知识，怎么他们始终学不会？有些同学怎么又笨又不开窍，而你又气馁又急躁？\n如果你是位架构师，在做技术分享的时候，总是不经意的提到「负载均衡」「分布式部署」「水平扩容」这些名词，你觉得大家都懂，却发现底下刚来的实习生一脸懵逼。\n\n\n如果你是位写作者，针对某个事件发表了观点，你认为自己已经写的很明白了，但评论里依然有人在问你认为已经强调过的信息。\n如果你是刚刚拥有了一项知识的普通人，你想把这个有用的知识传授给朋友，朋友却对你夸夸其谈的东西不知所云。\n你可能对这种场景感到郁闷，为什么显而易见的东西，对方就那么难以理解？\n你要是找不到答案的话，或许是因为不知道「知识的诅咒」这个概念。\n所谓「知识的诅咒」就是，当你学习到某个知识之后，就无法想象自己不知道它，它就像诅咒一样，让你很难再从不具备这项知识的角度考虑问题。\n这里的知识可以是信息、消息、概念、规律、常识、观念、认知和技能等等。\n简单来讲就是，你认为简单的东西，在对方看来却很难。\n比如驾校学车，教练手把手教了好几遍，我们还是会蹑手蹑脚总是出错。教练经常埋怨自己教的是笨蛋，这么简单的东西都学不好。事实上，教练掌握了技巧才觉得简单，学员太过生疏就觉得很难。\n比如听前奏猜歌名游戏。我大学听周杰伦的歌比较多，为了给室友证明对这些歌的熟悉程度，主动提议让室友放杰伦歌的前奏，我来猜歌名。结果当然是全部猜中，并且室友惊叹于我的响应速度。然而如果反过来，我来放前奏室友来猜，即便放了一首我自认为很常见的歌，却不能被猜中。\n想起程序员相亲的一个段子。程序员介绍自己说：我是做「底层架构」的。女生一听到「底层」两个字，就一脸不屑地说：「底层啊，啥时候升到中高层啊？」男生一脸懵逼，不知该如何接话。程序员的尴尬在于他所描述的「底层」在程序员的圈子里已经是稀松平常的称呼，象征了高水平高层级， 但对外界来说却是他们自己的理解。\n02\n为什么会有「知识的诅咒」？\n为什么会存在「知识的诅咒」呢？\n因为我们和对方存在认知偏差。\n每个人成长经历不同，接触的环境信息不同，塑造的性格观念不同，对事物的感知和对事情的判断，会自然而然的跟随着自己的经验。\n当我们抛出一项知识的时候，对方会习惯性的从 TA 的角度出发进行理解，而我们却不知不觉地认为对方有背景知识。正如世界上没有两片完全相同的树叶，地球上不存在两个思想近乎一致的人。\n所以我们常常误以为自己明确表达了内容，可是对方根本没有接收到，即便被理解，理解的程度也有很大差异，形成一种自我透明错觉，产生表达和接收上的误会。\n正是每个人知识的局限性，也决定了：任何知识的传播都会遇到诅咒。\n03\n如何打破「知识的诅咒」？\n既然「知识的诅咒」这么容易发生，那么怎么减轻它的副作用甚至打破诅咒，让我们和他人的交流更顺畅呢？\n\n首先要认清一个事实，自己的常识不是别人的常识。\n\n只有意识到我们习以为常的东西，别人可能不会懂，才会促使我们去考虑放下固有的表达方式，寻求有利于双方理解的沟通办法。\n\n其次是找到属于自己的柚子基模。\n\n「基模」这个词或许你不懂，现在是我遭受「知识的诅咒」的时候了，不过还是尽我所能解释一下。\n如果你不知道西柚是什么东西？现在有两种介绍。\n一种是『西柚是柑橘科属的亚热带水果，簇生成串，皮薄软，果肉分瓣，颜色淡黄色到珊瑚红，多汁到微干，从香甜可口到酸味扑鼻』。\n另外一种是「西柚是一种小型的柚子，形似葡萄，皮如柑橘薄且软。」\n哪一种描述你更能接受？当然是后一种，因为柚子，葡萄，柑橘你很熟悉，知道它们的颜色、大小、气味和口感，通过这些习以为常的东西感受新的概念就变得很容易。这儿的柚子，葡萄，柑橘就可以认为是「基模」。\n我们再换个角度来理解「基模」，如果你是程序员，你可以认为它是数据库索引，能够帮你快速锁定记录；如果你经常读书，你可以认为它是一本书的目录，可以让你了解主题和概要。\n「基模」就是这种大家所熟知的东西，本身是很简单的材料，却能组建复杂的信息，利用它就可以让人的思维产生关联，唤起认知。\n比如，经济学本身晦涩难懂，但薛兆丰老师的经济学课会提出很多精炼简约的案例，来教授像我这种没有任何经济学基模的学生。生动形象的案例很容易听明白，便自然而然的对经济学知识产生初步认识。\n\n第三点是要唤起对方脑中已有的记忆，运用对方已知的现成知识。\n\n人们总想精确无比的表达一切。但实际上应该，先告诉对方够用的信息，然后再一点一点慢慢增多。\n一次性告诉大量对方不知道的信息等同于没说。我们的沟通应该是你来我往，循序渐进的过程。\n\n最后一点是要扩充知识领域，多维度思考。\n\n俗话说，隔行如隔山。在一个行业里呆的久了，凡事会不可避免的从所处行业的角度上考虑问题，形成单点思维，不可避免产生局限，又对其他行业信息缺乏敏感度。\n当其他行业出现红利时，就无法嗅到机会。即便看到了机会，其他人也都看到了，此时已经不是机会了。\n所以要越过山丘，多看看山那头，能帮助我们多一种维度的思考。\n越早开始越有优势，因为时间积累带来的知识壁垒是难以逾越的。\n当我们知识体系足够丰富，思维变得灵活，遭受「知识的诅咒」的时刻自然会大大减少。\n\n---\n\n\n","categories":["思维"],"tags":["知识","思维","优秀"]},{"title":"并发下锁的同步","url":"https://java4u.cn/Java并发编程/Java并发编程/并发下锁的同步/","content":"前言“锁”在我们日常的生活工作中经常会用到，比如离开寝室会锁房门，不用手机会将屏幕锁定，这充分保证了个人财产安全和隐私安全。同样，在程序的世界里，也有一把锁，保证程序不会崩溃，保证我们手机钱包里的钱不会无缘无故变多变少。\n锁（lock）作为用于保护临界区（critical section）的一种机制，被广泛应用在多线程程序中。比如 Java 应用程序出现的 synchronized 关键字，就是锁实现的一种方式。下面我们从一个计数器的应用说起，分析下锁在 Java 程序中的应用。\n\n\n一个计数器\n非线程安全，value++ 不是原子性操作，状态不稳定，需要同步。\n同步方法锁定实例\n线程安全，锁的对象是当前 SafeCounter 的实例，不会影响到另一个 SafeCounter 实例的 getNext() 方法。\n锁定类\n线程安全，锁的对象是 SafeCounterWithClass 类，任何实例都会受锁的影响，一般不这么用。\nlock\n线程安全，锁的对象是 lock，可以灵活控制，只锁真正需要同步的代码。注意 lock 不能是 null，也不能改变。\n更好的 lock\n线程安全，灵活控制锁竞争时的处理，拥有更好的性能。\natomic\n最佳实践：使用原子操作类，不阻塞，获得最好的性能。\n首发于公众号：永伦的小屋。\n原文链接：遇到并发，上锁是个好习惯\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","同步","锁"]},{"title":"闭环思维，让你更加优秀的诀窍","url":"https://java4u.cn/思维/思维/闭环思维，让你更加优秀的诀窍/","content":"前言相信很多同学都有过这种经历，使用电脑时，辛辛苦苦写了很长的文档，也没有及时保存文件，突然一下死机或者断电，全部心血都付诸东流，一脸懵逼地看着没有任何动静的电脑屏幕，止不住的唉声叹气。\n于是这些同学痛定思痛，决定将保存的动作牢记于心。日后的码字过程中，总是按照 码字-保存-码字-保存 的流程进行，慢慢地在脑海里形成了一种条件反射，再也不用担心字白码了，事情白干了。\n而这种码字保存再码字再保存的循环机制，其实是闭环思维的一种体现。正是脑海中形成的这个闭环，我们的工作效果才能在这一次次的实践中得到保障和提升。\n\n\n\n\n闭环思维那么什么是闭环思维呢？\n别人发起一件事，在一定时间内，不管我们完成的效果如何，都要认真的反馈给发起人，这就叫闭环思维。\nPDCA“闭环”的理论根据是由美国质量管理专家休哈特博士提出“PDCA循环”。\n“PDCA 循环”将质量管理分为四个阶段：\nP(Plan)计划：目标的确定和计划的制定。\nD(Do)执行：具体运作，实现计划中的内容。\nC(Check)检查：总结对错，明确效果，找出问题。\nA(Act)处理：对检查结果进行处理，成功经验加以肯定并推广，失败教训引起重视并避免。未解决的问题，提交下一个 PDCA 循环。\n这四个过程不是一次性结束，而是周而复始地进行。\n\n当一个循环完结，解决一些问题，未解决的问题就进入下一个循环，如此阶梯式上升，直到任务完结。\n\n职场闭环职场上的闭环，决定了一个人是否靠谱。\n我第一次负责的项目，排期比较紧，高层也比较关注，压力是有的。自己投入了很多的精力去制定方案和计划，小步实施的过程中也是发现了一些不合理，有些问题自己没办法搞定，就会反馈给老大并和他沟通解决方案，老大也是给出了很好的建议。\n及时反馈并拿到结果使我在遇到问题的时候能够顺利推进项目节奏，心理上也不再焦虑，信心增加不少，工作一次一次检查，问题一个一个解决，项目进度也会告知给相关方。最后项目顺利上线。\n试想，遇到问题如果只是闷头苦干，不与相关人反馈沟通，就算有了结果，或许不是老大心中的最佳方案，效果肯定会大打折扣，而且等老大问的时候再去说，就很被动了。正向闭环的反馈机制不仅能让人心态更加积极办事更加顺畅，也能让整个人的状态进入良性循环。\n反馈不好也有过一次经历。业务方发邮件期望我们团队可以帮忙订正数据，我承接了这个活，并且很快做完了，最后邮件回复了业务方。直到晚上老大问我订正做了没，我才发现原来我回复邮件的时候忘记抄送老大了，老大还以为我没做呢。于是我回复了老大，重新发送了邮件，并且进一步钉钉告知了业务方。\n这件事给我的教训就是，重要信息反馈时，一定要检查下哪些人是相关方，不要漏掉。闭环思维强调的不仅仅是责任心，更强调团队配合和人际敏感性，完成事情本身的同时，心里要装着与此相关的人。\n生活闭环生活中的闭环，能看出一个人的为人处世方式。\n就拿借钱这件事来说。\n有人话不多说一句，拿钱走人。有人还会多说一句，等我有钱了就还你。结果是等到猴年马月也没一点音讯，没钱么？看小日子过的挺滋润，各种吃喝玩乐。忘了么？大概是真忘了或者假忘了。\n还有一种人，知道你愿意借了，立马会告诉你什么时候会还。就算还钱期间遇到了新的困难，要么会提前告诉你可能要延期了，要么挤也会挤出来按期换掉。反正给你的感觉就是，这钱没不了。\n我爸妈就遇到了那些记性不好的人，而我遇到的朋友基本都是靠谱的，所以我对我的这些朋友都很信任，把事情给他们不用操心后续，都能看到进度条，就算没得到好的结果，也可以及时收到反馈。\n我一直认为对一个人比较好的评价，就是靠谱。做事有始有终，而不是虎头蛇尾。答应别人事情时慎重，不轻易许诺。做一件事不管有没有办成，也会给到别人一个回复。\n怎样成为一个靠谱的人呢？那就是通过一件件事情有意识的培养自己的闭环思维，这种思维习惯会让你的能力你的价值在无形中得到螺旋式的上升，你会变得更加优秀，你会觉得自己进入了一个新的层次，你抗拒负面行为的能力也越来越强，你每一天都在成长。\n首发于微信公众号：永伦的小屋。欢迎关注~\n原文链接：闭环思维，让你更加优秀的诀窍\n\n---\n\n\n","categories":["思维"],"tags":["思维","优秀","高效","闭环"]},{"title":"夯实基础系列四：Linux 知识总结","url":"https://java4u.cn/tamp-basic-series/夯实基础系列/tamp_basic_series_4/","content":"前言现在很多公司项目部署都使用的是 Linux 服务器，互联网公司更是如此。对于大一些的互联网公司，系统可能会非常复杂，本地无法启动，一般都会采用专门的开发机给开发人员开发测试使用。我实习期间接触的项目没一个可以在本地启动的，都需要写好代码，把代码更新到开发机上，然后编译部署，并查看部署过程中是否有错误或是查看访问这台机器的日志。而这些操作，都需要对基本的 Linux 命令熟悉。\n今天总结下 Linux 的相关概念和基本操作，如果想了解更多，可以去看看《鸟哥的私房菜》。同时希望大家多动手实践，这样理解得更深刻。\n\n\n概要Linux 知识总结以下部分内容：Linux 常见概念、Linux 常用命令、vi 操作和一个最简单的 shell 脚本。\n细节1. Linux 常见概念1.1 Linux 与 Windows 的不同\nLinux 严格区分大小写\nLinux 中所有内容以文件形式保存，包括硬件。一切内容皆文件。\nLinux 不靠扩展名区分文件类型，靠权限区分文件类型。带后缀的文件名是约定俗成，方便管理\nWindows下的程序不能在Linux中安装和运行\n\n1.2 Linux 采用字符界面有什么优势\n字符界面占用的系统资源更少\n字符界面减少了出错、被攻击的可能性\n\n1.3 分区类型\n主分区：最多只能有 4 个。\n扩展分区\n最多只能有 1 个\n主分区加扩展分区最多有 4 个\n不能写入数据，只能包含逻辑分区\n\n\n逻辑分区\n\n1.4 挂载\n必须分区\n/ (根分区)\nswap 分区（交换分区，内存 2 倍，不超过 2GB）\n\n\n推荐分区\n/boot（启动分区，200 MB）\n\n\n\n1.5 常见目录的作用\n/ 根目录\n/bin 命令保存目录(普通用户就可以读取的命令)\n/boot 启动目录，启动相关文件\n/dev 设备文件保存目录\n/etc 配置文件保存目录\n/home 普通用户的家目录\n/lib 系统库保存目录\n/mnt 系统挂载目录\n/media 挂载目录\n/root 超级用户的家目录\n/tmp 临时目录\n/sbin 命令保存目录(超级用户才能使用的目录)\n/proc 直接写入内存的\n/sys\n/usr 系统软件资源目录\n/usr/bin/ 系统命令(普通用户)\n/usr/sbin/ 系统命令(超级用户)\n\n\n/var 系统相关文档内容\n\n\n根目录下的 bin 和 sbin，usr 目录下的bin 和 sbin,这四个目录都是用来保存系统命令的。\n\n\nproc 和 sys 目录不能直接操作，这两个目录保存的是内存的过载点。\n\n2. Linux 常用命令2.1 命令基本格式\n命令    [选项]     [参数]\n\n2.2 查询目录中内容\nls   [选项]    [文件或目录]\n\n选项：\n\n-a：显示所有文件，包括隐藏文件\n-l：显示详细信息\n-d：查看目录属性\n-h：人性化显示文件大小\n-i：显示 inode\n\n2.3 目录处理命令\nmkdir -p [目录名]\n\n-p 递归创建\n命令英文原意：make directories\n\ncd [目录]\n\n命令英文原意：change directory\n\n简化操作\n\n\ncd ~          进入当前用户的家目录\n\n\ncd\n\n\ncd -          进入上次目录\n\n\ncd ..         进入上一级目录\n\n\ncd .          进入当前目录\n\n查询所在目录位置：pwd\n命令英文原意：print working directory\n2.4 删除文件或目录\nrm -rf [文件或目录]\n\n选项：\n\n-r：删除目录\n-f：强制\n\n2.5 复制命令\ncp [选项] [源文件或目录] [目标目录]\n\n选项：\n\n-r：复制目录\n-p：连带文件属性复制\n-d：若源文件是链接文件，则复制链接属性\n-a：相当于 -pdr\n\n2.6 剪切或改名命令\nmv [原文件或目录] [目标目录]\n\n2.7 链接命令\nln -s [原文件] [目标文件]\n\n生成链接文件\n选项：-s 创建软链接\n硬链接特征：\n\n拥有相同的i节点和存储block块，可以看做是同一个文件\n可通过i节点识别\n不能跨分区\n不能针对目录使用\n\n软链接特征：\n\n类似 Windows 快捷方式\n软链接拥有自己的i节点和block块，但是数据块中只保存原文件的文件名和i节点号，并没有实际的文件数据\nlrwxrwxrwx表示软链接，软链接文件权限都为rwxrwxrwx\n修改任意文件，另一个都改变\n删除原文件，软链接不能使用\n软链接如果目标文件和源文件不在同一目录下，源文件必须写绝对路径\n\n2.8 文件搜索命令\nlocate 文件名\n\n在后台数据库中按文件名搜索，搜索速度更快\n\n/var/lib/mlocate\n\nlocate 命令所搜索的后台数据库\n\nupdatedb\n\n更新数据库。默认一天一更新。快。缺点：只能按文件名来搜索\n\nfind [搜索范围] [搜索条件]\n\n搜索文件\n\nfind / -name install.log\n\n避免大范围搜索，会非常耗费系统资源\nfind 是在系统当中搜索符合条件的文件名。如果需要匹配，使用通配符匹配，通配符是完全匹配。\n*    匹配任意内容\n?    匹配任意一个字符\n[]    匹配任意一个中括号内的字符\n\nfind /root -iname install.log\n\n不区分大小写\n\nfind /root -user root\n\n按照所有者搜索\n\nfind /root -nouser\n\n查找没有所有者的文件\n\nfind /var/log -mtime +10\n\n查找10天前修改的文件\n\nfind . -size 25k\n\n查找文件大小是 25KB 的文件\n\nfind . -inum 262422\n\n查找i结点是 262422 的文件\n2.9 搜索命令的命令\nwhereis 命令名\n\n搜索命令所在路径及帮助文档所在位置\n选项：\n\n-b：只查找可执行文件\n-m：只查找帮助文件\n\nwhich 命令能看到目录和别名\n2.10 搜索字符串命令\ngrep [选项] 字符串 文件名\n\n在文件当中匹配符合条件的字符串\n选项：\n\n-i：忽略大小写\n-v：排除指定字符串\n\n2.11 帮助命令\nman 命令\n\n\n命令 –help\n\n\nhelp shell内部命令\n\n\ninfo 命令\n\n2.12 压缩命令zip 格式压缩\n\nzip 压缩文件名 源文件\n\n压缩文件\n\nzip -r 压缩文件名 源目录\n\n压缩目录\nzip格式解压缩\n\nunzip 压缩文件\n\ngz 格式压缩\n\ngzip 源文件\n\n压缩为.gz 格式的压缩文件，源文件会消失\n\ngzip -c 源文件 &gt; 压缩文件\n\n压缩为.gz 格式，源文件保留\n\ngzip -r 目录\n\n压缩目录下所有的子文件，但是不能压缩目录\ngz 格式解压缩\n\ngzip -d 压缩文件\n\n解压缩文件\n\ngunzip 压缩文件\n\n解压缩文件\nbz2 格式压缩\n\nbzip2 源文件\n\n压缩为.bz2格式，不保留源文件\n\nbzip2 -k 源文件\n\n压缩之后保留源文件\nbzip2命令不能压缩目录\n打包命令tar\n\ntar -cvf 打包文件名 源文件\n\n解打包命令\n\ntar -xvf 打包文件名\n\n.tar.gz压缩格式\n其实.tar.gz 格式是先打包为.tar格式，再压缩为.gz格式\n\ntar -zcvf 压缩包名.tar.gz 源文件\n\n.tar.gz 解压缩\n\ntar -zxvf 压缩包名.tar.gz\n\n.tar.bz2压缩格式\n\ntar -jcvf 压缩包名.tar.bz2 源文件\n\n.tar.bz2 解压缩\n\ntar -jxvf 压缩包名.tar.bz2\n\n2.13 关机命令\nshutdown [选项] 时间\n\n选项：\n\n-c：取消前一个关机命令\n-h：关机\n-r：重启\n\n\nhalt\n\n\npoweroff\n\n\ninit 0\n\n2.14 重启\nreboot\n\n\ninit 6\n\n2.15 系统运行级别\n0：关机\n1：单用户\n2：不完全多用户，不含NFS服务\n3：完全多用户\n4：未分配\n5：图形界面\n6：重启\n\n\ncat /etc/inittab\n\n修改系统默认运行级别\n\nrunlevel\n\n查询系统运行级别\n\nlogout\n\n退出登录\n2.16 挂载命令\n查询与自动挂载\n\n\nmount\n\n查询系统中已经挂载的设备\n\nmount -a\n\n依据配置文件/etc/fstab 的内容，自动挂载\n\n挂载命令格式\n\n\nmount [-t 文件系统] [-o 特殊选项] 设备文件名 挂载点\n\n\n挂载光盘\n\n\nmkdir /mnt/cdrom\n\n建立挂载点\n\nmount -t iso9660 /dev/cdrom /mnt/cdrom/\n\n挂载光盘\n\n卸载命令\n\n\numount 设备文件名或挂载点\n\n\numount /mnt/cdrom\n\n2.17 查看登录用户信息\nw 用户名\n\n命令输出：\n\nUSER：登录的用户名\nTTY：登录终端\nFROM：从哪个IP地址登录\nLOGIN@：登录时间\nIDLE：用户闲置时间\nJCPU：和该终端连接的所有进程占用的时间\nPCPU：当前进程所占用的时间\nWHAT：当前正在运行的命令\n\n\nwho 用户名\n\n\n查询当前登录和过去登录的用户信息\n\n\nlast\n\n\n查看所有用户的最后一次登录时间\n\n\nlastlog\n\n2.18 历史命令\nhistory [选项] [历史命令保存文件]\n\n选项\n\n-c：清空历史命令\n-w：把缓存中的历史命令写入历史命令保存文件 ~/.bash_history\n\n历史命令默认会保存 1000 条，可以在环境变量配置文件 /etc/profile 中进行修改\n2.19 统计\nwc [选项] [文件名]\n\n选项\n\n-c：统计字节数\n-w：统计单词数\n-l：统计行数\n\n2.20 管道符分页查看输出内容\n\nls -l /etc | more\n\n\nnetstat -an | grep ESTABLISHED\n\n2.21 用户和用户组\n用户：使用操作系统的人\n\n用户组：具有相同系统权限的一组用户\n\n/etc/group：存储当前系统中所有用户组信息\n\n组名称\n组密码占位符\n组编号\n组中用户名列表\n\n\n/etc/gshadow：存储当前系统中用户组的密码信息\n\n组名称\n组密码\n组管理者\n组中用户名列表\n\n\n/etc/passwd：存储当前系统中所有用户的信息\n\n用户名\n密码占位符\n用户编号\n用户组编号\n用户注释信息\n用户主目录\nshell 类型\n\n\n/etc/shadow 存储当前系统中所有用户的密码信息\n\n用户名\n密码\n\n\n\n3. vi 操作3.1 操作模式\nCommand Mode：命令模式\nInsert Mode：输入模式\nLast Line Mode：底行模式\n\n3.2 常用指令\nvim + abc\n\n打开文件并把光标定位到最后一行\n\nvim +2 abc  \n\n第二行\n\nvim +/xxx abc\n\n跳到指定字符串第一次出现的地方同时打开多个文件 可用n  N  prev来切换\n3.3 底行模式常用指令\n:w\n保存文件，但不退出vi\n\n\n:q\n退出vi\n\n\n:!\n强制执行\n\n\n/xxx\n 向下查找, 按n查找下一个, N查找上一个,这个跟less命令的查找使用方式是一样的\n\n\n?xxx\n往前查找, 按n查找下一个, N查找上一个\n\n\n\n3.4 命令模式常用指令\nh：光标左移\nj：光标下移\nk：光标上移\nl：光标右移\nctrl+f：向下翻页\nctrl+b：向上翻页\nctrl+d：向下翻半页\nctrl+f：向上翻半页\ndd：删除光标所在行\no：在光标所在处的下方插入一行并切换到输入模式\nyy：复制光标所在的行\np：在光标所在行的下方粘贴\nP：在光标所在行的上方粘贴\n\n3. Shell 基础3.1 Shell 是什么\n命令行解释器，可启动、挂起、停止或编写程序\n编程语言，可直接调用Linux 系统命令\n\n3.2 输出命令\necho [选项] [输出内容]\n\n3.3 脚本编写首行\n\n#!/bin/bash\n\n\necho “hello world”\n\n赋予执行权限，直接运行\n\nchmod 755 hello.sh\n\n\n./hello.sh\n\n通过bash 执行脚本\n\nbash hello.sh\n\n\n\n\n\n","categories":["夯实基础系列"],"tags":["Linux","总结","心得"]},{"title":"夯实基础系列三：数据库知识总结","url":"https://java4u.cn/tamp-basic-series/夯实基础系列/tamp_basic_series_3/","content":"前言对于后端开发人员来说，经常会和数据打交道，今天总结下数据库相关的知识。包括MySQL，JDBC基础，JDBC进阶，MongoDB，性能优化。以下对这些内容做一些简单的总结。\n\n\n\n细节1. MySQL1.1 数据库的概述\nDBMS\n解释：关系型数据库管理系统\n库管+N个仓库\n\n\n常见的数据库管理系统\nMySQL\nOrcale\nDB2\nSQL Server\nSybase\n\n\n\n\n\n1.2 安装MySQL\n目录结构\nmysql.exe：客户端\nmysqld.exe：服务器\nmy.ini：总配置文件\n\n\n在windows下开户和关闭mysql服务器\nnet start mysql\nnet stop mysql\n\n\n登录和退出mysql客户端\nmysql -u用户名 -p密码 -hIP\nexit或quit\n\n\n\n1.3 SQL\n概述\n解释：结构化查询语言\nISO：国际标准化组织\nISO 定义了很多 SQL 标准，例如：SQL99\n各个数据库厂商需要遵循这个标签！但各个厂商也有自己的方言\n\n\nSQL的分类\nDDL：数据定义语言\nDML：数据操作语言\nDCL：数据控制语言\nDQL（不在标准中）：数据查询语言\n\n\n\n1.4 DDL\n数据库的操作\ncreate database\nshow databases\nuse mydb1\nalter database\ndrop database\n\n\n表的操作\ncreate table\nshow tables\ndesc mytable1\ndrop table\nalter table\nadd\nmodify\nchange\ndrop\nrename to\n\n\n\n\n\n1.5 DML\n插入记录\n修改记录\n删除记录\ndelete\ntruncat\n\n\n\n1.6 DCL\n创建用户\n授权\n撤消权限\n查看权限\n删除用户\n\n1.7 DQL\n基本查询\n查看整张表\nselect * from 表名\n\n\n列控制\n列运算：select sal * 1.5 from emp\n列运算：连接字符串：select concat(‘我的名称是’, ename) from emp\n处理 NULL 值：select sal + IFNULL(comm, 0) from emp\nselect ename 姓名 from emp\n去除完全重复的行：select distinct comm from emp\n\n\n\n\n条件查询\n模糊查询\n下划线\n百分号\n\n\n\n\n排序\ndesc\nasc\n\n\n聚合函数\ncount\nmin\nmax\nsum\navg\n\n\n分组\ngroup by\nhaving\n\n\nlimit\n\n1.8 约束\n约束保证数据的完整性和一致性\n约束分为表级约束和列级约束\n对一个数据列建立的约束，列级约束\n对多个数据列建立的约束，表级约束\n\n\n约束类型包括：\nNOT NULL\nPRIMARY KEY\nUNIQUE KEY\nDEFAULT\nFOREIGN KEY\n\n\n\n1.9 中文无法插入解决办法\ndos 下不支持直接使用 utf8,set names gbk，再插入即可。\n\n1.10 连接类型\n内连接\n显示左表及右表符合连接条件的记录\n\n\n左外连接\n显示左表的全部记录及右表符合连接条件的记录\n\n\n右外连接\n显示右表的全部记录及左表符合连接条件的记录\n\n\n自身连接\n同一个数据表对其自身进行连接\n\n\n\n2. JDBC2.1 JDBC 的原理\n是由 JavaEE 提供的连接数据库的规范\n需要由各大数据库的厂商提供对 JDBC 的实现类\n\n2.2 四大核心类\nDriverManager\n\ngetConnection\n\n\nConnection\n\ncreateStatement\nprepareStatement(String sql)\n\n\nStatement\n  方法：\n  ​    1.executeUpdate()–&gt;增、删、改　  ​    2.executeQuery()–&gt;查  ​    3.addBatch(String sql)  ​    4.executeBatch()  ​    5.execute(String sql)\n\nResultSet\n\ngetXxx()系统方法\n移动光标系统方法\n\n\n\n2.3 四大参数\ndriverClassName\nurl\nusername\npassword\n\n2.4 预编译语句集\n防SQL攻击\n可读性提高了\n效率高\n\n2.5 DAO模式\n面向接口编程\nDAO接口\nDAO实现，可以提供多个实现\nDAO工厂\nDAO配置文件：提供实现类名称\n\n\n\n2.6 时间类型的转换\n领域对象中的日期时间，必须为 util 的Date\n在 JDBC 中使用的都是 sql 的 Date\ninsert、update、delete，需要把领域对象中的 util 的 Date 转换成 sql 的 Date\n在 select 时，需要把 sql 的 Date 赋给领域对象的 util 的 Date 类型的属性，这不需要处理\n\n2.7 大数据存取\n把文件转换成 Blob 类型\n把 Blob 类型转换成文件\n\n2.8 批处理\n添加批\n执行批\n\n3. JDBC_进阶3.1 事务\nACID\n\n原子性\n一致性\n隔离性\n持久性\n\n\nmysql 中开启和关闭事务\n\n开启事务：START TRANSACTION\n结束事务\n提交事务：COMMIT\n回滚事务：ROLLBACK\n\n\n\n\nJDBC 中开启和关闭事务\n\n开启事务：connection.setAutoCommit(false)\n结束事务\nconnection.commit()\nconnection.rollback()\n\n\n\n\n格式：\n  try &#123;\n  ​      con.setAutoCommit(false);//开始事务  ​      …  ​       con.commit();//提交事务  ​    } catch(…) {  ​       con.rollback();//回滚事务  ​    }\n\n\n3.2 三种并发读问题\n脏读\n读到未提交\n\n\n不可重复读\n两次读取不一致，读取到另一事务修改的记录\n\n\n幻读\n两次读取不一致，读取到另一事务插入的记录\n\n\n\n3.3 四种隔离级别\n串行化\n可重复读\n防止了脏读、不可重复读    MySQL\n\n\n读已提交\n防止了脏读    Oracle\n\n\n读未提交\n\n3.4 连接池\n必须实现 javax.sql.DataSource\nDBCP\nC3P0\n\n3.5 JNDI\n在 tomcat 的 conf/catalina/localhost 下创建 xml 文件\n配置元素\n在中配置元素\n\n\n在代码中使得 Context 类的 lookup 方法来获取资源\njava:comp/env/ 资源名称\n\n\n\n3.6 ThreadLocal\n内部有一个 Map\nkey 是当前线程\n\n\n\n4. MongoDB4.1 MongoDB 安装\n在 github 上获取源码包 mongo-r2.6.5.zip\n解压缩 \n\n\nunzip mongo-r2.6.5.zip\n\n\n编译源码文件\n\n\ncd mongo-r2.6.5\n\n\nscons all -j 12        //12 为 CPU 核数，用来加速编译过程\n\n若未安装 scons，使用命令 sudo apt-get install scons\n4.2 编译后的文件\nmongod:mongodb 的启动文件，用来部署数据库\nmongo：链接服务器的客户端\nmongoimport,,mongoexport:用来导入导出数据库\nmongodump,mongorestore:用来导入导出二进制数据，一般用来数据的备份与恢复。\nmongooplog 操作日志\nmongostat:用来查看 mongodb 服务器的各种状态。\n\n4.3 MongoDB 搭建\n建立相关目录\n\ndata (用于存放数据文件)\nlog（用于存放日志文件）\nconf（用于存放数据库配置文件 mongod.conf）\nbin（用于存放数据库可执行文件 mongod） \n\n\n编辑配置文件\n  mongod.conf&#123;\n  ​    port = 12345 /监听端口/  ​    dbpath = data /指定数据文件/  ​    logpath = log/mongod.log /指定日志文件/  ​    fork = ture /linux后台运行标志，window无效/  ​    }\n\n运行程序\n\n\n\nmongod -f conf/mongod.conf /运行mongod 加载指定配置文件/\n\n\n查看运行状态\n  data 和 log 目录 \n  ​    tail mongod.log /查看日志/\n\n\n4.4 MongoDB 连接操作：\n1、拷贝到指定目录 ：cp mongo bin\n2、执行程序 mongo 127.0.0.1:12345/test(ip端口数据库)~\n3、关闭 mongodb use admin -》db.shutdownServer(),kill -15 进程\n4、重新启动 mongodb：numactl --interleave=all bin/mongod -f conf/mongod.conf\n4.5 数据库使用1、连接数据库\n/bin/mongo 127.0.0.1:12345\n2、显示数据库\nshow dbs\n3、切换数据库\nuse imooc(库名)\n4、切换后删除数据库\ndb.dropDatabase()\n5、创建数据库\nuse imooc(库名)\n6、查看数据库\nshow dbs\n7、创建 imooc_collection 并插入数据\ndb.imooc_collection.insert(&#123;x:1&#125;) -&gt; json 数据\n_id全局唯一不重复，可自行定义不重复字段\ndb.imooc_collection.insert(&#123;x:1,_id:1&#125;)\n插入多条语句（支持js语法）\nfor(i=3;i&lt;100;i++) db.imooc_collection.insert(&#123;x:i&#125;)\n8、显示表结构\nshow collections\n9、查询数据表中数据\n    a) 查询所有 db.imooc_collection.find()\n    b) 条件查询(x:1的数据) db.imooc_collection.find(&#123;x:1&#125;)\n    c)高级查询\n        db.imooc_collection.find().count()/*统计条数*/\n        db.imooc_collection.find().skip(3).limit(2).sor(&#123;x:1&#125;)/*过滤掉前三条并限制返回2条且使用x排序*\n4.6 数据更新 update1.db.imooc_collection.update(&#123;x:1&#125;,&#123;x:999&#125;) #将x为1的数据更新为x=999\nupdate接收两个参数，第一个是过滤条件，这里是x=1的数据，第二个是需要修改的目标值\n2.另一种情况，一条数据包含三个字段值，如\n&gt;db.imooc_collection.insert(&#123;x:100,y:100,z:100&#125;)\n如果直接执行&gt;db.imooc_collection.update(&#123;z:100&#125;,&#123;y:99&#125;) #将z为100的数据中的y更新为99\n这样会将x和z覆盖掉，只剩下y:99\n为了避免这种情况，需要：\n&gt;db.imooc_collection.update(&#123;z:100&#125;,&#123;$set:&#123;y:99&#125;&#125;) #加入set操作符\nset操作符为部分更新操作符，使用set后，内容中存在的字段会被更新，而不存在的字段会保持原状\n\n如果查找的数据不存在则创建：\n&gt; db.user.update(&#123;name: &#39;admin&#39;&#125;, &#123;name: &#39;admin-updated&#39;&#125;, true)\n第三个参数为true即可\n\nmongoDB：update方法有四个参数\n第一个参数：查找数据的条件，如&#123;c:1&#125; 表示查找c为1的数据\n第二个参数：要更新的数据，如&#123;c:2&#125; 跟新符合条件的数据c为2，默认只更新第一个符合条件的数据。\n第三个参数：boolean类型，更新数据不存在时是否创建一条数据，默认为false,设置为true时，自动创建数据。\n第四个参数：boolean类型，跟新数据时是否更新所有符合条件的数据，默认为false,只跟新一条符合条件的数据，设置为true时，更新所有符合条件的数据。\n\n如db.collection.update(&#123;c:1&#125;,&#123;$set&#123;c:2&#125;&#125;,false,true)\nupdate(旧数据,&#123;$set:新数据&#125;,false,true),只能使用部分更新操作符号$SET\n4.7 MongoDB 方法APIdb.test.save(&#123;1:&quot;hello&quot;&#125;);保存数据到test集合中\ndb.test.insert(&#123;1:&quot;hello&quot;&#125;);插入数据到test集合中(和insert功能相同) \nfind:一个参数，查找数据的条件，不填则查找所有数据\nupdate:上章说过\nremove:删除数据，一个参数（必须，否则会报错）：条件，默认删除所有符合条件的数据。\ndrop：没有参数，删除当前数据表\ncount:查找数据的条数\nsort:排序，一个参数，排序条件，&#123;c:1&#125; 根据c排序， 1为正序，-1为倒序。\nshow dbs:查询所有数据库\nshow tables:查询数据表\nshow collections; 显示当前选择的db中的集合 \nuse dbname:选择数据库，如果数据库不存在，在第一次保存数据的时候会创建数据库。\n4.8 命令小结scons all\nmongod -f file\nmongo ip:port\nshow dbs\nuse db\nshow collections\ndb.collection.insert();\ndb.collection.update()\ndb.collection.delete()\ndb.collection.count();\ndb.collection.find()\ndb.collection.getIndexes()\ndb.collection.ensuerIndex()\n5. 性能优化5.1 MySQL 性能优化\n表的设计合理化(符合3NF)\n1NF 是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)\n2NF 是对记录的惟一性约束，要求记录有惟一标识，即实体的惟一性；\n3NF 是对字段冗余性的约束，它要求字段没有冗余。 没有冗余的数据库设计可以做到。\n\n\n添加适当索引(index) [四种: 普通索引、主键索引、唯一索引 unique、全文索引]\n较频繁的作为查询条件字段应该创建索引\n唯一性太差的字段不适合单独创建索引，即使频繁作为查询条件\n更新非常频繁的字段不适合创建索引\n不会出现在 WHERE 子句中的字段不该创建索引\n\n\n分表技术(水平分割、垂直分割)\n读写[写: update/delete/add]分离\n存储过程 [模块化编程，可以提高速度]\n对 mysql 配置优化 [配置最大并发数 my.ini, 调整缓存大小 ]\nmysql 服务器硬件升级\n定时的去清除不需要的数据,定时进行碎片整理(MyISAM)\n\n5.2 SQL语句优化\n通过 show status 命令了解各种 SQL 的执行频率。\n定位执行效率较低的 SQL 语句-（重点 select）\n通过 explain 分析低效率的 SQL\n确定问题并采取相应的优化措施\n\n5.3 索引\n索引的类型\n主键索引，主键自动的为主索引 (类型 Primary)\n唯一索引 (UNIQUE)\n普通索引 (INDEX)\n全文索引 (FULLTEXT) [适用于MyISAM] ——》sphinx + 中文分词    coreseek [sphinx 的中文版 ]\n综合使用=&gt;复合索引\n\n\n可能使用到索引\n对于创建的多列索引，只要查询条件使用了最左边的列，索引一般就会被使用。\n对于使用like的查询，查询如果是  ‘%aaa’ 不会使用到索引， ‘aaa%’ 会使用到索引。\n\n\n不使用索引\n如果条件中有 or，即使其中有条件带索引也不会使用。\n对于多列索引，不是使用的第一部分，则不会使用索引。\nlike 查询是以%开头\n如果列类型是字符串，那一定要在条件中将数据使用引号引用起来。否则不使用索引。(添加时,字符串必须’’)\n 如果mysql估计使用全表扫描要比使用索引快，则不使用索引。\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["夯实基础系列"],"tags":["数据库","总结","心得","MySQL","MongoDB"]},{"title":"夯实基础系列二：网络知识总结","url":"https://java4u.cn/tamp-basic-series/夯实基础系列/tamp_basic_series_2/","content":"前言无论是 C/S 开发还是 B/S 开发，无论是前端开发还是后台开发，网络总是无法避免的，数据如何传输，如何保证正确性和可靠性，如何提高传输效率，如何解决会话管理问题，如何在网络拥堵环境下采取措施。这些都是需要了解的。\n上一篇总结了 Java 相关知识：夯实基础系列一：Java 基础总结。今天总结下与网络相关的知识，不是那么详细，但是包含了我认为重要的所有点。如果想深入了解的可以参考《图解HTTP[上野 宣]》、《图解TCP／IP（第5版）[竹下隆史]》以及计算机网络相关教材。\n\n\n概要网络知识我做了 8 个方面的总结，包括 DNS 协议，HTTP 协议，HTTPS 协议，TCP 协议，IP 协议，TCP/IP，Web 攻击，其他协议。以下对这些内容做一些简单的总结，同时我也有完整的思维导图，若有需要，请关注微信公众号蜗牛互联网，后台回复 网络 即可获取。\n\n细节1. DNS 协议作用：提供域名到 IP 地址之间的解析服务。或逆向从 IP 地址反查域名的服务。\n2. HTTP 协议2.1 特点\n无状态\n使用 URI 定义互联网资源\nHTTP方法\nGET：获取资源\nPOST：传输实体主体\nPUT：传输文件\nHEAD：获得报文首部\nDELETE：删除文件\nOPTIONS：询问支持的方法\nTRACE：追踪路径\nCONNECT：要求用隧道协议连接代理\n\n\n持久连接节省通信量\n管线化实现并行发送多个请求，而不需要一个接一个等响应\n\n2.2 HTTP 报文\n用于 HTTP 协议交互的信息称为 HTTP 报文\n请求报文\n报文首部\n请求行\n请求首部字段\n通用首部字段\n实体首部字段\n其他\n\n\n空行\n报文主体\n\n\n响应报文\n报文首部\n状态行\n响应首部字段\n通用首部字段\n实体首部字段\n其他\n\n\n空行\n报文主体\n\n\n发送多种数据的多部分对象集合\nMIME\nmultipart/form-data\n\n\n内容协商\n服务器驱动协商\n客户端驱动协商\n透明协商\n\n\n\n2.3 HTTP 状态码\n1XX：接收的请求正在处理\n2XX：请求正常处理完毕\n200 OK\n204 NoContent\n206 Partial Content\n\n\n3XX：需要进行附加操作以完成请求\n301 Moved Permanenetly\n302 Found\n303 See Other\n304 Not Modified\n307 Temporary Redirect\n\n\n4XX：服务器无法处理请求\n400 Bad Request\n401 Unauthorized\n403 Forbidden\n404 Not Found\n\n\n5XX：服务器处理请求出错\n500 Internal Server Error\n503 Service Unavailable\n\n\n\n2.4 HTTP 1.1 和 HTTP 1.0的区别\n可扩展性：定义Via头域，增加版本号的支持\n缓存\n增加对缓存的重激活机制：使用 ETag 头域描述一个资源\n增加 Cache-Control 头域支持可扩展的指令集 \n\n\n带宽优化：允许请求资源的某部分，而不是整个资源 \n长连接\nHTTP/1.0 只支持浏览器与服务器保持短暂的连接，浏览器的每次请求都要建立一个新的连接。\n而 HTTP/1.1 允许在一个 TCP 连接上可以传送多个 HTTP 请求和响应。HTTP/1.1 协议的持续连接有两种方式，即非流水线方式和流水线方式。\n非流水线方式的特点是，客户在收到前一个响应后才能发出下一个请求；\n流水线方式的特点是，客户在收到 HTTP 的响应报文之前就能接着发送新的请求报文 \n\n\n\n\n\n2.5 Cookie 与 Session 的区别\n存取方式的不同\nCookie 中只能保管 ASCII 字符串，假如需求存取 Unicode 字符或者二进制数据，需要先进行编码。Cookie 中也不能直接存取 Java 对象。若要存储略微复杂的信息，运用 Cookie 是比较艰难的。\nSession 中能够存取任何类型的数据，包括而不限于 String、Integer、List、Map 等。Session 中也能够直接保管 Java Bean 乃至任何 Java 类，对象等，运用起来十分便当。能够把 Session 看做是一个 Java 容器类。\n\n\n隐私策略的不同\nCookie 存储在客户端阅读器中，对客户端是可见的，客户端的一些程序可能会窥探、复制以至修正 Cookie 中的内容。\nSession 存储在服务器上，对客户端是透明的，不存在敏感信息泄露的风险。\n\n\n有效期上的不同\nCookie 的过期时间指定\nSession 依赖于名为 JSESSIONID 的Cookie，而 Cookie JSESSIONID 的过期时间默许为 –1，只需关闭了浏览器该 Session 就会失效，因而 Session 不能完成信息永世有效的效果。\n\n\n服务器压力的不同\nCookie 保管在客户端，不占用服务器资源。假如并发阅读的用户十分多，Cookie 是很好的选择。关于 Google、Baidu、Sina 来说，Cookie 或许是唯一的选择。\nSession 是保管在服务器端的，每个用户都会产生一个 Session。假如并发访问的用户十分多，会产生十分多的 Session，耗费大量的内存。因而像 Google、Baidu、Sina 这样并发访问量极高的网站，是不太可能运用 Session 来追踪客户会话的。\n\n\n浏览器支持的不同\nCookie 是需要客户端浏览器支持的。\n假如客户端浏览器不支持 Cookie，需要运用 Session 以及 URL 地址重写。\n\n\n跨域支持上的不同\nCookie 支持跨域名访问，例如将 domain 属性设置为“.biaodianfu.com”，则以“.biaodianfu.com”为后缀的一切域名均能够访问该 Cookie。跨域名 Cookie 如今被普遍用在网络中，例如 Google、Baidu、Sina 等。\nSession 则不会支持跨域名访问。Session 仅在他所在的域名内有效。\n\n\n\n2.6 电脑访问网页的过程\n用到的协议：DNS、HTTP、OSPF、IP、ARP\n过程描述\nDNS 把域名解析成对应的 IP \n发送一次请求，服务器返回一个永久重定向响应，这样浏览器就知道要访问的正确网址 \n发送请求 html 的请求，这个连接过程基于 TCP/IP 三次握手四次挥手的，建立连接 \n服务器返回一个 html 响应 \n浏览器根据渲染引擎解析返回的 html 响应，呈现内容 \n继续发送内嵌在html文件其他资源的请求，比如 css、js、图片资源等 \n加载整个页面\n\n\n\n2.7 Ping\n同网段\n主机 A 要去 Ping 主机 B， 主机 A 会封装两层报文，主机 A 先检查自己 MAC 地址中是否有 B 的 MAC 地址，如果没有就向外发送一个 ARP 广播包 \n交换机收到这个 ARP 后，会检查在交换机中是否包含 B 的 MAC 地址，如果有就直接返回给 A；如果没有就向所有端口发送 ARP，该网段的主机的 MAC 如果与 B 的 MAC 地址不同就丢弃，如果主机 B 收到了该 ARP 就马上返回相同格式的 ARP \n这时主机 A 已经有了 B 的 MAC 地址，就把 B 的 MAC 地址封装到 ICMP 报中，向主机 B 发送一个回显请求 \n主机 B 收到该报文后，知道是主机 A 的一个回显请求，就会返回一个相同格式的报文。这样就完成了同一个网段的 Ping 的过程\n\n\n不同网段\n主机 A 要去 Ping 一个不同网段的主机 C，主机 A 会去找网关转发 \n如果主机 A 不知道网关的 MAC 地址，就会发送一个 ARP 广播一下，这样就知道了网关的 MAC 地址 \n网关收到主机 A 的 ICMP 报文，根据上面的目的 IP，会去查找路由表，找到一个出口指针，给主机 C 发送一个 ICMP 报文 \n如果网关不知道主机 C 的 MAC 地址，就会给网关内所有的主机发送一个 ARP，从而找到主机 C 的 MAC 地址 \n主机 C 收到主机 A 的报文就会给主机 A 发送一个回显请求。这样就完成了不同网段的 Ping 的请求\n\n\n\n2.8 路由器与交换机的区别路由器包含了交换机的功能，交换机主要的作用是扩展接口\n2.9 确认访问用户身份的认证\nbasic 认证\ndigest 认证\nssl 客户端认证\n基于表单认证\n认证多半为基于表单认证\nsession 管理及 cookie 应用\n\n\n\n2.10 websocket\n全双工通信\n特点\n推送功能：支持服务器向客户端推送数据的推送功能\n减少通信量：一直保持连接\nHTTP 连接建立后，需要完成一次握手动作\n握手—请求：用到 HTTP 的 upgrade 字段告知服务器通信协议发生变化\n握手—响应：对于之前的请求返回状态码 101 switching    protocols\n\n\n成功握手确立 WebSocket 连接之后，通信不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧\n\n\n\n3. HTTPS 协议3.1 HTTP 缺点\n通信使用明文可能会被窃听\n解决方式\n通信加密。SSL 和 TLS 组合使用\n内容加密\n\n\n\n\n不验证通信方身份就可能遭遇伪装\n解决方式：查明对手的证书\n\n\n无法证明报文完整性，可能已遭篡改\n数字签名，MD5 并不可靠，应用 HTTPS\n\n\n\n3.2 HTTP+加密+认证+完整性保护=HTTPS3.3 HTTPS 是身披 SSL 外壳的 HTTP3.4 HTTP 采用混合加密机制3.5 证明公开密钥正确性的证书3.6 SSL 协议\n慢\n通信慢\n由于大量消耗 CPU 及内存等资源，导致处理速度变慢\nSSL 必须进行加密处理\n\n\n\n4. TCP 协议4.1 传输层4.2 作用\n提供可靠的字节流服务\n\n4.3 大块数据分割成报文段(segment)4.4 三次握手\n发送端发带 SYN 标志的数据包给对方。\n接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。\n最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束\n\n\n握手某个阶段中断，TCP 会以相同的顺序发送相同的数据包\n\n4.5 四次挥手\n客户端 A 发送一个 FIN，用来关闭客户 A 到服务器 B 的数据传送。\n服务器 B 收到这个 FIN，它发回一个 ACK，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号。\n服务器 B 关闭与客户端 A 的连接，发送一个 FIN 给客户端 A。\n客户端 A 发回 ACK 报文确认，并将确认序号设置为收到序号加 1。\n\n4.6 流量控制\nTCP 接收端对发送端发送多少字节的数据进行控制，防止接收端处理不及而丢失数据\n发送窗口的大小是受到接收窗口的控制的。\n发送窗口必须根据接收端的大小及时调整发送窗口的大小，这个机制保证了每次 TCP 传输的数据量都是接收端可以及时处理的。\n\n4.7 差错控制\n保证接收端接收的数据是完整未受损伤的，是可靠性的重要保证。\n主要使用校验和、确认、超时重传这三个工具进行差错控制。\n\n4.8 拥塞控制\n拥塞窗口\n发送方的窗口大小是接收窗口与拥塞窗口中的较小值。\n拥塞窗口的大小又取决于网络的拥塞状况。\n\n\n拥塞策略\n慢开始\n拥塞避免\n拥塞检测\n\n\n拥塞控制流程\n由于刚开始不清楚网络的拥塞情况，所以会首先采用慢开始算法，开始阶段，窗口大小由1指数增大，直到窗口大小到达门限值。\n窗口大小到达门限值后，就开始执行拥塞避免算法，之后窗口值按照线性规律增大，直到出现超时或者到达最大的窗口大小值。\n这个时候，会开始执行拥塞检测算法，也就是把门限值变为窗口大小的一半，之后继续执行拥塞避免算法，窗口大小按照线性规律增大。\n\n\n\n5. IP协议5.1 网络层5.2 作用\n把数据包传送给对方\n\n5.3 条件\nIP 地址和 MAC 地址\n\n5.4 使用 ARP 协议凭借 MAC 地址进行通信5.5 路由选择6. TCP/IP6.1 协议族\nIP、ICMP、DNS、TCP、FTP、HTTP、SNMP\n\n6.2 分层管理\n应用层\n决定向用户提供应用服务时通信的活动。FTP、HTTP、DNS\n\n\n传输层\n对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP、UDP\n\n\n网络层\n处理网络上流动的数据包\n规定了通过怎样的路径到达对方计算机，并把数据包传送给对方\n\n\n数据链路层\n处理连接网络的硬件部分\n\n\n\n6.3 通信传输流\n发送端层与层之间传输数据，每经过一层时必定会被打上一个该层所属的首部信息\n接收端在层与层传输数据时，每经过一层时会把对应的首部消去。\n这种把数据信息包装起来的做法称为封装\n\n7. Web 攻击7.1 因输出值转移不完全引发的安全漏洞\n跨站脚本攻击 XSS\nSQL 注入攻击\nOS 命令注入攻击\nHTTP 首部注入攻击\n邮件首部注入攻击\n目录遍历攻击\n远程文件包含漏洞\n\n7.2 因设置或设计上的缺陷引发的安全漏洞\n强制浏览\n不正确的错误消息处理\n开放重定向\n\n7.3 因会话管理疏忽引发的安全漏洞\n会话劫持\n会话固定攻击\n跨站点请求伪造(CSRF)\n\n7.4 其他安全漏洞\n密码破解\n点击劫持\ndos 攻击\n后门程序\n\n8. 其他协议8.1 IGMP 协议\n组管理协议，它帮助多播路由器创建以及更新与每一个路由接口相连的忠实成员列表（就是与该路由接口连接频率较高）。\n\n8.2 ICMP 协议\n差错控制协议，弥补了 IP 协议没有差错纠正机制以及差错报告的缺憾。\n\n8.3 ARP协议\n地址映射协议，可以把一个 IP 地址映射为 MAC 地址。\n把IP数据报封装成帧（以太网上对01串的分组定义）后才能通过物理网络，这时就需要目的主机的MAC地址\n\n\n\n","categories":["夯实基础系列"],"tags":["网络","基础"]},{"title":"夯实基础系列一：Java 基础总结","url":"https://java4u.cn/tamp-basic-series/夯实基础系列/tamp_basic_series_1/","content":"前言大学期间接触 Java 的时间也不短了，不论学习还是实习，都让我发觉基础的重要性。互联网发展太快了，各种框架各种技术更新迭代的速度非常快，可能你刚好掌握了一门技术的应用，它却已经走在淘汰的边缘了。\n而学习新技术总要付出一定的时间成本，那么怎么降低时间成本呢？那就是打好基础，技术再怎么革新，底层的东西也很少会变动，牢固的基础会帮助你在各种新技术的学习中游刃有余，快速上手。\n因为我选择的方向是后台开发，所以谈谈我认为的基础有哪些。其他方向肯定也有自己的体系，从低层到高层，可以自己摸索。后台的话，我觉得网络知识，各种协议，web 知识，数据库知识，Linux 基本操作以及自己选择的后台语言知识，这些是最基础最需要牢固掌握的。\n所以从今天起，会出一系列与后台基础相关的博文，一是对自己过去学习的一个总结，二是分享出来，希望可以帮助到需要的人。\n\n\n概要Java 基础我做了 10 个方面的总结，包括基本概念，面向对象，关键字，基本类型与运算，字符串与数组，异常处理，Java 平台与内存管理，分布式 Java 应用，多线程，IO。以下对这些内容做一些简单的总结，同时我也有完整的思维导图，博客上不方便展示，若有需要，请关注微信公众号蜗牛互联网，后台回复 Java 即可获取。\n\n细节1. 基本概念1.1 语言特点\n纯面向对象\n\n平台无关性\n\n内置类库\n\n支持 web\n\n安全性\n\n防止代码攻击\n\n\n健壮性\n\n强类型机制\n垃圾回收器\n异常处理\n安全检查机制\n\n\n去除 C++ 中难以理解易混淆的特性\n\n\n1.2 与 C++ 比较\n解释编译混合型语言，执行速度慢，跨平台\n纯面向对象，只有类，不存在全局变量或全局函数\n无指针，无多继承，可多实现\n垃圾回收器自动管理内存\n\n1.3 main函数知识\nJava 程序入口方法\n可由 final，synchronized 修饰，不能用 abstract\n\n1.4 Java程序初始化顺序\n静态优于非静态\n父类优于子类\n按照成员变量的定义顺序\n总共 10 个\n\n1.5 作用域与可见性\n静态变量属于类\n局部变量属于花括号\n成员变量看下一条\npublic、protected、default、private 可见性依次递减\n\n1.6 构造函数\n与类名相同，无返回值\n可重载，不能被继承，即不能被覆盖\n参数个数任意\n伴随 new 一起调用，为系统调用\n完成对象的初始化工作\n子类可通过 super 显式调用父类。父类没有提供无参，子类必须显式调用\n未定义，默认无参，修饰符取决于类修饰符\n\n1.7 标识接口\n无任何方法声明\n表示实现它的类属于一个特定的类型\n\n1.8 clone 方法\n实现 Cloneable 接口\n重写 Object 类中的 clone()\nclone() 中调用 super.clone()\n把浅复制引用指向新的克隆体\n\n1.9 反射\n定义：允许程序在运行时进行自我检查，也允许对其内部成员进行操作\n功能\n得到一个对象所属的类\n获取一个类的所有成员和方法\n运行时创建对象\n在运行时调用对象的方法\n\n\n获取类的方式\nclass.forName(“类路径”)\n类名.class\n实例.getClass()\n\n\n\n1.10 创建对象的四种方式\nnew\n反射机制\nclone()\n反序列化\n\n1.11 package 作用\n提供多层命名空间，解决命名冲突\n对类按功能进行分类，使项目组织更加清晰\n\n2. 面向对象2.1 与面向过程区别\n层次逻辑关系不同。\n面向对象是通过类的层次结构来体现类之间的继承与发展\n面向过程是通过模块的层次结构概括模块与模块间的关系与功能\n\n\n数据处理方式不同与控制程序方式不同\n面向对象是数据与操作封装成一个整体，通过事件驱动来激活和运行程序\n面向过程是数据单独存储，控制程序方式上按照设计调用或返回程序\n\n\n\n2.2 特性\n抽象\n继承\n多态\n封装\n\n2.3 这种开发方式优点\n开发效率高。代码重用\n保证软件的鲁棒性。经过长期测试的已有代码\n保证软件的高可维护性。设计模式成熟\n\n2.4 继承\n单继承\n只能继承父类的非私有成员变量和方法\n同名成员变量，子类覆盖，不会继承\n相同函数签名，子类覆盖，不会继承\n\n2.5 组合和继承区别\n组合：在新类中创建原有类的对象。has a\n继承是    is a\n\n2.6 多态\n方法重载\n编译时多态\n\n\n方法覆盖\n运行时多态\n\n\n成员变量无多态概念\n\n2.7 覆盖和重载区别\n子父类关系，垂直；同类方法间关系，水平\n一对方法发生关系；多个方法发生关系\n参数列表相同；参数列表不同\n调用的方法根据对象的类型决定；根据调用时的实参表决定方法体\n\n2.8 抽象类与接口异同同\n\n不能被实例化\n接口的实现类实现了接口，抽象类的子类实现了方法，才能被实例化\n\n异\n\n接口只能定义方法，不能实现；抽象类可以有定义和实现\n接口需要被实现；抽象类需要被继承\n接口强调特定功能的实现；抽象类强调所属关系\n接口成员变量默认为 public static final，成员方法 public abstract\n抽象类变量默认 default，方法不能用 private、static、synchronized、native 修饰\n\n2.9 内部类\n静态内部类\nstatic 修饰\n只能访问外部类中的 static 数据\n\n\n成员内部类\n与实例绑定\n不可定义静态属性和方法\n外部实例化后，该内部类才能被实例化\n\n\n局部内部类\n代码块内\n不能被 public、protected、private 以及 static 修饰\n只能访问 final 局部变量\n\n\n匿名内部类\n无类名\n无构造函数，必须继承或实现其他类\n原则\n无构造函数\n无静态成员，方法和类\n不能是 public、protected、private、static\n只能创建匿名内部类的一个实例\nnew 后面有继承或实现\n特殊的局部内部类\n\n\n\n\n\n2.10 如何获取父类类名\n利用反射：obj.getClass().getSuperClass().getName()\n不使用 super.getClass() 原因：该方法在 Object 中为 final 与 native，子类不能覆盖，返回此 Object 运行时类\n\n2.11 this\n指向当前实例对象\n区分成员变量与方法形参\n\n2.12 super\n访问父类成员变量或方法\n子类同名会覆盖，访问父类只能通过 super\n子类构造函数需显示调用父类构造函数时，super() 必须为构造函数的第一条语句\n\n3. 关键字3.1 变量命名\n英文字母\n 数字\n _和$\n 不能包含空白字符\n 首字符不能为数字\n 保留字不能做标识符\n 区分大小写\n\n3.2 assert\n软件调试 \n运行时开启        -ea\n\n3.3 static\n特定类的统一存储空间，类绑定\n成员变量：属于类，内存中只有一个复制\n成员方法：调静态数据。可实现单例模式\n代码块：初始化静态变量，只被执行一次\n内部类：不能与外部类重名，只能访问外部类静态数据(包括私有)\n\n3.4 switch\n多分支选择\n整型或字符类型变量或整数表达式\nJava 7 开始支持 String。原理是 String 的 hashCode() 返回的 int 类型值匹配\n\n3.5 volatile\n保证线程间的可见性\n从内存中取数据，而不是缓存\n不保证原子性\n\n3.6 instanceof\n二元运算符\n判断一个引用类型的变量所指向的对象是否是一个类的实例\n即左边对象是否是右边类的实例\n\n3.7 strictfp\n精确浮点\n确保浮点运算的准确性\n若不指定，结果依赖于虚拟机平台\n指定后依赖于统一标准，保证各平台的一致性\n\n3.8 null\n不是合法的 Object 实例\n无内存\n表明该引用目前没有指向任何对象\n\n4. 基本类型与运算4.1 基本数据类型\nint长度\nbyte(8 bit)\nshort(16 bit)\nint(32 bit)\nlong(64 bit)\n\n\nfloat长度\n单精度(32 bit float)\n双精度(64 bit double)\n\n\nboolean 类型变量的取值\ntrue\nfalse\n\n\nchar数据类型:Unicode字符(16 bit)\nvoid:java.lang.Void 无法直接对其进行操作\n\n4.2 不可变类\n实例创建后，值不可变\n所有的基本类型的包装类+String\n优点\n使用简单\n线程安全\n节省内存\n\n\n缺点:会因为值的不同而产生新的对象，导致无法预料的问题\n\n4.3 类型转换\n隐式类型转换\n\n低精度到高精度\nbyte-&gt;short-&gt;char-&gt;int-&gt;long-&gt;float-&gt;double\n\n\n显式类型转换\n\n反之\n可能会损失精度\n\n\n类型自动转换\n\n低到高\nchar 类型会转换为其对应的 ASCII 码\nbyte、char、short 参与运算自动转为 int，但”+=”，不转\n基本数据类型与 boolean 不能相互转换\n多种类型混合运算，自动转成容量最大类型\n\n\n运算符优先级\n  点    ()    []\n  ​    +(正)    -(负)        ++    –    ~    !  ​    *    /    %  ​    +(加)    -(减)  ​    &lt;&lt;    &gt;&gt;    &gt;&gt;&gt;  ​    &lt;    &lt;=    &gt;    &gt;=    instanceof  ​    ==    !=  ​    &amp;  ​    |  ​    ^  ​    &amp;&amp;  ​    ||  ​    ?:  ​    =    +=    -=    *=    /=    %=    &amp;=       |=    ^=    ~=    &lt;&lt;=    &gt;&gt;=    &gt;&gt;&gt;=\n\n\n5. 字符串与数组5.1 字符串创建与存储机制\n堆\n常量池\nnew String(“abc”) 创建 1 个或 2 个对象\n\n5.2 ==、equals和hashCode区别\n ==    比较引用，内存\n 未覆盖，同 ==；比较内容\n hashCode鉴定对象是否相等，返回整数\n\n5.3 String,StringBuffer,StringBuilder\nString:不可变，执行效率最低\nStringBuffer:可修改，线程安全，效率较高\nStringBuilder:可修改，线程不安全，效率最高\n\n5.4 其他\n数组初始化方式\nlength 属性和 length() 方法\n\n6. 异常处理6.1 finally 块执行时机\n若 try 中有 return，在 return 前\n若 try-finally 或 catch-finally 中都有 return，finally 会覆盖\n\n6.2 finally 代码块不是一定会被执行\n程序进入try之前出现异常\ntry 中调用System.exit(0)\n\n6.3 Error严重错误，不可恢复\n6.4 Exception\n可恢复，编译器可捕捉\n检查性异常\nIO\nSQL\n\n\n运行时异常\nJVM处理\nNullPointException\nClassCastException\nArrayIndexOutOfBoundsException\n\n\n出现异常后，一直往上层抛，直到遇到处理代码或最上层\n多态。若先捕获基类，再捕获子类。子类处理代码将永远不会得到执行\n\n7. Java 平台与内存管理7.1 Java 平台与其他语言平台的区别\n纯软件，包括 JVM 与 JAVA API\nJVM 虚拟，不跨平台\n\n7.2 JAVA 代码的执行\n代码编译为 class：sun jdk 中 javac\n装载 class：ClassLoader\n执行 class\n解释执行\n编译执行\nclient compiler\nserver compiler\n\n\n\n\n\n7.3 java 源码编译机制\n词法分析器组件：Token 流\n语法分析器组件：语法树\n语义分析器组件：注解语法树\n将语法树中的名字、表达式等元素与变量、方法、类型等联系到一起\n检查变量使用前是否已声明\n推导泛型方法的类型参数\n检查类型匹配性\n进行常量折叠\n检查所有语句都可到达\n检查变量的确定性赋值\n解除语法糖\n将泛型 JAVA 转成普通 Java\n检查所有 checked exception 都被捕获或抛出\n将含语法糖的语法树转成简单语法树 eg:foreach，自动折叠\n\n\n代码生成器组件：字节码\n\n7.4 类加载机制\n装载：全限定名+类加载器加载类\n链接\n校验\n格式不符，抛 VerifyError\n加载引用的类失败：抛 NoClassDefFoundError\n\n\n准备：静态变量默认初始化\n解析：属性、方法验证(可选)\n\n\n初始化(不是类加载必须触发的)\n静态初始化代码\n构造器代码\n静态属性初始化\n触发时机\n调用了 new\n反射调用了类中的方法\n子类调用了初始化\nJVM 启动过程中指定的初始化类\nBootstrap Class Loader：$JAVA_HOME/jre/lib/rt.jar\nExtension Class Loader：$JAVA_HOME/jre/lib/ext/*.jar\nSystem Class Loader：$CLASSPATH\nUser Defined Class Loader\n\n\n\n\n\n\n\n7.5 类执行机制\n解释执行\n\nJVM 字节码为中间代码，由 JVM 在运行期对其解释并执行\ninvokestatic\ninvokevirtual\ninvokeinterface\ninvokespecial\n\n\n基于栈\n代码紧凑，体积小\n线程创建后，产生 PC 和 Stack\n指令解释执行\n栈顶缓存：栈顶值缓存在寄存器上\n部分栈帧共享\n\n\n\n\n编译执行\n\nclient compiler\n轻量级，占内存少\n方法内联\n去虚拟化\n冗余消除\n\n\nserver compiler\n重量级，占内存多\n逃逸分析是 C2 进行很多优化的基础\n标量替换：用标量替换聚合量\n栈上分配\n若对象未逃逸，C2 会选择在栈上直接创建Point对象实例，而不是在堆上\n栈上分配更快速，对象易回收\n\n\n同步消除：如果发现同步的对象未逃逸，那也没有同步的必要。C2 会去掉同步代码块\n\n\n\n\n\n7.6 内存空间\n方法区：类信息，线程共享\n堆\n对象实例+数组\n分代管理\n新生代\n旧生代\n\n\n\n\n本地方法栈：支持 native 方法，Sun JDK 的实现中本地方法栈和 JVM 方法栈是同一个\nPC 寄存器：线程私有\nJVM 方法栈：线程私有\n\n7.7 内存分配\nJava 对象，堆上分配，分配需加锁，开销大\n当堆上空间不足–&gt;GC–&gt;仍不足–&gt;抛 OutOfMemory\nSun JDK 为新创建的线程在 Eden 上分配 TLAB\n多个小对象比大对象分配更高效\n基于逃逸分析直接从栈上分配\n\n7.8 内存回收\n收集器\n引用计数收集器\n计数器增减有消耗\n不适合循环引用\n\n\n跟踪收集器\n集中式管理\n全局记录数据的引用状态\n从根集合扫描对象，可能会造成应用程序暂停\n三种实现算法\n复制\n适用于回收空间中存活对象较少\n缺点：需要增加一块空的内存空间及进行对象的移动\n\n\n标记-清除：会产生内存碎片\n标记-压缩：不产生内存碎片\n\n\n\n\n\n\nSun JDK 中可用 GC\n新生代\n串行 GC(Serial GC)：复制算法\nMinor GC\n强软弱虚\n\n\n并行回收 GC(Parrallel Scavenge)：扫描复制多线程\n并行 GC(ParNew)：配合旧生代 CMS\n\n\n旧生代和持久代可用GC\n串行：标记压缩+清除\n并行：标记压缩\n并发：CMS\n标记：暂停\n并发标记：恢复，轮询着色对象，以标记它们\n重新标记：暂停\n并发收集：恢复\n\n\nCMS 内存回收易产生碎片，但是它提供了整理碎片的功能\n浮动垃圾：CMS 回收时产生应该回收但要等到下次 CMS 才能被回收掉的对象\n\n\n\n\nFull GC\n对新生代旧生代及持久代都进行的 GC\n触发的四种情况\n旧生代空间不足\n持久代空间满\nCMS GC 出现 promotion failed 和 concurrent mode failure\n统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间\n\n\n\n\n\n7.9 内存泄露\n一个不再被程序使用的对象或变量还在内存中占有存储空间\n符合垃圾回收标准\n对象赋空值 null\n给对象赋予新值，重新分配了内存空间\n\n\n泄露的两种情况\n堆中申请的空间没有被释放\n对象不再被使用，但仍然存活在内存中\n\n\n泄露原因\n静态集合类\n各种连接\n监听器\n变量不合理的作用域\n单例模式\n\n\n\n8. 分布式 Java 应用8.1 基于消息方式实现系统间的通信\nTCP/IP+BIO\nsocket.setSoTimeOut() 设置等待响应的超时时间\n一连接一线程\n缺点：无论连接是否真实，都要创建线程\nBIO下服务器端所能支撑的连接数目有限\n\n\nTCP/IP+NIO\nChannel\nSocketChannel：建立连接，监听事件，操作读写\nServerSocketChannel：监听端口，监听连接事件\n\n\nSelector：获取是否要处理的事件\nBuffer：存放处理的数据\nNIO    Reactor 模式，通过注册感兴趣的事件及扫描是否有感兴趣的事件发生，从而做出相应的动作\n多个请求，连接复用\n只有在有真实的请求时，才会创建线程\n一请求一线程\n\n\nUDP/IP+BIO\nDatagramSocket：负责监听端口，读写数据\nDatagramPacket：作为数据流对象进行传输\n\n\nUDP/IP+NIO\nDatagramChannel：监听端口，进行读写\nByteBuffer：数据流传输\n\n\nNIO好处：只在有流要读取或可写入流时才做出相应的 IO 操作，而不像 BIO 方式阻塞当前线程\n\n8.2 基于远程调用方式实现系统间的通信\n远程调用方式\n系统间通信和系统内一样\n让使用者感觉调用远程同调用本地一样\n\n\n基于 Java 自身技术\nRMI：客户端代理，stub，封装对象，序列化为流，TCP/IP BIO，Skeleton，反序列化，获取对象实例，调用\nWebService\n服务端的服务生成 WSDL 文件\n将应用+WSDL 文件放入 HTTP 服务器\n借用 Java 辅助工具根据 WSDL 文件生成客户端 stub 代码\nstub 将产生的对象请求信息封装为标准化的 SOAP 格式数据，并发请求到服务器端\n服端在接收到 SOAP 格式数据时进行转化，反射调用相应的 Java 类\nSOAP 优点支持跨语言，缺点对复杂对象结构难支持\n\n\n\n\n\n8.3 基于开源框架\nSpring RMI\n\n9. 多线程9.1 线程资源同步机制\nJVM 保证以下操作顺序\n同一线程操作\n对于 main Memory 上的同一个变量的操作\n对于加了锁的 main Memory 上的对象操作\n\n\n为避免资源操作的脏数据问题，JVM 提供了\nsynchronized\nvolatile\nlock/unlock\n目的是控制资源竞争\n\n\n\n9.2 线程交互机制\n基于 Object 的 wait/notify/notifyAll\n为避免假唤醒，需要 double check\n调用对象的 wait–&gt;wait sets—&gt;释放锁—&gt;其他线程 notify—-&gt;wait sets—-&gt;执行此对象线程—&gt;删除 sets中此线程\n\n\n基于 JDK 5 并发包，支持线程交互\nSemphore 的 acquire，release\nCondition 的 await，signal\nCountDownLatch 的 await 和 countDown\n\n\n\n9.3 线程状态\nNew\nRunnable \nRunning\nWait\nTimedWait\nBlocked\nTerminated\n\n9.4 sleep() 与 wait() 方法的区别\nsleep\n暂停一段时间执行\nThread 的静态方法\n不释放锁\n需要捕获异常\n\n\nwait\n使线程暂停执行\nObject 方法，用于线程间通信\n释放锁\n\n\n\n9.5 守护线程\n后台提供服务\n用户线程全部终止，只剩下守护线程时，JVM 就会退出\n调用 start() 之前，调用线程对象的 setDaemon(true)\n\n9.6 join\n调用该方法的线程在执行完 run() 后，再执行 join 方法后面的代码\n线程合并，实现同步功能\n\n10. IO10.1 流本质\n数据传输\n\n10.2 流分类\n字节流:不使用缓存\n字符流\n码表映射\n使用缓存\n\n\n\n10.3 装饰者模式\n运行时动态给对象增加额外的职责\n是你还有你，一切拜托你\nFilterInputStream\n\n10.4 Java Socket\nServerSocket server = new ServerSocket(2000);\nSocker socket = server.accept();\n客户端：Socket socket = new Socket(“localhost”,2000);\n\n10.5 NIO\nChannel–Selector–Buffer\n反应器模式\n\n10.6 序列化\n对象持久化方式\n解决在对对象流进行读写操作时引发的问题\n对象写进流里进行网络传输，保存到文件，数据库\n\n10.7 如何实现序列化\n实现 Serializable 接口\n使用 FileOutputStream 来构造 ObjectOutputStream 对象\n使用该对象的 writeObject(obj) 方法将对象写出\n要恢复时，使用对应的输入流\n\n10.8 序列化特点\n一个类能被序列化，它的子类也能被序列化\nstatic 代表类成员，transient 代表临时数据。均不能被序列化\n序列化影响性能，需要才使用\n需要通过网络来发送对象，或对象的状态需要被持久化到数据库或文件中\n序列化能实现深复制，即可以复制引用的对象\n\n10.9 反序列化\n将流转化为对象\nUID 最好自己定义。优点\n提高程序运行效率。省去计算过程\n提高程序不同平台兼容性。不同计算方式，反序列化失败\n增强程序各个版本的可兼容性。加入新属性，默认UID变化\n\n\n\n10.10 外部序列化\n实现 Externalizable 接口控制\n\n\n\n\n\n\n","categories":["夯实基础系列"],"tags":["Java","基础"]},{"title":"并发包之 CopyOnWriteArrayList","url":"https://java4u.cn/Java/Java/并发包之CopyOnWriteArrayList/","content":"CopyOnWriteArrayList实现　　线程安全， 读时无锁。\nCopyOnWriteArrayList()　　大小为 0 的数组\nadd(E)\n\n　　无 synchronized 关键字\n　　用 ReentrantLock \n　　新数组 newlen = len + 1\n　　新对象放结尾\n　　引用切换\nremove(E)　　ReentrantLock 保证线程安全\n　　新数组 newLen = len - 1\n　　遍历 newLen 长度\n\n若找到 equal ，后边元素前移，，引用切换，返回true\n未找到，单个赋值给新数组\n\n　　特殊处理最后一个元素\n\n是否 equal ，是，删，引用切换，返回true\n否，返回 false\n\n　　与 ArrayList 相比，锁不同，复制没有调用 System.arrayCopy ，性能有下降\nget(int)　　直接获取， 无锁保护\n　　可能 脏数据 ，性能高\n　　适合写少读多且脏数据影响不大\niterator()　　创建 CowIterator ，并保存当前数据的快照，不抛异常\n总结\nCopyOnWriteArrayList 基于 ReentrantLock\n保证增加、删除互斥\n读不上锁， 保证读的性能\n副作用：脏数据\n\n","categories":["Java"],"tags":["Java","分布式","并发","集合"]},{"title":"并发包之ConcurrentHashMap","url":"https://java4u.cn/Java/Java/并发包之ConcurrentHashMap/","content":"概述并发包包括：\n\n高性能的线程安全的集合对象\n原子操作类\n避免并发时资源冲突的的Lock及Condition\n\nConcurrentHashMap实现方式\n\n　　线程安全的HashMap实现\nConcurrentHashMap(initialCapacity , loadfactor, concurrencyLevel)　　参数默认 initialCapacity 为 16，loadfactor 为 0.75， concurrencyLevel 为16\n　　基于以下方式计算 ssize\nint sshift = 0;\nint ssize = 1;\nwhile(ssize &lt; concurrencyLevel)&#123;\n    ++sshiftl;\n    ssize &lt;&lt;= 1;\n&#125;\n　　在 concurrencyLevel 为 16 的情况下，最终计算出的 ssize 为 16，并使用此 ssize 作为参数传入 Segment 的 newArray 方法，创建大小为 16 的 Segment 对象数组，接着采用如下方法计算 cap 变量的值：\nint c = initialCapacity / ssize;\nif(c * ssize &lt; initialCapacity)\n    ++c;\nint cap = 1;\nwhile(cap &lt; c)\n    cap &lt;&lt;= 1;\nput(key, value)　　没加 synchronized 关键字\n　　\n\n判断 value 是否为 null\n\n是，抛异常\n否，根据 key 的 hashCode 获取 Segment，调用 Segment 的 put\nlock\n个数 +1，判断 threshold\n若超过大小，扩大两倍，重 hash，转移\n\n\n\n\n接下来与 HashMap 一致\n\nhash 值与数组长度 -1 按位与，得到位置，\n有相同 key 覆盖 value\n无，建新 HashEntry，赋值给对应位置，构成链表，释放锁\n\n\n\n\n\n　　默认允许 16 个线程并发无阻塞操作集合对象，尽可能减少并发时的阻塞现象\nremove(Object key)　　key.hash ——&gt; Segment ——&gt; 调用 remove\n\nremove 加锁，hash 值和数组大小 -1 按位与，得到位置，遍历对象及 next对象，找到和传入的 hash 值相等的 hash值，以及 key 和传入的 key equals 的对象。\n\n未找到，返回null\n找到，重建删除元素之前的 HashEntry\n\n\n释放锁\n\n\nget(Object key)　　hash ——&gt; Segment ——&gt; 调 get\n\nget 判断对象数组是否为 0\n是，返回 null\n否，hash 与 len - 1 按位与，获得 HashEntry，遍历，找 hash 等及 key equal 的对象\n若找到，\n若 value 为 null，调 readValueUnderlock\nlock\n返回 value\n释放锁\n\n\n该步骤，防止了并发读到默认值\n若 value 不为 null ，返回 value\n\n\n\n\n\n\n\n\n仅寻找到对象 value 为 null 时，才上锁，即在读数据时，大部分情况下没有才用锁\n\n\n对象数组变量 volatile，对象数组大小发生改变，读操作可看到最新数组大小。\n\ncontainsKey(Object key)　　同 get，没加锁\nkeySet().interator()　　不加锁，不抛异常\n\n---\n\n\n","categories":["Java"],"tags":["Java","分布式","并发","集合"]},{"title":"集合包之Map","url":"https://java4u.cn/Java/Java/集合包之Map/","content":"HashMap\nHashSet()\n\nloadFactor默认0.75，threshold为12\n\n并创建一个大小为16的Entry对象数组\n\n可调用另外两个构造器控制初始容量值，loadFactor\n\n数组大小由如下决定：\n  int capacity = 1;\n  while(capacity &lt; initialCapacity)\n      capacity &lt;&lt;= 1;\n\ncapacity才是创建的Entry对象数组的大小，new HashMap(5,0.6)，则设loadFactor为0.6，并创建一个大小为8的Entry对象数组，threshold则为4( 8 * 0.6 = 4 )\n\n\n\n\n\n\n\nput(key, value)\n\nkey为null,获取第一个Entry对象，并基于Entry的next遍历\n找到key为null，更新value，返回\n未找到，增加Entry。\n增加时获取数组首个Entry：e，并创建Entry对象，key为null，value为传入对象，next为e。\n若数组len &gt;= threshold，扩容为2倍，扩容前对所有元素重新hash，并填充数组，最后重设置threshold。\n\n\n\n\nkey不为null，获取key的hashCode，然后再对此hashCode作hash操作，hash完成后，将hash值与对象数组len按位与，得到key要存储的数组位置。\nhash冲突：不同key找到相同存储位置，通过调用Entry对象next遍历链表的方式。\n\n\n\n\nget(Object key)\n\n与put一样，根据key是否为null分别处理\nkey为null –&gt; 首个Entry –&gt; next遍历\nkey非null –&gt; hash和按位与 –&gt; 找到位置 –&gt; 找到Entry –&gt; next遍历\n\n\n\n\nremove(Object key)\n\n类似get，找到key,当前元素更新为next元素\n未找到，遍历链表\n\n\ncontainsKey(key)\n\n调用getEntry，与get基本相同，返回是否为null\n\n\nkeySet()\n\n用来遍历Map对象，返回KeySet对象实例\n调用iterator返回keyIterator，遍历中有增删会抛异常\n\n\n\nHashMap要点\nHashMap采用数组方式存储key,value构成的Entry对象，无容量限制\nHashMap基于key hash寻找Entry对象存放到数组的位置，对hash冲突采用链表的方式来解决\n插入扩容，扩容时重hash，并复制对象到新的数组中\n非线程安全\n\nTreeMap\n实现\n\n支持排序的Map实现，不同于HashMap\n\n\nTreeMap()\n\n将comparator属性为null，若希望控制存储顺序，使用带Comparator参数的构造器\n\n\nput(key, value)\n\n判断root是否为null\n是，建新Entry，并赋给root\n否，判断有无实现Comparator\n有，红黑树遍历key，相等替换，不等找到null为止\n未找到相同的key，创建新的Entry，将其parent设置成上面所寻找到的元素并根据和parent key比较的情况来设置parent的left或right属性\n\n\n无，判断key是否为null\n是，1.抛NullPointerException，2.并将key造型为Comparable，进行与上面相同过程\n否，执行2\n\n\n\n\n\n\n\n\n\n\n基于红黑树实现，一定要有key比较，要么传入Comparator实现，要么key对象实现Comparable接口\n\n\nget(Object)\n\n红黑树查找，从根开始往下比，一直找到等key，返回其value\n和put同样的处理方式，如未传入Comparator实现，当传入的Object为null，抛异常\n\n\nremove(O)\n\ngetEntry，并将Entry从红黑树上删除，并重新调整树上的相关结点。\n\n\ncontainsKey(O)\n\n同getEntry，但containsKey直接判断返回的Entry是否为null\n\n\nKeySet()\n\n返回TreeMap的内部类KeySet对象的实例，iterator的遍历从根开始，基于红黑树顺序完成。\n\n\n\nTreeMap要点\nTreeMap基于红黑树实现，无容量限制\nTreeMap非线程安全\n\n小结各集合类适用场景List          重复\nSet            不重复\nMap            key-value\nArrayList    通过位置读\nLinkedList    头尾操作及插入指定位置\nVector        线程安全的ArrayList\nStack        线程安全的LIFO\nHashSet        对排序无要求的非重复\nTreeSet        要排序的非重复\nHashMap        key-value存取\nTreeMap        排序，key-value\n\n\n","categories":["Java"],"tags":["Java","分布式","集合","Map"]},{"title":"集合包之Set","url":"https://java4u.cn/Java/Java/集合包之Set/","content":"HashSet\n实现：\n\n为了不允许元素重复，基于HashMap实现\n\n\nHashSet()\n\n创建HashMap对象\n\n\n\n\nadd(E)\n调用map的put(O,O)，需要增加的元素作为map中的key，value传入一个已创建的final Object对象\n\n\n\n\n\n\nremove(E)\n\n调用map的remove(E)\n\n\ncontains(E)\n\n调用map.containsKey(E)\n\n\niterator()\n\n调用map.keySet的iterator方法\n\n\n\n\nHashSet不支持get(int)获取指定位置的元素，只能自行通过iterator方法来获取\n\nHashSet要点\n基于HashMap实现，无容量限制\nHashSet是非线程安全\n\nTreeSet\n实现\n区别于HashSet支持排序，TreeSet基于TreeMap实现\n\n\n\n\nTreeSet()\n\n创建TreeMap对象\n\n\nadd(E)\n\n调用TreeMap.put(O,O)\n\n\nremove(E)\n\n调用TreeMap.remove(E)\n\n\niterator()\n\n调navigableKeySet的iterator方法\n\n\n\n\nTreeSet提供了排序方面的支持。例如，传入Comparator实现，descendingSet及descendingIterator实现\n\nTreeSet要点\n基于TreeMap实现，支持排序\nTreeSet是非线程安全的\n\n\n\n","categories":["Java"],"tags":["Java","分布式","集合","Set"]},{"title":"struts2中自定义拦截器","url":"https://java4u.cn/struts2/struts2/struts2中自定义拦截器/","content":"自定义拦截器\n自定义拦截器需要实现com.opensymphony.xwork2.interceptor.Interceptor接口 \n\nPermissionInterceptorpackage com.liuyong666.interceptor;\nimport com.opensymphony.xwork2.ActionContext;\nimport com.opensymphony.xwork2.ActionInvocation;\nimport com.opensymphony.xwork2.interceptor.Interceptor;\n\npublic class PermissionInterceptor implements Interceptor &#123;\n\n    public void destroy() &#123;\n    &#125;\n\n    public void init() &#123;\n    &#125;\n\n    public String intercept(ActionInvocation invocation) throws Exception &#123;\n        Object user = ActionContext.getContext().getSession().get(&quot;user&quot;);\n        if(user!=null) return invocation.invoke(); //如果user不为null,代表用户已经登录,允许执行action中的方法\n        ActionContext.getContext().put(&quot;message&quot;, &quot;你没有权限执行该操作&quot;);\n        return &quot;success&quot;;\n    &#125;\n&#125;\nstruts.xml&lt;package name=&quot;employee&quot; namespace=&quot;/control/employee&quot; extends=&quot;struts-default&quot;&gt;\n    &lt;interceptors&gt;\n        &lt;interceptor name=&quot;permission&quot; class=&quot;com.liuyong666.interceptor.PermissionInterceptor&quot;/&gt;\n        &lt;interceptor-stack name=&quot;permissionStack&quot;&gt;\n            &lt;interceptor-ref name=&quot;defaultStack&quot;/&gt;\n            &lt;interceptor-ref name=&quot;permission&quot; /&gt;\n        &lt;/interceptor-stack&gt;\n    &lt;/interceptors&gt;\n    &lt;global-results&gt;\n        &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/message.jsp&lt;/result&gt;\n    &lt;/global-results&gt;\n    &lt;action name=&quot;list_*&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot; method=&quot;&#123;1&#125;&quot;&gt;\n        &lt;interceptor-ref name=&quot;permissionStack&quot; /&gt;\n    &lt;/action&gt;\n&lt;/package&gt;\n注意\n因为struts2中如文件上传，数据验证，封装请求参数到action等功能都是由系统默认的defaultStack中的拦截器实现的，所以我们定义的拦截器需要引用系统默认的defaultStack，这样应用才可以使用struts2框架提供的众多功能。\n如果希望包下的所有action都使用自定义的拦截器，可以通过把拦截器定义为默认拦截器。注意：每个包只能指定一个默认拦截器。另外，一旦我们为该包中的某个action显式指定了某个拦截器，则默认拦截器不会起作用。\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2"]},{"title":"struts2中多文件上传","url":"https://java4u.cn/struts2/struts2/struts2中多文件上传/","content":"多文件上传导包　　在WEB-INF/lib下加入commons-fileupload-1.2.1.jar、commns-io-1.32.2.jar\n表单设置&lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/control/employee/list_execute.action&quot; enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;  \n    文件1:&lt;input type=&quot;file&quot; name=&quot;image&quot;&gt;&lt;br/&gt;  \n    文件2:&lt;input type=&quot;file&quot; name=&quot;image&quot;&gt;&lt;br/&gt;  \n    文件3:&lt;input type=&quot;file&quot; name=&quot;image&quot;&gt;&lt;br/&gt;  \n    &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;  \n&lt;/form&gt;  \nAction类public class HelloWorldAction &#123;  \n    private File[] image; //得到上传文件  \n    private String[] imageFileName; //得到文件的名称  \n    private String[] imageContentType; //得到文件的类型  \n    public File[] getImage() &#123;  \n        return image;  \n    &#125;  \n\n    public void setImage(File[] image) &#123;  \n        this.image = image;  \n    &#125;  \n\n    public String[] getImageFileName() &#123;  \n        return imageFileName;  \n    &#125;  \n\n    public void setImageFileName(String[] imageFileName) &#123;  \n        this.imageFileName = imageFileName;  \n    &#125;  \n\n    public String[] getImageContentType() &#123;  \n        return imageContentType;  \n    &#125;  \n\n    public void setImageContentType(String[] imageContentType) &#123;  \n        this.imageContentType = imageContentType;  \n    &#125;  \n    public String execute() throws Exception&#123;  \n        String realpath = ServletActionContext.getServletContext().getRealPath(&quot;/images&quot;);  \n        if(image!=null)&#123;  \n            File savedir = new File(realpath);  \n            if(!savedir.exists()) savedir.mkdirs();  \n            for(int i = 0 ; i&lt;image.length ; i++)&#123;                 \n                File savefile = new File(savedir, imageFileName[i]);  \n                FileUtils.copyFile(image[i], savefile);  \n            &#125;  \n            ActionContext.getContext().put(&quot;message&quot;, &quot;上传成功&quot;);  \n        &#125;  \n        return &quot;success&quot;;  \n    &#125;  \n&#125;  \n\n注意：image属性要和form表单上传控件名称要一致\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2"]},{"title":"struts2中文件上传","url":"https://java4u.cn/struts2/struts2/struts2中文件上传/","content":"文件上传步骤\n在WEB-INF/lib下加入conmmons-fileupload-1.2.1.jar、commons-io.1.3.2.jar。如果使用的struts.jar文件时2.1以上的这一步可以省略。但是如果想使用FileUtils类，还需要添加commons-io.1.3.2.jar包\n\n把form表的enctype设置为：“multipart/form-data”,如下：\n  &lt;form action=&quot;$&#123;pageContext.request.contextPath&#125;/hello/test/user_upload.action&quot;   enctype=&quot;multipart/form-data&quot; method=&quot;post&quot;&gt;\n     文件:&lt;input type=&quot;file&quot; name=&quot;uploadImage&quot;/&gt;\n     &lt;input type=&quot;submit&quot; value=&quot;上传&quot;/&gt;\n   &lt;/form&gt;\n\n“在Action类中添加如下属性：”\n  public class FileUploadAction &#123;\n      private File uploadImage; //得到上传文件\n      private String uploadImageFileName;//得到文件的名称\n\n      set... get....\n\n      public String upload() throws Exception&#123;\n\n          String realPath = ServletActionContext.getServletContext().getRealPath(&quot;/images&quot;);\n            System.out.println(realPath);\n\n            if(uploadImage!=null)&#123;\n                 File savefile = new File(new File(realPath),uploadImageFileName);\n                 if(!savefile.getParentFile().exists())&#123;\n                  //判断路径是否存在，不存在则创建\n                      savefile.getParentFile().mkdirs();//表示创建多级路径，mkdir()表示单级路径\n                &#125;\n             FileUtils.copyFile(uploadImage, savefile);\n             //表示把源文件拷贝到目标文件\n             ActionContext.getContext().put(&quot;message&quot;, &quot;文件上传成功&quot;);\n            &#125;\n            return &quot;success&quot;;\n      &#125;\n  &#125;\n\n\n注意\njsp页面的属性必须和action中上传的属性一致。\n上传文件名变量的定义是有规则的。规则如下：上传的文件+FileName。\n另外struts2默认上传文件大小限制是2M左右，若想调节大小，可以再struts.xml文件中通过常量调节，比如：\n现在跳到10M左右\n但是最好别调的太大，太大了理论上可以上传，但是容易中断。\n若想实现可以通过socket编程实现超大文件上传。\n\n\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2"]},{"title":"使用Spring配置文件实现事务管理","url":"https://java4u.cn/spring/spring/使用Spring配置文件实现事务管理/","content":"PersonServiceBeanpackage com.liuyong666.service.impl;\nimport java.util.List;\nimport javax.sql.DataSource;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\nimport com.liuyong666.bean.Person;\nimport com.liuyong666.service.PersonService;\n\n\npublic class PersonServiceBean implements PersonService &#123;\n    private JdbcTemplate jdbcTemplate;\n\n    public void setDataSource(DataSource dataSource) &#123;\n        this.jdbcTemplate = new JdbcTemplate(dataSource);\n    &#125;\n\n    public void delete(Integer personid)&#123;\n        //第二个语句sql故意插入错误语法，若为同一个事务，第一个语句会回滚，执行失败\n        jdbcTemplate.update(&quot;delete from person where id=?&quot;, new Object[]&#123;personid&#125;,\n                new int[]&#123;java.sql.Types.INTEGER&#125;);\n        jdbcTemplate.update(&quot;delete from persons where id=3&quot; );\n    &#125;\n\n    public Person getPerson(Integer personid) &#123;        \n        return (Person)jdbcTemplate.queryForObject(&quot;select * from person where id=?&quot;, new Object[]&#123;personid&#125;, \n                new int[]&#123;java.sql.Types.INTEGER&#125;, new PersonRowMapper());\n    &#125;\n\n\n    @SuppressWarnings(&quot;unchecked&quot;)\n    public List&lt;Person&gt; getPersons() &#123;\n        return (List&lt;Person&gt;)jdbcTemplate.query(&quot;select * from person&quot;, new PersonRowMapper());\n    &#125;\n\n    public void save(Person person) &#123;\n        jdbcTemplate.update(&quot;insert into person(name) values(?)&quot;, new Object[]&#123;person.getName()&#125;,\n                new int[]&#123;java.sql.Types.VARCHAR&#125;);\n    &#125;\n\n    public void update(Person person) &#123;\n        jdbcTemplate.update(&quot;update person set name=? where id=?&quot;, new Object[]&#123;person.getName(), person.getId()&#125;,\n                new int[]&#123;java.sql.Types.VARCHAR, java.sql.Types.INTEGER&#125;);\n    &#125;\n&#125;\nXML配置\n由于我们要拦截PersonServiceBean中的方法，因此我们需要在配置文件中配置信息，在配置文件中使用了AOP技术来拦截方法。\n      &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n           &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n      &lt;/bean&gt;\n\n      &lt;aop:config&gt;\n            &lt;aop:pointcut id=&quot;transactionPointcut&quot; expression=&quot;execution(* com.liuyong666.service..*.*(..))&quot;/&gt;\n            &lt;aop:advisor advice-ref=&quot;txAdvice&quot; pointcut-ref=&quot;transactionPointcut&quot;/&gt;\n      &lt;/aop:config&gt; \n      &lt;tx:advice id=&quot;txAdvice&quot; transaction-manager=&quot;txManager&quot;&gt;\n            &lt;tx:attributes&gt;\n              &lt;tx:method name=&quot;get*&quot; read-only=&quot;true&quot; propagation=&quot;NOT_SUPPORTED&quot;/&gt;\n              &lt;tx:method name=&quot;*&quot;/&gt;\n            &lt;/tx:attributes&gt;\n      &lt;/tx:advice&gt;    \n\n      &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n          &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n      &lt;/bean&gt;\n\n这样spring就能对这个类进行事务管理。\n\n\n测试数据库操作是否在同一事务中执行public void delete(Integer personid)&#123;\n    //第二个语句sql故意插入错误语法，若为同一个事务，第一个语句会回滚，执行失败\n    jdbcTemplate.update(&quot;delete from person where id=?&quot;, new Object[]&#123;personid&#125;,\n            new int[]&#123;java.sql.Types.INTEGER&#125;);\n    jdbcTemplate.update(&quot;delete from persons where id=3&quot; );\n&#125;\n\n在第二条删除语句中，persons 表是不存在的\n如果两次update语句是在两个事务中执行，则第一条能成功执行，并且数据库中该id的记录已经被删除，而第二条由于不存在该表不能正常删除。\n如果在同一事务中执行，由于第二条update出错，数据库中不能删除任何记录。\n\n\n\n测试结果@Test\npublic void delete()&#123;\n    personService.delete(2);\n&#125;\n\n程序报错，同时id=2的记录没有被删除，这说明我们的事务配置成功。\n如果我们把配置文件中关于事务配置的信息给注释掉，再次测试，程序同样报错，但是id=2的记录被成功删除掉，这说明这两条update语句是在两个不同的事务中运行。\n\n\n在平时开发中，Spring团队建议使用注解的方式进行配置，这样配置文件显得精简，同时也会做到精确控制。 \n\n\n\n","categories":["spring"],"tags":["spring","ssh","事务"]},{"title":"struts2中访问或添加request等属性","url":"https://java4u.cn/struts2/struts2/struts2中访问或添加request等属性/","content":"访问或添加request/session/application属性\n在struts2中获得request，session，application有3种方法\n通过ServletActionContext类直接获取：此法比较常用\n实现指定接口，有struts框架运行时注入：实现的接口是ServletRequestAware，ServletResponseAware，ServletContextAware，此方法不常用。\n通过ActionContext类直接获取。此法较常用\n\n\n\n方法一，通过ServletActionContext类直接获取：public class TestAction &#123;\n     public String rsa()&#123;\n          HttpServletRequest request = ServletActionContext.getRequest();\n          ServletContext servletContext =  ServletActionContext.getServletContext();\n          request.setAttribute(&quot;req&quot;, &quot;请求范围属性&quot;);\n          request.getSession().setAttribute(&quot;ses&quot;, &quot;会话范围属性&quot;);\n          servletContext.setAttribute(&quot;app&quot;, &quot;应用范围属性&quot;);\n          return &quot;message&quot;;\n     &#125;\n&#125;\n方法三，通过ActionContext类直接获取：public class TestAction &#123;\n     public String execute()&#123;\n          ActionContext act = ActionContext.getContext();\n          act.getApplication().put(&quot;app&quot;, &quot;应用范围&quot;);\n          act.getSession().put(&quot;ses&quot;, &quot;session范围&quot;);\n          act.put(&quot;req&quot;,&quot;request范围&quot;);\n          act.put(&quot;names&quot;, Arrays.asList(&quot;小明&quot;,&quot;小敏&quot;,&quot;小李&quot;));\n          return &quot;message&quot;;\n     &#125;\n&#125;\nmessage.jsp页面&lt;body&gt;\n    $&#123;applicationScope.app&#125;&lt;br/&gt;\n    $&#123;sessionScope.ses&#125;&lt;br/&gt;\n    $&#123;requestScope.req &#125;&lt;br/&gt;\n    &lt;c:forEach items=&quot;$&#123;names &#125;&quot; var=&quot;name&quot;&gt;\n          $&#123;name &#125; &lt;br/&gt;\n    &lt;/c:forEach&gt;\n&lt;/body&gt;\nstruts.xml配置文件&lt;action name=&quot;user_*&quot; class=&quot;com.liuyong666.action.TestAction&quot; method=&quot;&#123;1&#125;&quot;&gt;\n      &lt;result name=&quot;message&quot;&gt;/message.jsp&lt;/result&gt;\n&lt;/action&gt;\n应用场景\n仅仅是访问或添加属性，用ActionContext\n\n需要额外获取路径等操作，用ServletActionContext\n  HttpServletRequest request = ServletActionContext.getRequest();\n  ServletContext servletContext =  ServletActionContext.getServletContext();\n  servletContext.getRealPath(&quot;xxx&quot;);\n\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2"]},{"title":"使用Spring注解方式管理事务与传播行为详解","url":"https://java4u.cn/spring/spring/使用Spring注解方式管理事务与传播行为详解/","content":"遇到异常事务是否会回滚\nSpring容器如果碰到运行期异常(uncheck exception)，也就是 RuntimeException 会回滚.\n  public void delete(Integer id) &#123;\n          jdbcTemplate.update(&quot;delete from person where id=?&quot;, new Object[]&#123;id&#125;,   \n                  new int[]&#123;java.sql.Types.INTEGER&#125;);\n\n          throw new RuntimeException(&quot;运行期例外&quot;);\n  &#125;\n  @Test\n  public void testDelete()&#123;   \n          ps.delete(1);   \n  &#125;   \n\n如果是用户定义的例外则不会回滚(check exception)，这个特性是默认的：\n  @Override\n  public void delete(Integer id) throws Exception &#123;\n      jdbcTemplate.update(&quot;delete from person where id=?&quot;, new Object[]&#123;id&#125;,   \n              new int[]&#123;java.sql.Types.INTEGER&#125;);\n  &#125;\n  @Test\n  public void testDelete()&#123;   \n      try &#123;\n          ps.delete(1);\n      &#125; catch (Exception e) &#123;\n          e.printStackTrace();\n      &#125;   \n  &#125; \n\n\n设置回滚的方式\n我们可以使用注解来改变回滚的默认方式：\n\n默认情况发生RuntimeException要回滚，改变为不回滚\n @Transactional(noRollbackFor=RuntimeException.class)\n public void delete(Integer personid) &#123;\n     jdbcTemplate.update(&quot;delete from person where id=?&quot;, new Object[]&#123;personid&#125;,\n             new int[]&#123;java.sql.Types.INTEGER&#125;);\n     throw new RuntimeException(&quot;运行期例外&quot;);\n &#125;\n\n发生非RuntimeException不回滚，改变为回滚\n @Transactional(rollbackFor=Exception.class)\n\n如果不希望业务方法开启事务，比如select等方法可以\n @Transactional(propagation=Propagation.NOT_SUPPORTED)\n\n设置事务的超时时间\n @Transactional(timeout=500)  /*依赖与底层数据库的实现*/\n\n\n\n\n事务的传播属性\nREQUIRED：业务方法需要在一个事务中运行。如果方法运行时，已经处在一个事务中，那么加入到该事务，否则为自己创建一个新的事务。\n\nNOT_SUPPORTED：声明方法不需要事务。如果方法没有关联到一个事务，容器不会为它开启事务。如果方法在一个事务中被调用，该事务会被挂起，在方法调用结束后，原先的事务便会恢复执行。\n\nREQUIRESNEW：属性表明不管是否存在事务，业务方法总会为自己发起一个新的事务。如果方法已经运行在一个事务中，则原有事务会被挂起，新的事务会被创建，直到方法执行结束，新事务才算结束，原先的事务才会恢复执行。\n\nMANDATORY：该属性指定业务方法只能在一个已经存在的事务中执行，业务方法不能发起自己的事务。如果业务方法在没有事务的环境下调用，容器就会抛出例外。\n\nSUPPORTS：这一事务属性表明，如果业务方法在某个事务范围内被调用，则方法成为该事务的一部分。如果业务方法在事务范围外被调用，则方法在没有事务的环境下执行。\n\nNever：指定业务方法绝对不能在事务范围内执行。如果业务方法在某个事务中执行，容器会抛出例外，只有业务方法没有关联到任何事务，才能正常执行。\n\nNESTED：如果一个活动的事务存在，则运行在一个嵌套的事务中. 如果没有活动事务, 则按REQUIRED属性执行.它使用了一个单独的事务， 这个事务拥有多个可以回滚的保存点。内部事务的回滚不会对外部事务造成影响。它只对DataSourceTransactionManager事务管理器起效。外部事务的回滚会导致整个事务的回滚。\n\n\n数据库系统提供了四种事务隔离级\n数据库系统提供了四种事务隔离级别供用户选择。不同的隔离级别采用不同的锁类型来实现，在四种隔离级别中，Serializable的隔离级别最高，Read Uncommited的隔离级别最低。大多数据库默认的隔离级别为Read Commited，如SqlServer，当然也有少部分数据库默认的隔离级别为Repeatable Read ，如Mysql\n\nRead Uncommited：读未提交数据(会出现脏读,不可重复读和幻读)。\nRead Commited：读已提交数据(会出现不可重复读和幻读)\nRepeatable Read：可重复读(会出现幻读)\nSerializable：串行化\n\n\n\n\n脏读：一个事务读取到另一事务未提交的更新新据。\n不可重复读：在同一事务中，多次读取同一数据返回的结果有所不同。换句话说就是，后续读取可以读到另一事务已提交的更新数据。相反，“可重复读”在同一事务中多次读取数据时，能够保证所读数据一样，也就是，后续读取不能读到另一事务已提交的更新数据。\n幻读：一个事务读取到另一事务已提交的insert数据。\n\n\n\n","categories":["spring"],"tags":["spring","ssh","注解","事务"]},{"title":"搭建和配置Spring与jdbc整合的环境","url":"https://java4u.cn/spring/spring/搭建和配置Spring与jdbc整合的环境/","content":"配置数据源  &lt;!-- 配置结点，可以使用占位符 --&gt;\n &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt;\n\n &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot; destroy-method=&quot;close&quot;&gt;\n    &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;driverClassName&#125;&quot;/&gt;\n    &lt;property name=&quot;url&quot; value=&quot;$&#123;url&#125;&quot;/&gt;\n    &lt;property name=&quot;username&quot; value=&quot;$&#123;username&#125;&quot;/&gt;\n    &lt;property name=&quot;password&quot; value=&quot;$&#123;password&#125;&quot;/&gt;\n     &lt;!-- 连接池启动时的初始值 --&gt;\n     &lt;property name=&quot;initialSize&quot; value=&quot;$&#123;initialSize&#125;&quot;/&gt;\n     &lt;!-- 连接池的最大值 --&gt;\n     &lt;property name=&quot;maxActive&quot; value=&quot;$&#123;maxActive&#125;&quot;/&gt;\n     &lt;!-- 最大空闲值.当经过一个高峰时间后，连接池可以慢慢将已经用不到的连接慢慢释放一部分，一直减少到maxIdle为止 --&gt;\n     &lt;property name=&quot;maxIdle&quot; value=&quot;$&#123;maxIdle&#125;&quot;/&gt;\n     &lt;!--  最小空闲值.当空闲的连接数少于阀值时，连接池就会预申请去一些连接，以免洪峰来时来不及申请 --&gt;\n     &lt;property name=&quot;minIdle&quot; value=&quot;$&#123;minIdle&#125;&quot;/&gt;\n &lt;/bean&gt;\n\n当前类路径下，保存jdbc.properties文件。文件内容如下：\n  driverClassName=org.gjt.mm.mysql.Driver\n  url=jdbc\\:mysql\\://localhost\\:3306/test?useUnicode\\=true&amp;characterEncoding\\=UTF-8\n  username=root\n  password=root\n  initialSize=1\n  maxActive=500\n  maxIdle=2\n  minIdle=1\n\n\n配置事务\n配置事务时，需要在xml配置文件中引入用于声明事务的tx命名空间\n  xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;\n  http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-2.5.xsd\n\n事物的配置方式有两种：注解方式和基于xml配置方式\n\n\n\n使用注解方式配置事务\n  &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;\n       &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n  &lt;/bean&gt;\n  &lt;!--使用基于注解方式配置事务 --&gt;  \n  &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;\n\n  &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n      &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;\n  &lt;/bean&gt;\n\n\n采用@Transactional注解方式使用事务package com.liuyong666.service.impl;\n\nimport java.util.List;\nimport javax.sql.DataSource;\nimport org.springframework.jdbc.core.JdbcTemplate;\nimport org.springframework.transaction.annotation.Transactional;\nimport com.liuyong666.bean.Person;\nimport com.liuyong666.service.PersonService;\n\n//表明业务方法受spring事务管理\n@Transactional\npublic class PersonServiceBean implements PersonService &#123;\n\n    private JdbcTemplate jdbcTemplate;\n\n    public void setDataSource(DataSource dataSource)&#123;\n        this.jdbcTemplate = new JdbcTemplate(dataSource);\n    &#125;\n\n    public void save(Person person) &#123;\n        jdbcTemplate.update(&quot;insert into person(name) values(?)&quot;, new Object[]&#123;person.getName()&#125;, \n                new int[]&#123;java.sql.Types.VARCHAR&#125;);\n    &#125;\n\n    public void update(Person person) &#123;\n        jdbcTemplate.update(&quot;update  person set name=? where id=?&quot;, new Object[]&#123;person.getName(),person.getId()&#125;, \n                new int[]&#123;java.sql.Types.VARCHAR, java.sql.Types.INTEGER&#125;);\n    &#125;\n\n    public Person getPerson(Integer personid) &#123;\n        return (Person) jdbcTemplate.queryForObject(&quot;select * from person where id=?&quot;, \n                new Object[]&#123;personid&#125;, new int[]&#123;java.sql.Types.INTEGER&#125;, new PersonRowMapper());\n    &#125;\n\n    public List&lt;Person&gt; getPersons() &#123;\n        return (List&lt;Person&gt;) jdbcTemplate.query(&quot;select * from person&quot;,new PersonRowMapper());\n    &#125;\n\n    public void delete(Integer personid) &#123;\n        jdbcTemplate.update(&quot;delete from  person where id=?&quot;, new Object[]&#123;personid&#125;, \n                new int[]&#123;java.sql.Types.INTEGER&#125;);\n    &#125;\n\n&#125;\nPersonpackage com.liuyong666.bean;\n\npublic class Person &#123;\n    private Integer id;\n    private String name;\n\n    public Person() &#123;\n    &#125;\n\n    public Person(String name) &#123;\n        super();\n        this.name = name;\n    &#125;\n    public Integer getId() &#123;\n        return id;\n    &#125;\n    public void setId(Integer id) &#123;\n        this.id = id;\n    &#125;\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n\n\n\n&#125;\nPersonRowMapperpackage com.liuyong666.service.impl;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport org.springframework.jdbc.core.RowMapper;\nimport com.liuyong666.bean.Person;\n\npublic class PersonRowMapper implements RowMapper &#123;\n    //外部默认next\n    public Object mapRow(ResultSet rs, int index) throws SQLException &#123;\n        Person person = new Person(rs.getString(&quot;name&quot;));\n        person.setId(rs.getInt(&quot;id&quot;));\n        return person;\n    &#125;\n&#125; \n测试public class PersonServiceTest &#123;\n\n    private static PersonService personService;\n\n    @BeforeClass\n    public static void setUpBeforeClass() throws Exception&#123;\n        try &#123;\n            ApplicationContext context = new ClassPathXmlApplicationContext(\n                    &quot;beans.xml&quot;);\n            personService = (PersonService) context.getBean(&quot;personService&quot;);\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    @Test\n    public void save()&#123;\n        personService.save(new Person(&quot;小蓝&quot;));\n    &#125;\n\n    @Test\n    public void getPerson()&#123;\n        Person p = personService.getPerson(1);\n        System.out.println(p.getName());\n    &#125;\n\n    @Test\n    public void update()&#123;\n        Person p = personService.getPerson(1);\n        p.setName(&quot;大明&quot;);\n        personService.update(p);\n    &#125;\n\n    @Test\n    public void delete()&#123;\n        personService.delete(1);\n    &#125;\n\n    @Test\n    public void getBeans()&#123;\n        for(Person person : personService.getPersons())&#123;\n            System.out.println(person.getName());\n        &#125;\n    &#125;\n&#125;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n","categories":["spring"],"tags":["spring","ssh","整合"]},{"title":"aspectj的切入点语法定义细节","url":"https://java4u.cn/spring/spring/aspectj的切入点语法定义细节/","content":"表达式分析expression=“execution(* com.liuyong666.service.impl.PersonServiceBean.*(..))”\n\n第一个星号表示 拦截方法的返回值 为任意\n\n如果为 java.lang.String ，表示只拦截 返回值为String 的方法\n如果为 void ，则表示只拦截 返回值为 void 的方法\n如果为 !void ，则表示只拦截 返回值为 非void的方法\n\n\n如果我们只拦截方法第一个参数为String,剩下的参数类型任意，则可以　　expression=”execution(java.lang.String com.liuyong666.service.impl.PersonServiceBean.*(java.lang.String,..))”\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP"]},{"title":"使用Spring配置文件实现AOP","url":"https://java4u.cn/spring/spring/使用Spring配置文件实现AOP/","content":"\n现在学习一下使用XML方式怎样来开发AOP应用。\n如果使用XML方式开发AOP应用的话，我们就不再需要提供注解的配置，我们只需要一个普通的Java类对象\n\nMyInterceptorpackage com.liuyong666.service;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\n/**\n * 切面\n *\n */\npublic class MyInterceptor &#123;    \n    public void doAccessCheck() &#123;\n        System.out.println(&quot;前置通知&quot;);\n    &#125;\n\n    public void doAfterReturning() &#123;\n        System.out.println(&quot;后置通知&quot;);\n    &#125;\n\n    public void doAfter() &#123;\n        System.out.println(&quot;最终通知&quot;);\n    &#125;\n\n    public void doAfterThrowing() &#123;\n        System.out.println(&quot;例外通知&quot;);\n    &#125;\n\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n        System.out.println(&quot;进入方法&quot;);\n        Object result = pjp.proceed();\n        System.out.println(&quot;退出方法&quot;);\n        return result;\n    &#125;\n\n&#125;\n\n可以看到，在这个切面里面，这只是一个普普通通的Java类，里面没有任何的注解。\n\nPersonServiceBeanpackage com.liuyong666.service.impl;\nimport com.liuyong666.service.PersonService;\n\npublic class PersonServiceBean implements PersonService &#123;\n\n\n\n    public void save(String name) &#123;\n//        throw new RuntimeException(&quot;我是例外&quot;);\n        System.out.println(&quot;我是save()方法！&quot;);\n\n    &#125;\n\n    public void update(String name, Integer personid) &#123;\n        System.out.println(&quot;我是update()方法！&quot;);\n    &#125;\n\n    public String getPersonName(Integer personid) &#123;\n        System.out.println(&quot;我是getPersonName()方法！&quot;);\n        return &quot;666&quot;;\n    &#125;\n\n&#125;\n\n如果我们采用基于XML方式来开发AOP应用的话，我们是要在配置文件中对切面进行配置的。现在看一下切面该如何配置\n\n基于XML配置方式声明切面——beans.xml&lt;aop:aspectj-autoproxy/&gt; \n\n&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;/&gt;\n\n&lt;bean id=&quot;aspectbean&quot; class=&quot;com.liuyong666.service.MyInterceptor&quot;/&gt;\n\n&lt;aop:config&gt;\n    &lt;aop:aspect id=&quot;asp&quot; ref=&quot;aspectbean&quot;&gt;\n        &lt;aop:pointcut id=&quot;mycut&quot; expression=&quot;execution (* com.liuyong666.service.impl.PersonServiceBean.*(..))&quot;/&gt;\n        &lt;aop:before pointcut-ref=&quot;mycut&quot;  method=&quot;doAccessCheck&quot;/&gt;\n        &lt;aop:after-returning pointcut-ref=&quot;mycut&quot; method=&quot;doAfterReturning&quot;/&gt;\n        &lt;aop:after pointcut-ref=&quot;mycut&quot; method=&quot;doAfter&quot;/&gt;\n        &lt;aop:after-throwing pointcut-ref=&quot;mycut&quot; method=&quot;doAfterThrowing&quot;/&gt;\n        &lt;aop:around pointcut-ref=&quot;mycut&quot; method=&quot;doBasicProfiling&quot;/&gt;\n    &lt;/aop:aspect&gt;\n&lt;/aop:config&gt;\n测试@Test\npublic void interceptorTest()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n    PersonService personService = (PersonService) context.getBean(&quot;personService&quot;);\n    personService.save(&quot;hhh&quot;);\n&#125;\n结果前置通知\n进入方法\n我是save()方法！\n后置通知\n最终通知\n退出方法\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP"]},{"title":"使用Spring的注解方式实现AOP的细节","url":"https://java4u.cn/spring/spring/使用Spring的注解方式实现AOP的细节/","content":"beans.xml配置&lt;aop:aspectj-autoproxy/&gt; \n\n&lt;bean id=&quot;myInterceptor&quot; class=&quot;com.liuyong666.service.MyInterceptor&quot;/&gt;\n&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;/&gt;\nPersonServicepackage com.liuyong666.service;\n\npublic interface PersonService &#123;\n\n    public void save(String name);\n\n    public void update(String name, Integer personid);\n\n    public String getPersonName(Integer personid);\n\n&#125;\nPersonServiceBeanpackage com.liuyong666.service.impl;\n\nimport com.liuyong666.service.PersonService;\n\npublic class PersonServiceBean implements PersonService &#123;\n\n\n\n    public void save(String name) &#123;\n        throw new RuntimeException(&quot;我是例外&quot;);\n//        System.out.println(&quot;我是save()方法！&quot;);\n\n    &#125;\n\n    public void update(String name, Integer personid) &#123;\n        System.out.println(&quot;我是update()方法！&quot;);\n    &#125;\n\n    public String getPersonName(Integer personid) &#123;\n        System.out.println(&quot;我是getPersonName()方法！&quot;);\n        return &quot;666&quot;;\n    &#125;\n\n&#125;\nMyInterceptorpackage com.liuyong666.service;\n\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.AfterReturning;\nimport org.aspectj.lang.annotation.AfterThrowing;\nimport org.aspectj.lang.annotation.Around;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.annotation.Pointcut;\n/**\n * 切面\n */\n@Aspect\npublic class MyInterceptor &#123;\n\n    //Spring只支持方法的拦截\n\n    /*\n     * \n     * 这句话是方法切入点，\n     *             execution为执行的意思，\n     *             *代表任意返回值，\n     *             然后是包名，.*意思是包下面的所有子包。\n     *             (..)代表各种方法.\n     */\n\n    @Pointcut(&quot;execution (* com.liuyong666.service.impl.PersonServiceBean.*(..))&quot;)\n    private void anyMethod()&#123;&#125;//声明一个切入点\n\n    @Before(&quot;anyMethod() &amp;&amp; args(name)&quot;)\n    public void doAccessCheck(String name)&#123;\n        System.out.println(&quot;前置通知:&quot; + name);\n    &#125;\n\n    @AfterReturning(pointcut=&quot;anyMethod()&quot;,returning=&quot;result&quot;)\n    public void doAfterReturning(String result)&#123;\n        System.out.println(&quot;后置通知:&quot; + result);\n    &#125;\n\n    @AfterThrowing(pointcut=&quot;anyMethod()&quot;,throwing=&quot;e&quot;)\n    public void doAfterThrowing(Exception e)&#123;\n        System.out.println(&quot;例外通知:&quot; + e);\n    &#125;\n\n    @After(&quot;anyMethod()&quot;)\n    public void doAfter()&#123;\n        System.out.println(&quot;最终通知&quot;);\n    &#125;\n\n    @Around(&quot;anyMethod()&quot;)\n    public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123;\n        //if()&#123;//判断用户是否在权限\n        System.out.println(&quot;进入方法&quot;);\n        Object result = pjp.proceed();\n        System.out.println(&quot;退出方法&quot;);\n        //&#125;\n        return result;\n    &#125;\n&#125;\n测试    @Test\n    public void interceptorTest()&#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        PersonService personService = (PersonService) context.getBean(&quot;personService&quot;);\n        personService.save(&quot;hhh&quot;);\n//        personService.getPersonName(111);\n    &#125;\n当前结果前置通知:hhh\n进入方法\n例外通知:java.lang.RuntimeException: 我是例外\n最终通知\n\n使用不同的方法，设置不同的AOP注解会有不同的结果。\n\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP","注解"]},{"title":"使用Spring的注解方式实现AOP入门","url":"https://java4u.cn/spring/spring/使用Spring的注解方式实现AOP入门/","content":"配置文件\n使用Spring进行面向切面（AOP）编程\n\n要进行AOP编程，首先我们要在Spring的配置文件中引入aop命名空间：\n  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns:context=&quot;http://www.springframework.org/schema/context&quot; \n         xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;      \n         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n             http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n             http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\n             http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-2.5.xsd&quot;&gt;\n  &lt;/beans&gt;\n\n\n使用方式\nspring提供两种切面使用方式，实际工作中我们可以选用其中一种：\n基于XML配置方式进行AOP开发\n基于注解方式进行AOP开发\n\n\n\n基于注解方式声明切面\n首先启动对@AspectJ注解的支持：\n  &lt;aop:aspectj-autoproxy/&gt;\n\n切面\n  @Aspect\n  public class MyInterceptor &#123;\n\n      //Spring只支持方法的拦截\n\n      @Pointcut(&quot;execution (* com.liuyong666.service.impl.PersonServiceBean.*(..))&quot;)\n      private void anyMethod()&#123;&#125;//声明一个切入点\n\n      @Before(&quot;anyMethod()&quot;)\n      public void doAccessCheck()&#123;\n          System.out.println(&quot;前置通知&quot;);\n      &#125;\n  &#125;\n\nbeans.xml中添加\n     &lt;bean id=&quot;myInterceptor&quot; class=&quot;com.liuyong666.service.MyInterceptor&quot;/&gt;\n     &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;/&gt;\n\n测试\n  @Test\n  public void interceptorTest()&#123;\n      ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n      PersonService personService = (PersonService) context.getBean(&quot;personService&quot;);\n      personService.save(&quot;hhh&quot;);\n  &#125;\n\n结果\n\n\n\n前置通知我是save()方法！\n\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP","注解"]},{"title":"使用CGLIB实现AOP功能与AOP概念解释","url":"https://java4u.cn/spring/spring/使用CGLIB实现AOP功能与AOP概念解释/","content":"使用场景\n通过JDK中的Proxy技术实现AOP功能，目标对象是实现了接口的，用JDK的Proxy技术可以使其生成代理对象，但有些情况下，目标对象是没有实现接口的，那么我们就要通过另外的方法来实现了。\n首先需要导入cglib-nodep-x.x_x.jar这个包。\n\n步骤分三步：\n\n  创建Enhancer\n\n  设置目标对象为超类\n\n  创建对象\n\n\n这样就产生了一个目标对象的子类\nPersonServiceBeanpackage com.liuyong666.service.impl;\n\nimport com.liuyong666.service.PersonService;\n/**\n * 业务需求：\n *         1. 拦截所有业务方法\n *         2. 判断用户是否有权限\n *                 如果用户为null，没有权限调用业务方法\n *                 如果用户不为null，则有权限调用\n * @author Administrator\n *\n */\npublic class PersonServiceBean （这里不必实现接口）&#123;\n\n    private String user = null;\n\n\n\n    public String getUser() &#123;\n        return user;\n    &#125;\n\n    public PersonServiceBean() &#123;\n        super();\n    &#125;\n\n    public PersonServiceBean(String user)&#123;\n        this.user = user;\n    &#125;\n\n\n    public void save(String name) &#123;\n        System.out.println(&quot;我是save()方法！&quot;);\n\n    &#125;\n\n    public void update(String name, Integer personid) &#123;\n        System.out.println(&quot;我是update()方法！&quot;);\n    &#125;\n\n    public String getPersonName(Integer personid) &#123;\n        System.out.println(&quot;我是getPersonName()方法！&quot;);\n        return &quot;666&quot;;\n    &#125;\n\n&#125;\nCGlibProxyFactorypackage com.liuyong666.aop;\nimport java.lang.reflect.Method;\nimport com.liuyong666.service.impl.PersonServiceBean;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class CGlibProxyFactory implements MethodInterceptor &#123;\n\n    private Object targetObjeact;//代理的目标对象\n\n    public Object createProxyInstance(Object targetObjeact)&#123;\n\n        this.targetObjeact = targetObjeact;\n\n        Enhancer enhancer = new Enhancer();//该类用于生成代理对象\n        enhancer.setSuperclass(this.targetObjeact.getClass());//非final\n        enhancer.setCallback(this);//设置回调对象为本身\n        return enhancer.create();//创建代理对象\n    &#125;\n\n    /**\n     * 当代理对象的业务方法被调用的时候，会回调这个方法\n     * @param proxy   代理对象\n     * @param method  被拦截到的方法\n     * @param args      方法的输入参数\n     * @param methodProxy  方法的代理对象\n     * @return \n     * @throws Throwable\n     */\n    @Override \n    public Object intercept(Object proxy, Method method, Object[] args,\n            MethodProxy methodProxy) throws Throwable &#123;\n\n        PersonServiceBean bean = (PersonServiceBean) this.targetObjeact;\n        Object  result = null;\n        if(bean.getUser() != null)&#123;\n            result = methodProxy.invoke(targetObjeact, args);//把方法的调用委派给目标对象\n        &#125;\n\n\n        return result;\n    &#125;\n&#125;\n\n可以在调用方法前，后，以及出现例外时处理，无论抛不抛异常都会执行的方法，分别为前置通知，后置通知，例外通知，最终通知\n还有一种叫做环绕通知，允许在目标类方法调用前后织入横切逻辑\n\n测试@Test\npublic void proxyTestByCGlib()&#123;\n    CGlibProxyFactory factory = new CGlibProxyFactory();\n    PersonServiceBean service = (PersonServiceBean) factory.createProxyInstance(new PersonServiceBean(&quot;xxx&quot;));\n    service.save(&quot;6666&quot;);\n&#125;\n\n也一样会打印出“我是save()方法”。\n spring框架的一些实现就是通过类似这样的方法实现的，根据判断目标对象有没实现接口，决定用哪个方法生成代理对象。\n\nAOP概念\nAspect(切面)：指横切性关注点的抽象即为切面，它与类很相似，只是两者的关注点不一样，类是对物体特征的抽象，而切面是横切性关注点的抽象。\nJoinpoint(连结点)：所谓连结点是指那些被拦截到的点。在spring中，这些点指的是方法，因为spring只支持方法类型的连结点，实际上joinpoint还可以是field或类构造器。\nPointcut(切入点)：所谓切入点是指我们要对那些joinpoint进行拦截的定义。\nAdvice(通知)：所谓通知是指拦截到joinpoint之后要做的事情就是通知。通知分为前置通知，后置通知，异常通知，最终通知，环绕通知。\nTarget(目标对象)：代理的目标对象。\nWeave(织入)：指将aspects应用到target对象并导致proxy对象创建的过程为织入。\nIntroduction(引入)：再不修改类代码的前提下，Introduction可以在运行期为类动态添加一些方法或Field.\n\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP","CGlib"]},{"title":"使用JDK中的Proxy技术实现AOP功能","url":"https://java4u.cn/spring/spring/使用JDK中的Proxy技术实现AOP功能/","content":"PersonService接口package com.liuyong666.service;\n\npublic interface PersonService &#123;\n\n    public void save(String name);\n\n    public void update(String name, Integer personid);\n\n    public String getPersonName(Integer personid);\n\n&#125;\n实现类PersonServiceBeanpackage com.liuyong666.service.impl;\n\nimport com.liuyong666.service.PersonService;\n/**\n * 业务需求：\n *         1. 拦截所有业务方法\n *         2. 判断用户是否有权限\n *                 如果用户为null，没有权限调用业务方法\n *                 如果用户不为null，则有权限调用\n * @author Administrator\n *\n */\npublic class PersonServiceBean implements PersonService &#123;\n\n    private String user = null;\n\n\n\n    public String getUser() &#123;\n        return user;\n    &#125;\n\n    public PersonServiceBean() &#123;\n        super();\n    &#125;\n\n    public PersonServiceBean(String user)&#123;\n        this.user = user;\n    &#125;\n\n    @Override\n    public void save(String name) &#123;\n        System.out.println(&quot;我是save()方法！&quot;);\n\n    &#125;\n\n    @Override\n    public void update(String name, Integer personid) &#123;\n        System.out.println(&quot;我是update()方法！&quot;);\n    &#125;\n\n    @Override\n    public String getPersonName(Integer personid) &#123;\n        System.out.println(&quot;我是getPersonName()方法！&quot;);\n        return &quot;666&quot;;\n    &#125;\n\n&#125;\n分析\n为什么要用到AOP技术呢？试想一下，如果上边的三个方法，要通过权限验证才能使用的话，那么要在每个方法里面都加上“if() {}”来判断吗？没错，这是可行的，但这里仅针对一个类，如果是N个类呢？大家可能想到，拦截器，但如果不是web项目呢？\n\n原理图如下：\n      客户端————&gt;代理对象————&gt;目标对象\n\n客户端要调用目标对象之前，先要通过代理对象，再调用目标对象，代理对象实现了目标对象的所有方法。\n\n\n代理工厂类JDKProxyFactorypackage com.liuyong666.aop;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\nimport com.liuyong666.service.impl.PersonServiceBean;\n\npublic class JDKProxyFactory implements InvocationHandler &#123;\n\n    private Object targetObject;\n\n    public Object createProxyInstance(Object targetObject)&#123;\n\n        this.targetObject = targetObject;\n\n        /*\n         * 1. this.targetObject.getClass().getClassLoader() --目标对象的类装载器\n         * 2. this.targetObject.getClass().getInterfaces()  --代理对象要实现的接口\n         * 3. this  --这个类实例本身\n         */\n\n\n        return Proxy.newProxyInstance(this.targetObject.getClass().getClassLoader(),\n                this.targetObject.getClass().getInterfaces(), this);\n    &#125;\n\n\n    /**\n     * 代理对象会执行这个方法\n     * @param proxy   代理对象\n     * @param method  被拦截到的方法\n     * @param args      方法的输入参数\n     * @return \n     * @throws Throwable\n     */\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args)\n            throws Throwable &#123;//环绕通知\n        PersonServiceBean bean = (PersonServiceBean) this.targetObject;\n        Object result = null; \n        if(bean.getUser()!=null)&#123;\n            //..... advice()--&gt;前置通知\n            try &#123;\n                result = method.invoke(targetObject, args);\n                // afteradvice() --&gt;后置通知\n            &#125; catch (RuntimeException e) &#123;\n                //exceptionadvice()--&gt; 例外通知\n            &#125;finally&#123;\n                //finallyadvice(); --&gt;最终通知\n            &#125;\n        &#125;\n        return result;\n    &#125;\n\n\n\n&#125;\n\n上面的类使用JDK中的Proxy技术实现AOP功能。当我们要调用目标对象PersonServiceImpl的时候，先要通过JDKProxyFactory的createProxyInstance创建代理对象，这个代理对象会执行invoke的方法，里面判断是否有权限，有的话，再通过method.invoke，执行目标对象的方法。\n\n测试package junit.test;\n\nimport org.junit.Test;\n\nimport com.liuyong666.aop.JDKProxyFactory;\nimport com.liuyong666.service.PersonService;\nimport com.liuyong666.service.impl.PersonServiceBean;\n\npublic class AOPTest &#123;\n\n\n    @Test\n    public void proxyTest()&#123;\n        JDKProxyFactory factory = new JDKProxyFactory();\n        PersonService service = (PersonService) factory.createProxyInstance(new PersonServiceBean(&quot;xxx&quot;));\n        service.save(&quot;666&quot;);\n    &#125;\n\n&#125;\n\n上面的测试方法表明，如果传入了user,即user不为空，那么它就有权限执行save方法，打印出“我是save()方法”\n如果不传入user,即PersonService service = (PersonService)factory.createProxyInstance(new PersonServiceBean());，那么，在代理对象的invoke方法中判断出没权限，不会扫描目标对象的save方法，所以没任何的输出。\n\n\n\n","categories":["spring"],"tags":["spring","ssh","AOP","代理"]},{"title":"让Spring自动扫描和管理Bean","url":"https://java4u.cn/spring/spring/让Spring自动扫描和管理Bean/","content":"为什么需要自动扫描\n通过在classpath自动扫描方式把组件纳入spring容器中管理\n之前我们都是使用XML的bean定义来配置组件。在一个稍大的项目中，通常会有上百个组件，如果这些组件采用xml的bean定义来配置，显然会增加配置文件的体积，查找以及维护起来也不太方便。\n\n如何实现自动扫描\nSpring2.5为我们引入了组件自动扫描机制，他可以在类路径底下寻找标注了@Component,@Service,@Controller,@Repository注解的类，并把这些类纳入进spring容器中管理。\n\n它的作用和在xml文件中使用bean节点配置组件时一样的。要使用自动扫描机制，我们需要打开以下配置信息\n  &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n         xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n             http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n             http://www.springframework.org/schema/context \n             http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;\n       &lt;!-- \n       &lt;context:annotation-config/&gt;\n        --&gt;\n\n           &lt;!-- 让Spring自动扫描和管理Bean --&gt;\n           &lt;!-- 当前标签包括了 &quot;&lt;context:annotation-config/&gt;&quot;，所以当前标签存在时，配置注解的标签可以不要--&gt;\n           &lt;context:component-scan base-package=&quot;com.liuyong666&quot;/&gt;\n  &lt;/beans&gt;\n\n其中base-package为需要扫描的包（含子包）\n\n\n各个注解的使用\n@Service用于标注业务层组件\n@Controller用于标注控制层组件（如struts中的action）\n@Repository用于标注数据访问组件，即DAO组件\n而@Component泛指组件，当组件不好归类的时候，我们可以使用这个注解进行标注\n\n组件标注\n业务层组件\n  @Service(&quot;newName&quot;)\n  public class PersonServiceBean implements PersonService &#123;&#125;\n\n\n\n数据访问组件\n  @Repository\n  public class PersonDaoBean implements PersonDao &#123;&#125;\n\n测试方法\n\n\n    /**\n     * 使用spring自动扫描包获取bean\n     */\n    @Test\n    public void getBeanBySpringComponentScan()&#123;\n        ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\n        /*\n         * getBean的默认名称是类名（头字母小写），如果想自定义，可以@Service(“aaaaa”)这样来指定，\n         * 这种bean默认是单例的，如果想改变，可以使用@Service(“aaaaa”) @Scope(“prototype”)来改变\n         */\n        PersonService personService = (PersonService) context.getBean(&quot;newName&quot;);\n        PersonService personService1 = (PersonService) context.getBean(&quot;newName&quot;);\n        System.out.println(personService == personService1);//true\n\n        PersonDao personDao = (PersonDao) context.getBean(&quot;personDaoBean&quot;);\n        System.out.println(personService);\n        System.out.println(personDao);\n    &#125;    \n特别操作\ngetBean的默认名称是类名（头字母小写），\n\n如果想自定义，可以@Service(“aaaaa”)这样来指定，这种bean默认是单例的，\n\n如果想改变，可以使用@Service(“aaaaa”) @Scope(“prototype”)来改变。\n\n可以使用以下方式指定初始化方法和销毁方法（方法名任意）\n  @PostConstruct\n  public void init() &#123;\n      //getBean之后\n  &#125;\n\n  @PreDestroy\n  public void destory() &#123;\n      //上下文关闭之前\n  &#125;\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean","扫描bean"]},{"title":"使用@Autowire注解与自动装配","url":"https://java4u.cn/spring/spring/使用@Autowire注解与自动装配/","content":"@Autowired注解\nAutowire 默认是按类型匹配  @ Autowire\n如果你要修改 Autowire，按名称匹配可以 @Autowired @Qualifier(“MypersonDao”) ,如果在beans.xml中没有发现有这个名字的bean,则会有异常\n@Autowired(required=true) @Qualifier(“MypersonDao”), 表示这个bean必须注入值,不然报错\n\n用于字段上@Autowired \nprivate PersonDao  personDao;\n用于属性的setter方法上@Autowired\npublic void setPersonDao(PersonDao personDao) &#123; \n    this.personDao = personDao; \n&#125; \n扩展\n@Autowired注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它的required属性为false,如果我们向使用按名称装配，可以结合@Qualifier注解一起使用。如下：\n  @Autowired @Qualifier(&quot;MypersonDao&quot;)\n  private PersonDao personDao;\n\n\n自动装配\n自动装配了解，不推荐使用\n4种类型的自动装配\nbyName——按名称装配，可以根据属性的名称，在容器中寻找跟该属性名相同的bean，如果没有找到，即属性值为null\nbyType——按类型装配，可以根据属性的类型，在容器中寻找跟该类型匹配的bean，如果没有找到，即属性值为null\nconstructor——与byType的方式类似，不同之处在于它应用于构造器参数。如果容器中没有找到与构造器参数类型一致的bean，那么将会抛出异常。\nautodetect——通过bean类的自省机制(introspection)来决定是使用constructor还是byType方式进行自动装配。如果发现默认的构造器，那么将使用byType。\n\n\n\n总结\n使用注解方式允许更细粒度的自动装配，可以选择性地标注某一个属性来对其应用自动装配。\nSpring容器默认禁用注解装配\nxml配置中启用注解，利用context命名空间中context:annotation-config元素\n\n\n\n\n注入依赖对象可以采用手工装配或自动装配，在实际应用中建议使用手工装配，因为自动装配会产生未知情况，开发人员无法预见最终的装配结果。\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean","装配属性"]},{"title":"用@Resource注解完成属性装配","url":"https://java4u.cn/spring/spring/用@Resource注解完成属性装配/","content":"\nbean的注入方式有3种:\n第一种:使用构造器注入\n第二钟:使用属性setter方法注入\n第三种:使用Field注入（用于注解方式）\n\n\n\n使用注解的方式完成bean的注入\n在java代码中使用@Autowired或@Resource注解方式进行装配，这两个注解的区别是：\n@Autowired 默认按类型装配。是spring的api。\n@Resource默认按名称装配，当找不到与名称匹配的bean才会按类型装配。但一旦指定了name属性，就只能按名称装配了。是jdk的api。使用它可以不依赖spring的特性。\n\n\n\n@Resource1.修改beans.xml&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd\n           http://www.springframework.org/schema/context \n           http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;\n     &lt;context:annotation-config/&gt;\n\n    &lt;bean id=&quot;MypersonDao&quot; class=&quot;com.liuyong666.dao.impl.PersonDaoBean&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n    &lt;/bean&gt;\n\n&lt;/beans&gt;\n\n这个配置隐式注册了多个对注释进行解析处理的处理器:\nAutowiredAnnotationBeanPostProcessor，\nCommonAnnotationBeanPostProcessor，\nPersistenceAnnotationBeanPostProcessor，\nRequiredAnnotationBeanPostProcessor\n\n\n注： @Resource注解在spring安装目录的lib\\j2ee\\common-annotations.jar\ncontext:annotation-config/  必不可少\n\n使用@Resource来注入我们在beans.xml种声明的bean\n用于字段上\n  @Resource(name=&quot;MypersonDao&quot;) private PersonDao personDao; \n\n用于属性的setter方法上\n\n\n    @Resource(name=&quot;MypersonDao&quot;)\n    public void setPersonDao(PersonDao personDao) &#123; \n        this.personDao = personDao; \n    &#125; \n\n\n","categories":["spring"],"tags":["spring","ssh","bean","装配属性"]},{"title":"使用构造器装配属性","url":"https://java4u.cn/spring/spring/使用构造器装配属性/","content":"\n以前我们都是使用setter方法给属性注入值的,现在我们来看看另外一种注入方法:构造器注入\n\n步骤1.改写PersonServiceBean，为注入的属性加上构造方法public PersonServiceBean(PersonDao personDao, String name) &#123;\n    this.personDao = personDao;\n    this.name = name;\n&#125;\n2.配置beans.xml,其中配置了一个依赖属性和一个基本的String类型&lt;!-- 使用构造器装配属性 --&gt;\n&lt;bean id=&quot;personDao&quot; class=&quot;com.liuyong666.dao.impl.PersonDaoBean&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n    &lt;constructor-arg index=&quot;0&quot; ref=&quot;personDao&quot; type=&quot;com.liuyong666.dao.PersonDao&quot;&gt;&lt;/constructor-arg&gt;\n    &lt;constructor-arg index=&quot;1&quot; value=&quot;花永伦&quot;&gt;&lt;/constructor-arg&gt;\n&lt;/bean&gt;\n3.测试name:花永伦\n执行PersonDaoBean里的add()方法\n\n目前学习到了两种注入方式:1.setter方式2.构造器方式\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean","装配属性"]},{"title":"Spring如何装配各种集合类型的属性","url":"https://java4u.cn/spring/spring/Spring如何装配各种集合类型的属性/","content":"首先在bean里面声明这些属性，并设置相应的更改器方法和访问器方法private Set&lt;String&gt; sets = new HashSet&lt;&gt;();\nprivate List&lt;String&gt; lists = new ArrayList&lt;&gt;();  \nprivate Properties properties = new Properties();  \nprivate Map&lt;String, String&gt; maps = new HashMap&lt;&gt; ();\n接着在beans.xml做如下配置&lt;property name=&quot;sets&quot;&gt;\n    &lt;set&gt;\n        &lt;value&gt;set第一个&lt;/value&gt;\n        &lt;value&gt;set第二个&lt;/value&gt;\n        &lt;value&gt;set第三个&lt;/value&gt;\n    &lt;/set&gt;\n&lt;/property&gt;\n\n&lt;property name=&quot;lists&quot;&gt;\n    &lt;set&gt;\n        &lt;value&gt;list第一个&lt;/value&gt;\n        &lt;value&gt;list第二个&lt;/value&gt;\n        &lt;value&gt;list第三个&lt;/value&gt;\n    &lt;/set&gt;\n&lt;/property&gt;\n\n&lt;property name=&quot;properties&quot;&gt;  \n    &lt;props&gt;  \n        &lt;prop key=&quot;p1&quot;&gt;properties第一个&lt;/prop&gt;  \n        &lt;prop key=&quot;p2&quot;&gt;properties第二个&lt;/prop&gt;  \n        &lt;prop key=&quot;p3&quot;&gt;properties第三个&lt;/prop&gt;  \n    &lt;/props&gt;  \n&lt;/property&gt; \n\n&lt;property name=&quot;maps&quot;&gt;  \n    &lt;map&gt;  \n        &lt;entry key=&quot;key1&quot; value=&quot;value1&quot;&gt;&lt;/entry&gt;  \n        &lt;entry key=&quot;key2&quot; value=&quot;value2&quot;&gt;&lt;/entry&gt;  \n        &lt;entry key=&quot;key3&quot; value=&quot;value3&quot;&gt;&lt;/entry&gt;  \n    &lt;/map&gt;  \n&lt;/property&gt;\n\n对于map集合，entry里面的key属性和value属性都可以换成key-ref 和value-ref\n\n测试方法/**\n * 装载集合\n */\n@Test\npublic void getCollectionBySpring()&#123;\n    ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\n    PersonService bean = (PersonService) context.getBean(&quot;personService&quot;);\n    System.out.println(&quot;-----Set测试--------&quot;);\n    for(String value: bean.getSets())&#123;\n        System.out.println(value);\n    &#125;\n\n    System.out.println(&quot;-----List测试--------&quot;);\n    for(String value: bean.getLists())&#123;\n        System.out.println(value);\n    &#125;\n\n    System.out.println(&quot;-----Properties测试--------&quot;);\n    for(Object key: bean.getProperties().keySet())&#123;\n        System.out.println(key + &quot;=&quot; + bean.getProperties().getProperty((String)key));\n    &#125;\n\n    System.out.println(&quot;-----Map测试--------&quot;);\n    for(Object key: bean.getMaps().keySet())&#123;\n        System.out.println(key + &quot;=&quot; + bean.getMaps().get(key));\n    &#125;\n&#125;\n输出-----Set测试--------\nset第一个\nset第二个\nset第三个\n-----List测试--------\nlist第一个\nlist第二个\nlist第三个\n-----Properties测试--------\np3=properties第三个\np2=properties第二个\np1=properties第一个\n-----Map测试--------\nkey1=value1\nkey2=value2\nkey3=value3  \n\n\n\n\n\n&lt;p&gt;&lt;/p&gt;\n","categories":["spring"],"tags":["spring","ssh","bean","装配属性"]},{"title":"Spring装配基本属性的原理","url":"https://java4u.cn/spring/spring/Spring装配基本属性的原理/","content":"依赖注入对象方式二\n使用内部bean，但该bean不能被其他bean使用\n\n    &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n        &lt;property name=&quot;personDao&quot;&gt;\n            &lt;bean class=&quot;com.liuyong666.dao.impl.PersonDaoBean&quot;&gt;&lt;/bean&gt;\n        &lt;/property&gt;\n    &lt;/bean&gt;\n\n两种方式的优缺点比较\n使用ref的方式，引用的bean可以被多个bean引用\n而采用内部bean的方式，内部bean只能为那个bean里面那那个属性使用。\n\n\n\n前面都是注入依赖对象，那么如何注入基本类型呢？\n例如，在PersonServiceBean里面添加一个String类型的name属性和Integer类型的id属性，可以这样注入值：\n\n    &lt;property name=&quot;name&quot; value=&quot;huayonglun&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;id&quot; value=&quot;22&quot;&gt;&lt;/property&gt;\nStpring容器是怎么获取这些值，并转化成相应的类型的呢？\n首先我们在PropertyDefinition里面多加一个属性value.同时，在读取property里面的属性的值的时候读取value的值。\n然后在为bean对象的属性注入值的时候要做一下处理。\n\nPropertyDefinition/**\n * 建一个java bean，用来存储property的信息，然后property的信息再通过一个集合存在bean里面\n * @author Administrator\n *\n */\npublic class PropertyDefinition &#123;\n    private String name;\n    private String ref;\n    private String value;\n\n\n\n    public PropertyDefinition(String name, String ref) &#123;\n        this.name = name;\n        this.ref = ref;\n    &#125;\n\n    public PropertyDefinition(String name, String ref, String value) &#123;\n        this.name = name;\n        this.ref = ref;\n        this.value = value;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getRef() &#123;\n        return ref;\n    &#125;\n    public void setRef(String ref) &#123;\n        this.ref = ref;\n    &#125;\n\n    public String getValue() &#123;\n        return value;\n    &#125;\n\n    public void setValue(String value) &#123;\n        this.value = value;\n    &#125;\n\n&#125;\nMyClassPathXMLApplicationContext1/**\n * 读取xml配置文件\n * @param filename\n */\nprivate void readXML(String filename) &#123;\n       SAXReader saxReader = new SAXReader();   \n        Document document=null;   \n        try&#123;\n         URL xmlpath = this.getClass().getClassLoader().getResource(filename);\n         document = saxReader.read(xmlpath);\n         Map&lt;String,String&gt; nsMap = new HashMap&lt;String,String&gt;();\n         nsMap.put(&quot;ns&quot;,&quot;http://www.springframework.org/schema/beans&quot;);//加入命名空间\n         XPath xsub = document.createXPath(&quot;//ns:beans/ns:bean&quot;);//创建beans/bean查询路径\n         xsub.setNamespaceURIs(nsMap);//设置命名空间\n         List&lt;Element&gt; beans = xsub.selectNodes(document);//获取文档下所有bean节点 \n         for(Element element: beans)&#123;\n            String id = element.attributeValue(&quot;id&quot;);//获取id属性值\n            String clazz = element.attributeValue(&quot;class&quot;); //获取class属性值        \n            BeanDefinition beanDefine = new BeanDefinition(id, clazz);\n            XPath propertysub = element.createXPath(&quot;ns:property&quot;);\n            propertysub.setNamespaceURIs(nsMap);//设置命名空间\n            List&lt;Element&gt; propertys = propertysub.selectNodes(element);\n            for(Element property : propertys)&#123;\n                String propertyName = property.attributeValue(&quot;name&quot;);\n                String propertyRef = property.attributeValue(&quot;ref&quot;);\n                String propertyValue = property.attributeValue(&quot;value&quot;);\n                System.out.println(propertyName + &quot;;&quot; + propertyRef);\n                PropertyDefinition propertyDefinition = new PropertyDefinition(propertyName, propertyRef, propertyValue);\n                beanDefine.getPropertys().add(propertyDefinition);\n            &#125;\n            beanDefines.add(beanDefine);\n         &#125;   \n        &#125;catch(Exception e)&#123;   \n            e.printStackTrace();\n        &#125;\n&#125;\n\n/**\n * 为bean对象的属性注入值\n */\nprivate void injectObject() &#123;\n    for(BeanDefinition beandefinition : beanDefines)&#123;\n        Object bean = sigletons.get(beandefinition.getId());\n        if(bean != null)&#123;\n            try &#123;\n                PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n                for(PropertyDefinition propertyDefinition: beandefinition.getPropertys())&#123;\n                    for(PropertyDescriptor properdesc : ps)&#123;\n                        if(propertyDefinition.getName().equals(properdesc.getName()))&#123;\n                            Method setter = properdesc.getWriteMethod();//获取属性的setter方法\n                            if(setter != null)&#123;\n                                Object value  = null;\n                                if(propertyDefinition.getRef() != null &amp;&amp; !&quot;&quot;.equals(propertyDefinition.getRef().trim()))&#123;\n                                    value = sigletons.get(propertyDefinition.getRef());\n\n                                &#125;else&#123;\n                                    //BeanUtils的工具类把字符串类型的数据转换成指定类型的数据\n                                    //convert需要的值通过属性定义获取，需要的类型通过属性描述符获取\n                                    value = ConvertUtils.convert(propertyDefinition.getValue(), properdesc.getPropertyType());\n                                &#125;\n                                setter.setAccessible(true);//允许访问private方法\n                                setter.invoke(bean, value);//把引用对象注入到属性\n\n                            &#125;\n\n                        &#125;\n                    &#125;\n                &#125;\n            &#125; catch (Exception e) &#123;\n            &#125;\n        &#125;\n    &#125;\n\n&#125;\nbeans.xml&lt;bean id=&quot;personDao&quot; class=&quot;com.liuyong666.dao.impl.PersonDaoBean&quot;&gt;&lt;/bean&gt;\n&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;\n    &lt;property name=&quot;personDao&quot; ref=&quot;personDao&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;name&quot; value=&quot;huayonglun&quot;&gt;&lt;/property&gt;\n    &lt;property name=&quot;id&quot; value=&quot;22&quot;&gt;&lt;/property&gt;\n&lt;/bean&gt;\n\n测试自定义容器，得到以下输出\n\n\n我是save()方法name:huayonglun,id:22\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean","装配属性"]},{"title":"Spring依赖注入的原理","url":"https://java4u.cn/spring/spring/Spring依赖注入的原理/","content":"\n使用Spring，可以使用里面的控制反转把依赖对象交给Spring管理，并把依赖对象通过容器注入到组件内部。\n那么在Spring里面，该如何把对象注入到组件内部呢？创建一个PersonDao对象，并把这个对象注入到PersonServiceBean中\n\n依赖注入使用PersonDaoBeanpackage com.liuyong666.dao.impl;\nimport com.liuyong666.dao.PersonDao;\n\npublic class PersonDaoBean implements PersonDao&#123;\n    @Override\n    public void add()&#123; \n        System.out.println(&quot;执行PersonDaoBean里的add()方法&quot;); \n    &#125;\n\n&#125;\n抽取接口package com.liuyong666.dao;\n\npublic interface PersonDao &#123;\n\n    public abstract void add();\n\n&#125;\n说明\n接口跟实现类不要放一块，接下来，如何将PersonDaoBean对象注入进PersonServiceBean，注入方式有两种：\n一种是构造器参数，\n另一种是通过属性的set方法注入。 \n\n\n下面介绍通过属性的set方法我们该如何注入PersonDaoBean对象\n\nPersonServiceBeanpackage com.liuyong666.service.impl;\n\nimport com.liuyong666.dao.PersonDao;\nimport com.liuyong666.service.PersonService;\n\npublic class PersonServiceBean implements PersonService &#123;\n    private PersonDao personDao; \n\n\n    public PersonServiceBean()&#123;\n        System.out.println(&quot;我被实例化了&quot;);\n    &#125;\n\n    public PersonDao getPersonDao() &#123; \n        return personDao; \n    &#125; \n\n    public void setPersonDao(PersonDao personDao) &#123; \n        this.personDao = personDao; \n    &#125; \n\n    @Override\n    public void save()&#123;\n        personDao.add();\n    &#125;\n\n&#125;\n说明\n可以看到，在服务层的这个类里面，我们并没有看到PersonDaoBean的身影，也就是说我们并不关心这个实现类是谁，我们通过PersonDao这个接口去引用注入进来的对象，再通过接口调用它的方法。这样的话，服务层的组件和DAO层的组件已经进行彻底的解耦了。\n看下在beans.xml里如何为personDao这个属性注入PersonDaoBean这个bean呢？ 首先要把personDao这个bean配置在Spring中\n\nbeans.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot; &gt;\n\n    &lt;bean id=&quot;personDao&quot; class=&quot;com.liuyong666.dao.impl.PersonDaoBean&quot;&gt;&lt;/bean&gt;\n    &lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot; &gt;\n        &lt;property name=&quot;personDao&quot; ref=&quot;personDao&quot;&gt;&lt;/property&gt;\n    &lt;/bean&gt;\n\n\n&lt;/beans&gt;\n\nproperty这个元素就是用于为属性注入值\n\nname填写的是属性的名称\nref填写的值就是我们要注入的bean的名称。Spring会根据这个名称从Spring容器里面得到这个bean，因为这个bean默认在Spring容器实例化后就会被实例化，所以它在容器里面根据ref里的名称得到相应的bean，然后把这个bean通过反射技术就赋给了里面的属性。这就是Spring执行的过程。\n\n\n我们看下我们注入的personDao这个bean是否能够成功注入呢？判断是否能够成功注入很简单，在PersonServiceBean.java里的save方法，调用了personDao.add()方法，\n\n如果注入不成功的话，就会出现空指针异常；\n\n如果能输出add方法里面打印的那句话，就代表注入是成功的\n  @Test\n  public void getBeanBySpring()&#123;\n      ApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\n      PersonService bean = (PersonService) context.getBean(&quot;personService&quot;);\n      bean.save();\n  &#125;\n\n\n\n\n说明\n这时候，思考下控制反转，原先我们对象的创建是由应用本身创建的。现在对象的创建是由容器帮我们创建，并且由容器注入进来，这时候控制权发生了转移，这就是所谓的控制反转。\n\n自定义类模拟Spring的注入功能，解剖Spring实现这个过程的内部细节PropertyDefinitionpackage junit.test;\n/**\n * 建一个java bean，用来存储property的信息，然后property的信息再通过一个集合存在bean里面\n * @author Administrator\n *\n */\npublic class PropertyDefinition &#123;\n    private String name;\n    private String ref;\n\n    public PropertyDefinition(String name, String ref) &#123;\n        this.name = name;\n        this.ref = ref;\n    &#125;\n\n    public String getName() &#123;\n        return name;\n    &#125;\n    public void setName(String name) &#123;\n        this.name = name;\n    &#125;\n    public String getRef() &#123;\n        return ref;\n    &#125;\n    public void setRef(String ref) &#123;\n        this.ref = ref;\n    &#125;\n&#125;\nBeanDefinitionpackage junit.test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class BeanDefinition &#123;\n    private String id;\n    private String className;\n    private List&lt;PropertyDefinition&gt; propertys = new ArrayList&lt;&gt;();\n    //通过一个集合，来存放property的信息 \n\n    public BeanDefinition(String id, String className) &#123;\n        this.id = id;\n        this.className = className;\n    &#125;\n\n\n    public String getId() &#123;\n        return id;\n    &#125;\n    public void setId(String id) &#123;\n        this.id = id;\n    &#125;\n    public String getClassName() &#123;\n        return className;\n    &#125;\n    public void setClassName(String className) &#123;\n        this.className = className;\n    &#125;\n    public List&lt;PropertyDefinition&gt; getPropertys() &#123;\n        return propertys;\n    &#125;\n    public void setPropertys(List&lt;PropertyDefinition&gt; propertys) &#123;\n        this.propertys = propertys;\n    &#125;\n&#125;\nMyClassPathXMLApplicationContext1package junit.test;\n\nimport java.beans.Introspector;\nimport java.beans.PropertyDescriptor;\nimport java.lang.reflect.Method;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.dom4j.Document;\nimport org.dom4j.Element;\nimport org.dom4j.XPath;\nimport org.dom4j.io.SAXReader;\n/**\n * 自己的容器\n * @author Administrator\n *\n */\npublic class MyClassPathXMLApplicationContext1 &#123;\n    private List&lt;BeanDefinition&gt; beanDefines = new ArrayList&lt;BeanDefinition&gt;();\n    private Map&lt;String, Object&gt; sigletons = new HashMap&lt;String, Object&gt;();\n    // 存放bean实例\n\n    public MyClassPathXMLApplicationContext1(String filename)&#123;\n        // 模拟内部的实现，首先要读取配置文件，可以用dom4j \n        this.readXML(filename);\n        // 读取完bean之后，Spring要对bean进行实例化，怎么实现实例化呢？ 通过反射机制就很容易做到\n        this.instanceBeans();\n        this.injectObject();\n    &#125;\n\n    /**\n     * 为bean对象的属性注入值\n     */\n    private void injectObject() &#123;\n        for(BeanDefinition beandefinition : beanDefines)&#123;\n            Object bean = sigletons.get(beandefinition.getId());\n            if(bean != null)&#123;\n                try &#123;\n                    PropertyDescriptor[] ps = Introspector.getBeanInfo(bean.getClass()).getPropertyDescriptors();\n                    for(PropertyDefinition propertyDefinition: beandefinition.getPropertys())&#123;\n                        for(PropertyDescriptor properdesc : ps)&#123;\n                            if(propertyDefinition.getName().equals(properdesc.getName()))&#123;\n                                Method setter = properdesc.getWriteMethod();//获取属性的setter方法\n                                if(setter != null)&#123;\n                                    Object value = sigletons.get(propertyDefinition.getRef());\n                                    setter.setAccessible(true);//允许访问private方法\n                                    setter.invoke(bean, value);//把引用对象注入到属性\n                                &#125;\n\n                            &#125;\n                        &#125;\n                    &#125;\n                &#125; catch (Exception e) &#123;\n                &#125;\n            &#125;\n        &#125;\n\n    &#125;\n    /**\n     * 完成bean的实例化\n     */\n    private void instanceBeans() &#123;\n        for(BeanDefinition beanDefinition : beanDefines)&#123;\n            try &#123;\n                if(beanDefinition.getClassName()!=null &amp;&amp; !&quot;&quot;.equals(beanDefinition.getClassName().trim()))\n                    sigletons.put(beanDefinition.getId(), Class.forName(beanDefinition.getClassName()).newInstance());\n            &#125; catch (Exception e) &#123;\n                e.printStackTrace();\n            &#125;\n        &#125;\n\n    &#125;\n    /**\n     * 读取xml配置文件\n     * @param filename\n     */\n    private void readXML(String filename) &#123;\n           SAXReader saxReader = new SAXReader();   \n            Document document=null;   \n            try&#123;\n             URL xmlpath = this.getClass().getClassLoader().getResource(filename);\n             document = saxReader.read(xmlpath);\n             Map&lt;String,String&gt; nsMap = new HashMap&lt;String,String&gt;();\n             nsMap.put(&quot;ns&quot;,&quot;http://www.springframework.org/schema/beans&quot;);//加入命名空间\n             XPath xsub = document.createXPath(&quot;//ns:beans/ns:bean&quot;);//创建beans/bean查询路径\n             xsub.setNamespaceURIs(nsMap);//设置命名空间\n             List&lt;Element&gt; beans = xsub.selectNodes(document);//获取文档下所有bean节点 \n             for(Element element: beans)&#123;\n                String id = element.attributeValue(&quot;id&quot;);//获取id属性值\n                String clazz = element.attributeValue(&quot;class&quot;); //获取class属性值        \n                BeanDefinition beanDefine = new BeanDefinition(id, clazz);\n                XPath propertysub = element.createXPath(&quot;ns:property&quot;);\n                propertysub.setNamespaceURIs(nsMap);//设置命名空间\n                List&lt;Element&gt; propertys = propertysub.selectNodes(element);\n                for(Element property : propertys)&#123;\n                    String propertyName = property.attributeValue(&quot;name&quot;);\n                    String propertyRef = property.attributeValue(&quot;ref&quot;);\n                    System.out.println(propertyName + &quot;;&quot; + propertyRef);\n                    PropertyDefinition propertyDefinition = new PropertyDefinition(propertyName, propertyRef);\n                    beanDefine.getPropertys().add(propertyDefinition);\n                &#125;\n                beanDefines.add(beanDefine);\n             &#125;   \n            &#125;catch(Exception e)&#123;   \n                e.printStackTrace();\n            &#125;\n    &#125;\n    /**\n     * 获取bean实例\n     * @param beanName\n     * @return\n     */\n    public Object getBean(String beanName)&#123;\n        return this.sigletons.get(beanName);\n    &#125;\n&#125;\nTestSpring@Test\npublic void getBeanByMine1()&#123;\n    MyClassPathXMLApplicationContext1 context = new MyClassPathXMLApplicationContext1(&quot;beans.xml&quot;);\n    PersonService bean = (PersonService) context.getBean(&quot;personService&quot;);\n    //通过自定义的Spring容器得到这个bean \n    bean.save();\n&#125;\n说明\n运行单元测试代码，如果是空指针异常，则注入不成功；如果注入成功，则打印add里面的语句。\n\n结果控制台输出的是：\n  personDao;personDao\n  我被实例化了\n  执行PersonDaoBean里的add()方法\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean","依赖注入"]},{"title":"Spring管理的Bean的生命周期","url":"https://java4u.cn/spring/spring/Spring管理的Bean的生命周期/","content":"Bean实例化之后的初始化工作实现接口\norg.springframework.beans.factory.InitializingBean 接口指定一个单一的方法：\n  void afterPropertiesSet() throws Exception;\n\n因此，你可以简单地实现上述接口和初始化工作可以在 afterPropertiesSet() 方法中执行，如下所示：\n  public class PersionServiceBean implements InitializingBean &#123;\n     public void afterPropertiesSet() &#123;\n        // do some initialization work\n     &#125;\n  &#125;\n\n\nXML配置\n在基于 XML 的配置元数据的情况下，你可以使用 init-method 属性来指定带有 void 无参数方法的名称。例如：\n  &lt;bean id=&quot;persionService&quot;\n      class=&quot;com.liuyong666.service.impl.PersionServiceBean&quot;\n      init-method=&quot;init&quot;/&gt;\n\n下面是类的定义：\n  public class PersionServiceBean &#123;\n     public void init() &#123;\n        // do some initialization work\n     &#125;\n  &#125;\n\n\nBean销毁之前的工作实现接口\norg.springframework.beans.factory.DisposableBean 接口指定一个单一的方法：\n  void destroy() throws Exception;\n\n因此，你可以简单地实现上述接口并且结束工作可以在 destroy() 方法中执行，如下所示：\n  public class PersionServiceBean implements DisposableBean &#123;\n         public void destroy() &#123;\n        // do some destruction work\n         &#125;\n  &#125;\n\n\nXML配置\n在基于 XML 的配置元数据的情况下，你可以使用 destroy-method 属性来指定带有 void 无参数方法的名称。例如：\n  &lt;bean id=&quot;persionService&quot; \n      class=&quot;com.liuyong666.service.impl.PersionServiceBean&quot; \n      destroy-method=&quot;destroy&quot;/&gt;    \n\n下面是类的定义：\n  public class PersionServiceBean &#123;\n     public void destroy() &#123;\n        // do some destruction work\n     &#125;\n  &#125;\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean"]},{"title":"配置Spring管理的bean的作用域","url":"https://java4u.cn/spring/spring/配置Spring管理的bean的作用域/","content":"配置Spring管理的bean的作用域.singleton\n在每一个spring IoC容器中一个bean定义只有一个对象实例。默认情况下会在容器启动时初始化bean，但我们可以指定bean节点的lazy-init = “true”来延迟初始化bean，这时候，只有第一次获取bean才会初始化bean。如下：\n  &lt;bean id=&quot;persionService&quot; \n      class=&quot;com.liuyong666.service.impl.PersionServiceBean&quot;  \n      lazy-init = &quot;ture&quot;/&gt;\n\n\n\n如果想对所有bean都应用延迟初始化，可以在节点beans设置default-lazy-init = “ture” ,如下：\n  &lt;beans default-lazy-init = &quot;ture&quot;.../&gt;\n\n\n.prototype\n每次从容器获取bean都是新的对象。\n\n在第一次获取bean时初始化\n  &lt;bean id=&quot;persionService&quot; \n      class=&quot;com.liuyong666.service.impl.PersionServiceBean&quot; \n      scope=&quot;prototype&quot;/&gt;\n\n\n.request.session.global session\n\n","categories":["spring"],"tags":["spring","ssh","bean"]},{"title":"struts2中自定义类型转换器之全局类型转换器","url":"https://java4u.cn/struts2/struts2/struts2中自定义类型转换器之全局类型转换器/","content":"全局类型转换器\n如果业务需求所有的日期都要转换，则可以使用全局类型转换器，只要在src根目录下面放置xwork-conversion.properties文件,并且properties文件中的内容为： 待转换的类型=类型转换器的全类名 \n如：Java.util.Date = com.liuyong666.type.converter.DateTypeConverter。 \n总体目录结构：\n\n局部类型转换器和全局类型转换器的说明\n局部类型转换器是对指定action指定属性进行转换。不管该action的该属性是数组还是List集合，该转换器的转换方法对该属性只转换一次，假设某个action有一个List类型的属性users，那么局部类型转换器只调用一次convertValue方法，该方法吧users请求参数一次性地转换为一个List集合对象。 \n全局类型转换器会对所有action的特定类型进行转换。如果一个action的某个需要转换的属性是数组或集合，那么全局类型转换器将不是对该集合或数组整体进行转换，而是对该集合或数组的每一个属性进行转换。 \n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","类型转换器"]},{"title":"struts2中自定义类型转换器之局部类型转换器","url":"https://java4u.cn/struts2/struts2/struts2中自定义类型转换器之局部类型转换器/","content":"Struts2自定义类型转换器\n应用中，常需要将字符串请求参数转换为相应的数据类型，或将一定的数据类型类型转换为字符串显示显示给用户，Struts2提供了类型转换机制。 \nStruts2的类型转换是基于OGNL表达式的，只要我们把HTML输入项（表单元素和其他GET/POET的参数）命名为合法的OGNL表达式，就可以充分利用Struts2的转换机制。 \n除此之外，Struts2提供了很好的扩展性，可以实现自己的类型转换器，完成字符串和自定义复合类型之间的转换。总之，Struts2的类型转换器提供了非常强大的表现层数据处理机制，可以利用Struts2的类型转换机制来完成任意的类型转换。\nStruts2自定义类型转换器分为局部类型转换器和全局类型转换器。\n局部类型转换器：对某个action起作用\n全局类型转换器：对所有的action起作用\n\n\n\n局部类型转换器\n如果页面传来一个参数xxx.action?birthday=20160527到后台action，然后action属性用Date类型进行接收，用Date类型是获取不到，并且会出现错误的，struts2提供了一种类型转换器供我们使用。 \n以下为局部类型转换器的开发步骤： \n首先要写一个类来继承DefaultTypeConverter\n然后覆盖convertValue这个方法，在里面进行数据转型\n在action类所在的包下放置ActionClassName-conversion.properties文件，ActionClassName是简单类名，后面的-conversion.properties是固定写法，如： HelloWorldAction-conversion.properties\nProperties文件里面的内容为：action中属性名称=类型转换器的全类名(既包名.类名) ，如:birthday=com.liuyong666.type.converter.DateTypeConverter\n\n\n\n案例1.action类package com.liuyong666.action;\nimport java.util.Date;\n\npublic class HelloWorldAction &#123;//?birthday=2016-05-27\n    private Date birthday;\n\n    public Date getBirthday() &#123;\n        return birthday;\n    &#125;\n\n    public void setBirthday(Date birthday) &#123;\n        System.out.println(birthday);\n        this.birthday = birthday;\n    &#125;\n\n    public String addUI()&#123;\n        return &quot;success&quot;;\n    &#125;\n\n    public String execute() throws Exception&#123;\n        return &quot;success&quot;;\n    &#125;\n&#125;\n2.自定义类型转换类package com.liuyong666.type.converter;\n\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Map;\n\nimport com.opensymphony.xwork2.conversion.impl.DefaultTypeConverter;\n\npublic class DateTypeConverter extends DefaultTypeConverter &#123;\n\n    @Override\n    public Object convertValue(Map&lt;String, Object&gt; context, Object value, Class toType) &#123;\n        SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyyMMdd&quot;);\n        try &#123; \n            if(toType == Date.class)&#123;//当字符串向Date类型转换时\n                String[] params = (String[]) value;// request.getParameterValues() \n                return dateFormat.parse(params[0]);\n            &#125;else if(toType == String.class)&#123;//当Date转换成字符串时\n                Date date = (Date) value;\n                return dateFormat.format(date);\n            &#125;\n        &#125; catch (ParseException e) &#123;&#125;\n        return null;\n    &#125;\n&#125;\n3.配置\n配置DateTypeConverter自定义类型转换，在com.liuyong666.action的包下创建HelloWorldAction-conversion.properties文件birthday=com.liuyong666.type.converter.DateTypeConverter\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","类型转换器"]},{"title":"模拟spring自定义上下文获取bean","url":"https://java4u.cn/spring/spring/模拟spring自定义上下文获取bean/","content":"模拟spring自定义上下文获取bean\n利用dom4j解析\n\n设置两个域，一个List存放BeanDefinition，一个Map存放实例化对象的映射\n\n构造器传配置文件进去，依次执行两个方法\n\n方法1，读取配置文件，把解析出的BeanDefinition放入List中\n方法2，完成bean的实例化，把实例化对象的映射放入Map中\n\n\n定义获取bean实例的方法，从Map中根据实例名返回Object对象\n      import java.net.URL;\n      import java.util.ArrayList;\n      import java.util.HashMap;\n      import java.util.List;\n      import java.util.Map;\n\n      import org.dom4j.Document;\n      import org.dom4j.Element;\n      import org.dom4j.XPath;\n      import org.dom4j.io.SAXReader;\n      /**\n       * 自己的容器\n       * @author Administrator\n       *\n       */\n      public class MyClassPathXMLApplicationContext &#123;\n          private List&lt;BeanDefinition&gt; beanDefines = new ArrayList&lt;BeanDefinition&gt;();\n          private Map&lt;String, Object&gt; sigletons = new HashMap&lt;String, Object&gt;();\n\n          public MyClassPathXMLApplicationContext(String filename)&#123;\n              this.readXML(filename);\n              this.instanceBeans();\n          &#125;\n          /**\n           * 完成bean的实例化\n           */\n          private void instanceBeans() &#123;\n              for(BeanDefinition beanDefinition : beanDefines)&#123;\n                  try &#123;\n                      if(beanDefinition.getClassName()!=null &amp;&amp; !&quot;&quot;.equals(beanDefinition.getClassName().trim()))\n                          sigletons.put(beanDefinition.getId(), Class.forName(beanDefinition.getClassName()).newInstance());\n                  &#125; catch (Exception e) &#123;\n                      e.printStackTrace();\n                  &#125;\n              &#125;\n\n          &#125;\n          /**\n           * 读取xml配置文件\n           * @param filename\n           */\n          private void readXML(String filename) &#123;\n                 SAXReader saxReader = new SAXReader();   \n                  Document document=null;   \n                  try&#123;\n                   URL xmlpath = this.getClass().getClassLoader().getResource(filename);\n                   document = saxReader.read(xmlpath);\n                   Map&lt;String,String&gt; nsMap = new HashMap&lt;String,String&gt;();\n                   nsMap.put(&quot;ns&quot;,&quot;http://www.springframework.org/schema/beans&quot;);//加入命名空间\n                   XPath xsub = document.createXPath(&quot;//ns:beans/ns:bean&quot;);//创建beans/bean查询路径\n                   xsub.setNamespaceURIs(nsMap);//设置命名空间\n                   List&lt;Element&gt; beans = xsub.selectNodes(document);//获取文档下所有bean节点 \n                   for(Element element: beans)&#123;\n                      String id = element.attributeValue(&quot;id&quot;);//获取id属性值\n                      String clazz = element.attributeValue(&quot;class&quot;); //获取class属性值        \n                      BeanDefinition beanDefine = new BeanDefinition(id, clazz);\n                      beanDefines.add(beanDefine);\n                   &#125;   \n                  &#125;catch(Exception e)&#123;   \n                      e.printStackTrace();\n                  &#125;\n          &#125;\n          /**\n           * 获取bean实例\n           * @param beanName\n           * @return\n           */\n          public Object getBean(String beanName)&#123;\n              return this.sigletons.get(beanName);\n          &#125;\n      &#125;\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean"]},{"title":"【Spring 系列】二、spring三种实例化bean的方式","url":"https://java4u.cn/spring/spring/【Spring 系列】二、spring三种实例化bean的方式/","content":"【Spring 系列】二、spring三种实例化bean的方式\nbeans.xml中配置\n  &lt;!-- 三种实例化bean的方式 --&gt; &lt;!-- 1.使用类构造器实例化 --&gt;&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;&lt;/bean&gt;&lt;!-- 2.使用静态工厂方法实例化 --&gt;&lt;bean id=&quot;personService2&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBeanFactory&quot; factory-method=&quot;createPersonServiceBean&quot;&gt;&lt;/bean&gt;&lt;!-- 3.使用实例工厂方法实例化 --&gt;&lt;bean id=&quot;personServiceFactory&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBeanFactory&quot;&gt;&lt;/bean&gt;&lt;bean id=&quot;personService3&quot; factory-bean=&quot;personServiceFactory&quot; factory-method=&quot;createPersonServiceBean2&quot;&gt;&lt;/bean&gt;\n\n\nPersonServiceBeanFactory类\npackage com.liuyong666.service.impl;public class PersonServiceBeanFactory &#123;\t\tpublic static PersonServiceBean createPersonServiceBean()&#123;\t\treturn new PersonServiceBean();\t&#125;\t\tpublic PersonServiceBean createPersonServiceBean2()&#123;\t\treturn new PersonServiceBean();\t&#125;&#125;\n\n测试类\npublic class TestSpring &#123;\t\t/**\t\t * 使用spring框架获取bean\t\t */\t\t@Test\t\tpublic void getBeanBySpring()&#123;\t\t\tApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\t\t\tPersonService bean = (PersonService) context.getBean(&quot;personService&quot;);\t\t\tbean.save();\t\t&#125;\t\t/**\t\t * 使用静态工厂方法获取bean\t\t */\t\t@Test\t\tpublic void getBeanByStaticFactory()&#123;\t\t\tApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\t\t\tPersonService bean = (PersonService) context.getBean(&quot;personService2&quot;);\t\t\tbean.save();\t\t&#125;\t\t      \t/**\t * 使用实例工厂方法获取bean\t */\t@Test\tpublic void getBeanByInstantceFactory()&#123;\t\tApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;&quot;beans.xml&quot;&#125;);\t\tPersonService bean = (PersonService) context.getBean(&quot;personService3&quot;);\t\tbean.save();\t&#125;&#125;\n\n\n\n\n\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean"]},{"title":"【Spring 系列】一、如何从spring中获取bean","url":"https://java4u.cn/spring/spring/【Spring 系列】一、如何从spring中获取bean/","content":"【Spring 系列】一、如何从spring中获取bean\n导包\n\nspring要管理的类信息\n  package com.liuyong666.service.impl;\n  ​    \n  import com.liuyong666.service.PersonService;\n\n  public class PersonServiceBean implements PersonService &#123;\n      @Override\n      public void save()&#123;\n          System.out.println(&quot;我是save()方法&quot;);\n      &#125;\n\n  &#125;\n\nspring面向接口编程，该类对应的接口\n  public interface PersonService &#123;\n  ​        public abstract void save();  ​    }\n\n配置beans.xml文件，文件在src目录下&lt;bean id=&quot;personService&quot; class=&quot;com.liuyong666.service.impl.PersonServiceBean&quot;&gt;&lt;/bean&gt;\n\n使用spring获取bean\n  @Test\n  ​    public void getBeanBySpring(){  ​        //参数为数组表明可以加载多个配置文件  ​        ApplicationContext context = new ClassPathXmlApplicationContext(new String[]{“beans.xml”});  ​        //面向接口编程，用接口引用实现它的实例对象  ​        PersonService bean = (PersonService) context.getBean(“personService”);  ​        bean.save();  ​    }\n\n\n\n\n","categories":["spring"],"tags":["spring","ssh","bean"]},{"title":"struts2中请求参数接收","url":"https://java4u.cn/struts2/struts2/struts2中请求参数接收/","content":"采用基本类型接受请求参数(get/post)\n在Action类中定义与请求参数同名的属性，struts2便能自动接收请求参数并赋予给同名的属性。\n\n请求路径：http://localhost:8080/action/xxx.action?id=66\n  public class HelloWorldAction &#123;\n      private Integer id;\n\n      public Integer getId() &#123;\n          return id;\n      &#125;\n\n      public void setId(Integer id) &#123;\n          this.id = id;\n      &#125;\n  &#125;\n\n\n采用复合类型接受请求参数\n获取Bean属性的原理：\n\nStruts2首先通过反射技术调用Person的默认构造器创建person的实例，然后再通过反射技术调用person中与请求参数同名的属性的setter方法，来获取请求参数数值。\n\n\n请求路径：http://localhost:8080/action/xxx.action?person.id=1&amp;person.name=zhangsan\n\n实体bean\n  public class Person &#123;\n      private String name;\n      private Integer id;\n\n      public String getName() &#123;\n          return name;\n      &#125;\n\n      public void setName(String name) &#123;\n          this.name = name;\n      &#125;\n\n      public Integer getId() &#123;\n          return id;\n      &#125;\n\n      public void setId(Integer id) &#123;\n          this.id = id;\n      &#125;\n  &#125;\n\nHelloWorldAction类\n  public class HelloWorldAction &#123;\n      private Person person;\n\n      public Person getPerson() &#123;\n          return person;\n      &#125;\n\n      public void setPerson(Person person) &#123;\n          this.person = person;\n      &#125;\n  &#125;\n\n\n请求页面&lt;body&gt;\n    &lt;!-- get方法发送，如果是中文则会出现乱码，post不会，好像struts2.1.8有修正此问题\n    基本类型get请求参数: http://localhost:8080/action/xxx.action?id=66\n    复合类型get请求参数: http://localhost:8080/action/xxx.action?person.id=1&amp;person.name=zhangsan--&gt;\n\n    &lt;!-- post方法发送 --&gt;\n    &lt;form action=&quot;&lt;%=request.getContextPath()%&gt;/xxx.action&quot; method=&quot;post&quot;&gt;\n        &lt;!-- 基本类型请求参数 --&gt;\n        id:&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br/&gt;\n        name:&lt;input type=&quot;text&quot; name=&quot;name&quot;&gt;&lt;br/&gt;\n\n        &lt;!-- 复合类型请求参数 --&gt;\n        person.id:&lt;input type=&quot;text&quot; name=&quot;person.id&quot;&gt;&lt;br/&gt;\n        person.name:&lt;input type=&quot;text&quot; name=&quot;person.name&quot;&gt;&lt;br/&gt;\n        &lt;input type=&quot;submit&quot; value=&quot;发送&quot;/&gt;\n    &lt;/form&gt;\n&lt;/body&gt;\n显示页面&lt;body&gt;\n    &lt;!-- 输出基本类型请求参数 --&gt;\n    id=$&#123;id&#125;&lt;br/&gt;\n    name=$&#123;name&#125;&lt;br/&gt;\n\n    &lt;!-- 输出复合类型请求参数 --&gt;\n    person.id=$&#123;person.id &#125;&lt;br/&gt;\n    person.name=$&#123;person.name &#125;&lt;br/&gt;\n&lt;/body&gt;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n","categories":["struts2"],"tags":["ssh","struts2","请求参数"]},{"title":"集合包之List","url":"https://java4u.cn/Java/Java/集合包之List/","content":"\n集合包\nCollection：多个单对象\nMap：键值对\n\n\n\nArrayList\n实现：\n\n数组实现\n\n\nadd(E)\n\n更新minCapacity为已有数量+1\n和Object数组比大小\n若minCapacity大，将当前数组赋给一个数组对象，新容量为old * 1.5 + 1\n若数组新容量大小仍小于minCapacity，更新minCapacity为新容量值\n\n\n调用Arrays.CopyOf生成新数组对象\n添加元素E进入数组\n\n\nremove(E)\n\n判断E是否为null\n是，找出null，调用fastRemove完成对象的删除\n否，equals比较，调用fastRemove\n\n\n\n\nremove(int)\n\n相比较remove(E)，多了数组范围检测\n少了对象位置查找，性能更好\n\n\nget(int)\n\n获取单个对象\n先进行数组范围检测\n然后直接返回\n\n\n\n\niterator()\n\n遍历对象\nAbstractList的实现\nhasNext()\nnext()\n获取的modCount与当前的modCount比较\n不等，集合大小发生改变，抛ConcurrentModificationException\n等\n若游标cursor &gt;= 集合大小，抛NoSuchElementException\n若当前cursor &gt;= 数组长度，抛ConcurrentModificationException\ncursor + 1，返回元素\n\n\n\n\n\n\n\n\ncontains(E)\n\n判断对象是否存在\n遍历，E为null，==判断；E不为null，E.equals判断\n\n\nindexOf(E)\n\n从前向后遍历\n\n\nlastIndexOf(E)\n\n从后向前遍历\n\n\n\nArrayList要点\n数组实现，无容量限制\n插入扩容，删除不减容(想缩小可调用trimToSize())\n查找遍历，非null用equals找\n非线程安全\n\nLinkedList\n实现\n\n双向链表\nEntry：element，next，privious\n\n\n创建\n\n创建属性均为null的Entry对象，并赋值给全局的header属性\n在执行构造器时，LinkedList将header的next及previous都指向header，以形成双向链表所需的闭环\n\n\nadd(E)\n\n创建Entry，next指向header，previous指向header.previous\n不用考虑扩容及复制数组\n但每次+1需创建Entry，修改相邻两个元素的属性\n\n\nremove(E)\n\n遍历，删除当前，置element，previous及next为null\n\n\nget(int)\n\n比ArrayList复杂\n判断int合法性\n判断是否小于LinkedList的一半\n是，从头开始，利用next\n否，从尾开始，利用previous\n\n\n\n\niterator()\n\n创建ListItr对象，负责保存cursor位置\nnext()，若出现增删，抛异常\n也可用hasPrevious()和previous来遍历\n\n\n\nLinkedList要点\n双向链表实现\n插入创建新Entry，切换前后引用\n查找，遍历链表\n删除，遍历链表，找到删除\n非线程安全\n\nVector\n实现方式\n\nObject数组\n\n\nVector()\n\n大小为10，capacityIncrement = 0\n\n\nadd(E)\n\n加synchronized关键字\n扩容策略与ArrayList不同\n若capInc &gt; 0 ，扩大为size + capInc\n否则，扩大为 size * 2\n\n\n比ArrayList更可控\n\n\nremove(E)\n\nArrayList上+ synchronized\n\n\nget(int)\n\n在ArrayList上+ synchronized\n\n\niterator()\n\n同ArrayList\n\n\ncontains(E)\n\n方法中调用的indexOf有同步关键字\n\n\nVector除扩大数组方法和ArrayList不同及线程安全外，其他实现完全相同\n\n\nVector要点\nVector是基于synchronized实现的线程安全的ArrayList\n扩容机制不同，可通过传入capacityIncrement控制容量补充\n\nStack\n实现方式\n\n继承于Vector，并实现LIFO的弹出及压入操作\n\n\npush\n\n调用Vector中add完成\n\n\npop\n\n调用peek获取，同时删除数组最后一个\n\n\npeek\n\n获取当前Object数组大小，并获取最后一个元素\n\n\n\n要点\nStack基于Vector，支持FIFO\n\n\n\n","categories":["Java"],"tags":["Java","分布式","集合","List"]},{"title":"Java分布式之性能调优","url":"https://java4u.cn/Java/Java/Java分布式之性能调优/","content":"\n\n寻找性能瓶颈CPU消耗分析　　Linux中，CPU主要用于中断、内核以及用户进程的任务处理，优先级为中断&gt;内核&gt;用户进程\n\n上下文切换\n\n每个CPU同一时间只能执行一个线程，Linux采用抢占式调度\n发生条件：\n到达执行时间\nI/O阻塞\n高优先级线程要执行\nJava中：\n文件I/O\n网络I/O\n锁等待\n线程sleep\n\n\n\n\n缺点：\n切换过多，造成内核占据较多的CPU使用，使应用的响应速度下降\n\n\n\n\n运行队列\n\n每个CPU核都维护了一个可运行的线程队列。\n运行队列值越大，意味着线程会消耗越长的时间才能执行完\n\n\n利用率\n\nCPU在用户进程、内核、中断处理、IO等待以及空闲五个部分使用百分比\nLinux中，top或pidstat可查看进程中线程的CPU消耗状况\ntop命令第3行为CPU信息\nus表示用户进程百分比\nsy表示内核进程\nni表示被nice命令改变优先级的任务所占的百分比\nid表示CPU的空闲时间\nwa表示在执行过程中等待IO\nhi表示硬件中断\nsi表示软件中断\nshift+h 可切换Tasks和Threads\n\n\npidstat 需要安装sysstat\npidstat 1 2 表示隔一秒输出，共输出2次\npidstat -p [pid] -t 1 5 某进程中线程的CPU消耗情况\ntid为线程ID，该命令优点，可查看每个线程具体CPU利用率的状况\n\n\nvmstat\n采样查看CPU的上下文切换，运行队列，利用率的具体信息\n\n\n\n\n\n\n\n文件IO消耗分析　　Linux在操作文件时，将数据放入文件缓存区，直到内存不够或系统要释放内存给用户进程使用。故free经常不多，cached用了很多。这是Linux提升文件IO速度的一种做法。\n\n在这种做法下，如物理空闲内存够用，通常在Linux上只有写文件和第一次读取文件时会产生真正的文件IO\n\npidstat 跟踪线程的文件IO的消耗\n\npid -d -t -p [pid] 1 100\nKB_rd/s 每秒读取的KB数\nKB_wr/s 每秒写入的KB数\n\n\niostat 可查看各个设备的IO历史状况\n\nDevice ：设备卷标名或分区名\ntps：每秒的IO请求数\nKB_read/s\nKB_wrtn/s\nKB_read\nKB_wrtn\n\n\niostat -x xvda 3 5 定时采样查看IO消耗情况\n\nr/s：每秒读的请求数\nw/s：每秒写的请求数\nawait：平均每次IO操作的等待时间\navgqu-sz：等待请求的队列的平均长度\nsvctm：平均每次设备执行IO操作的时间\nutil：一秒之中有百分之几用于IO操作\n\n\n使用iostat要关注iowait%\n\nJava应用造成IO消耗严重：\n\n主要是多个线程需要进行大量内容写入(例如频繁的日志写入)的动作\n磁盘设备本身的处理速度慢\n文件系统慢\n操作的文件本身已经很大\n\n\n\n网络IO消耗分析　　Linux中采用sar分析网络IO的消耗\n\nsar\nsar -n ALL 1 2\n得到三部分：\n网卡上成功的接包和发包信息。rxpck/s,txpck/s,rxbyt/s,rxmcst/s\n网卡上失败的接包和发包信息。rxerr/s,txerr/s,rxdrop/s,txdrop/s\nsocket上的统计信息。tolsck,tcpsck,udpsck,rawsck\n\n\n\n\n\n内存消耗分析　　Java应用对内存的消耗主要在ＪＶＭ堆内存上。正式环境中，－Xms和-Xmx设为相同的值，避免运行期要不断申请内存。\n\nJava应用只有在创建线程和使用Direct ByteBuffer时才会操作JVM堆以外的内存。\n\n堆外内存消耗主要关注swap的消耗和物理内存的消耗，都可以基于OS提供的命令来查看\n\nLinux用vmstat，sar，top，pidstat\n\nvmstat\n\n和内存相关的有memory下的swpd，free，buff，cache，swap下的si和so\nswpd：虚拟内存已使用的部分,kb\nfree：空闲的物理内存\nbuff：缓冲的内存\ncache：作为缓存的内存\nsi：每秒从disk读至内存的数据量\nso：每秒从内存中写入disk的数据量\n物理内存消耗过多的原因:\nJVM内存设置过大\n创建的Java线程过多\n通过Direct ByteBuffer往物理内存放置了过多的对象\n\n\n\n\nsar\n\nsar -r 1 2\nsar相比vmstat的好处是，可以查询历史状况以更加准确的分析趋势状况\n共同弱点：不能分析进程所占用的内存量\n\n\ntop\n\ntop可查看进程所消耗的内存量\nJVM已分配内存+Java应用所耗费的JVM以外的物理内存\ntop很难判断出Java进程消耗的内存中，有多少是属于JVM的，有多少是消耗JVM以外的内存\n\n\npidstat\n\npidstat -r -p [pid] [interval] [times] 查看进程所消耗的内存量\n最佳内存消耗分析方法是：\n结合top或pidstat以及JVM内存分析工具来共同分析内存消耗\n\n\n\n\n\n程序执行慢原因分析　　资源消耗不多，但程序执行慢，多出现在访问量不是非常大的情况下\n\n锁竞争激烈。例如：数据库连接池。\n未充分使用硬件资源。例如：双核CPU但程序使用单线程。\n数据量增长。例如：数据库单表100万记录增到1亿，读写速度下降。\n\n调优　　从硬件，操作系统，JVM，程序4个方面着手\nJVM调优\n主要是内存管理方面的调优\n各个代的大小\nGC策略\n\n\n代大小的调优\n关键参数：\n-Xms   \n-Xmx：与-Xms设置相同的值，避免运行时不断扩展JVM内存空间\n-Xmn：决定新生代空间的大小\n-XX:SurvivorRatio：Eden，s0，s1的比率\n-XX:MaxTenuringThreshold：控制对象在经历多少次Minor GC后才转入旧生代。这个值称为新生代存活周期。只在串行GC有效。\n\n\n\n\n策略：\n避免新生代大小设置过小\n过小产生的现象：\nMinor GC频繁\n可能导致Minor GC对象直接进入旧生代，若满，触发Full GC\n\n\n调整原则：\n尽可能放大新生代空间\n保证旧生代空间够用\n\n\n\n\n避免新生代设置过大\n过大产生现象：\n旧生代变小，Full GC频繁\nMinor GC耗时大幅度增加\n\n\n推荐新生代占JVM Heap区大小的33%。\n\n\n避免Survivor区过大或过小\nSurvivor区域变大，意味着可以存储更多在minor GC后仍存活的对象，避免其进入旧生代\n\n\n合理设置新生代存活周期\n-XX:MaxTenuringThreshold：默认15次\n\n\n\n\n\n程序调优　　根据资源的消耗情况\nCPU消耗严重的解决办法\nCPU us高的解决办法\n\n原因：\n执行线程无任何挂起动作，线程饿死\n解决办法：对这种线程的动作增加Thread.sleep()，以释放CPU的执行权，降低CPU的消耗\n\n\nGC频繁\n解决办法：JVM调优，降低GC执行次数\n\n\n\n\n\n\nCPU sy高的解决办法\n\n原因：\n线程的运行状态经常切换\n\n\n解决办法：\n减少线程数\n降低线程之间的锁竞争\n\n\nJava应用中可采用协程(coroutine)来支撑更高的并发量，避免并发量上涨后造成CPU sy消耗严重，系统load迅速上涨和系统性能下降(框架Kilim)。\n\n\n\n文件消耗严重的解决办法\n原因：\n多个线程在写大量的数据到同一文件\n导致文件很快变得很大\n从而写入速度越来越慢\n并造成各线程激烈争抢文件锁\n\n\n解决办法：\n异步写文件。例如：写日志，log4j的AsyncAppender。\n批量读写\n限流。将文件IO消耗控制到一个能接受的范围。\n限制文件大小。超过最大值生成一个新的文件。例如log4j中RollingFileAppender的maxFileSize。\n缓冲区读取文件内容\n\n\n\n网络IO消耗严重的解决办法\n原因：\n同时需要发送或接收的包太多\n\n\n解决办法：\n限流。限制发送packet的频率\n\n\n\n内存消耗严重的情况\n解决办法\n释放不必要的引用。例如，复用线程使用ThreadLocal，存放的对象如果未做主动释放的话则不会被GC。\n使用对象缓存池\n采用合理的缓存失效算法。放太多对象在缓存池中，会造成内存的严重消耗。控制缓存池大小的问题在于当到达缓存池最大容量后，如果要加入新的对象该如何处理：FIFO，LRU，LFU算法可控制缓存池中的对象数目。\n合理使用SoftReference和WeakReference。对于占据内存但又不是必须存在的对象，例如缓存对象，也可以基于SoftReference或WeakReference的方式进行缓存。\n\n\n\n对于资源消耗不多，但程序执行慢的情况\n原因：\n\n锁竞争激烈\n未充分发挥硬件资源\n\n\n锁竞争激烈：\n\n线程多了后，锁竞争明显，线程容易处在等待锁的状况，从而导致性能下降，以及CPU sy上升。\n解决办法：\n使用并发包的类\n使用Treiber算法\n使用MichaelScott非阻塞队列算法(ConcurrentLinkedQueue)。以上两种算法都基于CAS以及AtomicReference\n尽可能少用锁。让锁最小化，只对互斥及原子操作的地方加锁\n拆分锁。把独占锁拆分成多把锁。读写锁拆分。ConcurrentHashMap默认拆分成16把锁。缺点：全局性质操作变复杂，比如size。\n去除读写操作的互斥锁。在修改时加锁，并复制对象进行修改，修改完毕后切换对象的引用，而读取时则不加锁，CopyOnWrite。\n\n\n\n\n未充分使用硬件资源\n\n未充分使用CPU\n原因：\n并行处理的场景中未使用足够的线程\n\n\n\n\n未充分使用内存\n场景：\n数据缓存，耗时资源的缓存(数据库连接，网络连接)，页面片段的缓存\n\n\n\n\n\n\n\n\n\n","categories":["Java"],"tags":["Java","分布式","性能","调优"]},{"title":"16.Java存储模型","url":"https://java4u.cn/Java并发编程/Java并发编程/16-Java存储模型/","content":"\n高层的设计问题，比如安全发布、规约、以及遵守同步策略等等。它们的安全性得益于JMM，当你理解了这些机制会如此工作后，能发现可以更容易有效地使用它们。\n\n16.1 什么是存储模型，要它何用\n假设一个线程为变量a赋值：a = 3;\n存储模型要回答这个问题：“在什么条件下，读取a的线程会看到3这个值？”\n编译器生成指令的次序，可以不同于源代码所暗示的“显然”的版本，而且编译器还会把变量存储在寄存器，而不是内存中；处理器可以乱序或者并行地执行指令；缓存会改变写入提交到主内存的变量的次序；最后，存储在处理器本地缓存中的值，对于其他处理器并不可见。这些因素都会妨碍一个线程看到一个变量的最新值，而且会引起内存活动在不同的线程中表现出不同的发生次序——如果你没有适当同步的话。\nJava语言规范规定了JVM要维护内部线程类似顺序化语意：只要程序的最终结果等同于它在严格的顺序化环境中执行的结果，那么上述所有行为是允许的。\n最近几年，重新排序后的指令使得程序在计算性能上得到了很大的提升。对性能提升作出贡献的，除了越来越高的时钟频率，还有不断提升的并行性——管道超标量体系结构执行单元，动态指令调度，试探性执行以及成熟的多级存储缓存。\n\n\n\n\n只有当多个线程要共享数据时，才必须协调它们的活动；协调是通过使用同步完成的，JVM依赖于程序明确地指出何时需要协调线程的活动。\nJVM规定了JVM的一种最小保证：什么时候写入一个变量会对其他线程可见。\n\n16.1.1 平台的存储模型\n处理器架构提供了不同级别的缓存一致性；有些只提供最小的保证，几乎在任何时间内，都允许不同的处理器在相同的存储位置上看到不同的值。\n顺序一致性模型：操作执行顺序唯一，与执行它们的处理器无关。未实现。冯诺伊曼模型，这个经典的顺序化计算模型，仅仅是现代多处理行为的模糊近似而已。\n结论：跨线程共享数据，可能会产生不同执行结果。除非你已经使用存储关卡，通知它们不要这样做。好在Java中不用，只要在访问共享状态时能够识别到它们就可以了。通过正确的使用同步，可以做到这些。\n\n16.1.2 重排序\n内存级的重排序(reordering)会让程序的行为变得不可预期。没有同步，推断执行次序的难度令人望而却步；只需要确保你的程序已正确同步，事情就会变得简单些。同步抑制了编译器、运行时和硬件对存储操作的各种方式的重排序，否则这些重排序将会破坏JMM提供的可见性保证。\n\n16.1.3 Java存储模型的简介\nJava存储模型的定义是通过**动作(action)**的形式进行描述的，所谓动作，包括\n\n变量的读和写、\n监视器加锁和释放锁、\n线程的启动和拼接(join)。\n\n\nJMM为所有程序内部的动作定义了一个偏序关系，叫做happens-before。要想保证执行动作B的线程看到动作A的结果(无论A和B是否在同一个线程中)，A和B之间就必须满足happens-before关系。如果两个操作之间并未依照happens-before关系排序，JVM可以对它们随意地重排序。\n\n当一个变量被多个线程读取，且至少被一个线程写入时，如果读写操作并未依照happens-before排序，就会产生**数据竞争(data race)**。一个正确同步的程序是没有数据竞争的程序；正确同步的程序会表现出顺序的一致性，这就是说所有程序内部的动作会以固定的、全局的顺序发生。\n\nhappens-before的法则包括：\n\n程序次序法则：线程中的每个动作A都happens-before于该线程中的每一个动作B，其中，在程序中，所有的动作B都出现在动作A之后。\n监视器锁法则：对一个监视器锁的解锁happens-before于每一个后续对同一监视器锁的加锁。\nvolatile变量法则：对volatile域的写入操作happens-before于每一个后续对同一个域的读操作\n线程启动法则：在一个线程里，对Thread.start的调用会happens-before于每一个启动线程中的动作。\n线程终结法则：线程中的任何动作都happens-before于其他线程检测到这个线程已经终结、或者从Thread.join调用中成功返回，或者Thread.isAlive返回false。\n中断法则：一个线程调用另一个线程的interrupt happens-before 于被中断线程发现中断(通过抛出 InterruptedException，或者调用isInterrupted和interrupted)。\n终结法则：一个对象的构造函数的结束happens-before于这个对象finalizer的开始。\n传递性：如果A happens-before 于B，且B happens-before 于C， 则 A happens-before 于C。\n\n\n虽然动作仅仅需要满足偏序关系，但是同步动作——锁的获取与释放，以及volatile变量的读取与写入——却是满足全序关系。\n\n\n\n16.1.4 “驾驭”在同步之上\n由类库担保的其他happens-before排序包括：\n将一个条目置入线程安全容器happens-before于另一个线程从从容器中获取条目\n执行CountDownLatch中的倒计时happens-before于线程从闭锁(latch)的await中返回。\n释放一个许可给Semaphore happens-before 于同一 Semaphore里获得一个许可。\nFuture 表现的任务所发生的动作 happens-before 于另一个线程成功地从Future.get中返回。\n向Executor提交一个Runnable 或 Callable happens-before 于开始执行任务。\n最后一个线程到达CyclicBarrier 或 Exchanger happens-before于相同关卡(barrier)或Exchange点中的其他线程被释放。如果CyclicBarrier使用一个关卡动作，到达关卡happens-before 于关卡动作，依照次序，关卡动作happens-before于线程从关卡中释放。\n\n\n\n16.2 发布\n第三章我们探究了一个对象是如何被正确或不正确地发布出去的。当时描述的安全发布技术之所以是安全的，正是得益于JMM提供的保证；而为不正确发布带来风险的真正原因，是在“发布共享对象”与从“另一个线程访问它”之间，缺少happens-before排序。\n\n16.2.1 不安全的发布//不安全的惰性初始化(不要这样做)\n@NotThreadSafe\npublic class UnsafeLazyInitialization &#123;\n    private static Resource resource;\n\n    public static Resource getInstance() &#123;\n        if (resource == null)\n            resource = new Resource(); // unsafe publication\n        return resource;\n    &#125;\n    static class Resource &#123;\n    &#125;\n&#125;\n\n假设第一次调用getInstance的是线程A。它会看到resource是null，接着初始化一个新的Resource，然后设置resource引用这个新实例。随后线程B调用getInstance，它可能看到resource已经有了一个非空的值，于是就使用这个已经创建的Resource。这最初看起来可能无害，但是线程A写入resource与线程B读取resource之间，不是按照happens-before进行排序的。发布对象时存在数据竞争，因此B并不能保证可以看到Resource的正确状态。\n在新分配一个Resource时，Resource的构造函数会把实例的域从默认值转变到它们的初始值。由于两个线程都没有用到同步，因此B看到的A的动作，可能与A执行它们时的顺序并不相同。所以即使A是先初始化Resource，再设置resource引用它的，B也可以看到写入resource的动作会先于写入Resource域的发生。B可能因此看到一个部分构建的Resource，它可能处于非法的状态——在后期，它的状态可能出现无法预料的改变。\n\n\n除了不可变对象以外，使用被另一个线程初始化的对象，是不安全的，除非对象的发布是happens-before于对象的消费线程使用它。\n\n16.2.2 安全发布\n如果线程A将X置入BlockingQueue(并且随后没有线程修改它)，线程B从队列中获取X，可以保证B看到的X就是A留下的那个。这是因为在BlockingQueue的实现中，B进行了充足的内部同步，确保了put happens-before于take。类似的，使用锁保护内部共享变量，或者使用共享的volatile类型变量，也可以保证对该变量的读取和写入是按照happens-before排序的。\nhappens-before事实上可以比安全发布承诺更强的可见性与排序性。如果X从A到B是安全发布的，安全发布可以保证X的状态的可见性，但不包括A可能触及到的其他变量的状态。但是，如果A将X置入队列happens-before于B从队列中获取X。B不仅仅能看到A移交X前所作的每件事情。\n\n16.2.3 安全初始化技巧//线程安全的惰性初始化\n@ThreadSafe\npublic class SafeLazyInitialization &#123;\n    private static Resource resource;\n\n    public synchronized static Resource getInstance() &#123;\n        if (resource == null)\n            resource = new Resource();\n        return resource;\n    &#125;\n    static class Resource &#123;\n    &#125;\n&#125;\n\n上锁提供额外的线程安全性保证。这个锁每个线程都至少会用到一次，来确保一个类是否已被加载；这个锁也保证了静态初始化期间，内存写入的结果自动地对所有线程是可见。所以静态初始化的对象，无论是构造期间还是被引用的时候，都不需要显式的进行同步。\n\n    //主动初始化\n    @ThreadSafe\n        public class EagerInitialization &#123;\n        private static Resource resource = new Resource();\n\n        public static Resource getResource() &#123;\n            return resource;\n        &#125;\n        static class Resource &#123;\n        &#125;\n    &#125;\n\n使用主动的初始化，避免同步开销。这项技术可以和JVM的惰性类加载相结合，创建一种惰性初始化技术，使得在通常的代码路径中都不需要同步。\n  //惰性初始化holder类技巧\n  @ThreadSafe\n  public class ResourceFactory &#123;\n      private static class ResourceHolder &#123;\n          public static Resource resource = new Resource();\n      &#125;\n\n      public static Resource getResource() &#123;\n          return ResourceFactory.ResourceHolder.resource;\n      &#125;\n      static class Resource &#123;\n      &#125;\n  &#125;\n\nResourceFactory是专门用来初始化Resource的类。JVM将ResourceHolder的初始化被延迟到真正使用它的时刻。因为Resource是在静态初始阶段进行初始化的，所以不需要额外的同步。线程第一次调用getResource，引起ResourceHolder的加载和初始化，这个时候，正是在静态初始阶段Resource完成初始化发生的时间。\n\n\n16.2.4 双检查锁(double-checked locking)\n惰性初始化在通常的代码路径下，不需要在同步上花费时间。它运作的方式是，首先检查在没有同步的情况下检查是否需要初始化，如果resource不等于null，就用它。否则，就进行同步，并再次检查Resource是否需要同步，以保证只有唯一的线程真正地初始化了共享的Resource。\n\nDCL这个技巧已经被广泛地废弃了——催生它的动力(缓慢的无竞争同步和缓慢的JVM启动)已经不复存在，这使得优化的效果越来越不明显了。惰性初始化容器(lazy initialization holder)的模式提供了同样的好处，而且更易理解。\n  //双检查锁反模式 不要这样做\n  @NotThreadSafe\n  public class DoubleCheckedLocking &#123;\n      private static Resource resource;\n\n      public static Resource getInstance() &#123;\n          if (resource == null) &#123;\n              synchronized (DoubleCheckedLocking.class) &#123;\n                  if (resource == null)\n                      resource = new Resource();\n              &#125;\n          &#125;\n          return resource;\n      &#125;\n      static class Resource &#123;\n\n      &#125;\n  &#125;\n\n\n16.3 初始化安全性\n保证了初始化安全性，就可以让正确创建的不可变对象在没有同步的情况下，可以被安全地跨线程地共享，而不管它们是如何发布的——甚至发布时也存在数据竞争。\n\n假若没有初始化安全性，就会发生这样的事情：像String这样的不可变对象，没有在发布或消费线程中用到同步，可能表现出它们的值被改变。\n\n初始化安全性可以保证，对于正确创建的对象，无论它是如何发布的，所有线程都将看到构造函数设置的final域的值。更进一步，一个正确创建的对象中，任何可以通过其final域触及到的变量(比如一个final数组中的元素，或者一个final域引用的HashMap里面的内容)，也可以保证对其他线程都是可见的。\n\n对于含有final域的对象，初始化安全性可以抑制重排序，否则这些重排序会发生在对象的构造期间以及内部加载对象引用的时刻。所有构造函数要写入值的final域，以及通过这些域可以到达任何变量，都会在构造函数完成后被“冻结”，而且可以保证任何获得该引用的线程，至少可以看到和冻结值一样新的值。用于向通过final域可到达的初始变量写入值的操作，不会和构造后的操作一起被重排序。\n\n初始化安全性意味着，像以下的SafeStates，即使存在着不安全的惰性初始化，或者在没有同步的公共静态域中隐藏SafeStates的引用，即使它没有使用同步，而且依赖于非线程安全的HashSet，它都可以被安全地发布。\n  //不可变对象的初始化安全性\n  public class SafeStates &#123;\n      private final Map&lt;String, String&gt; states;\n\n      public SafeStates() &#123;\n          states = new HashMap&lt;String, String&gt;();\n          states.put(&quot;alaska&quot;, &quot;AK&quot;);\n          states.put(&quot;alabama&quot;, &quot;AL&quot;);\n          /*...*/\n          states.put(&quot;wyoming&quot;, &quot;WY&quot;);\n      &#125;\n\n      public String getAbbreviation(String s) &#123;\n          return states.get(s);\n      &#125;\n  &#125;\n\n\n\n初始化安全性保证只有以通过final域触及的值，在构造函数完成时才是可见的。对于通过final域触及的值，或者创建完成后可能改变的值，必须使用同步来确保可见性。\n\nsummary\nJava存储模型明确地规定了在什么时机下，操作存储器的线程的动作可以保证被另外的动作看到。规范还规定了要保证操作是按照一种偏序关系进行排序。这种关系称为happens-before，它是规定在独立存储器和同步操作的级别之上的。如果缺少充足的同步，线程在访问共享数据时就会发生非常无法预期的事情。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","同步"]},{"title":"15.原子变量与非阻塞同步机制","url":"https://java4u.cn/Java并发编程/Java并发编程/15-原子变量与非阻塞同步机制/","content":"\njava.util.concurrent包中的许多类，比如Semaphore和ConcurrentLinkedQueue，都提供了比使用synchronized更好的性能和可伸缩性。这一章，我们来学习这些性能提升的原始来源：原子变量和非阻塞的同步机制。\n近来很多关于并发算法的研究都聚集在非阻塞算法上，这种算法使用低层原子化的机器指令取代锁，比如比较并交换，从而保证数据在并发访问下的一致性。非阻塞算法广泛用于操作系统和JVM中的线程和进程调度、垃圾回收以及实现锁和其他并发数据结构。\n与基于锁的方案相比，非阻塞算法的设计和实现都要复杂得多，但是它们在可伸缩性或活跃度上占有很大的优势。因为非阻塞算法可以让多个线程在竞争相同资源时不会发生阻塞，所以它能在更精化的层面上调整粒度，并能大大减少调度的开销。\n进一步而言，它们对死锁和其他活跃度问题具有免疫性。在基于锁的算法中，如果一个线程在持有锁的时候休眠，或者停滞不前，那么其他线程就都不可能前进了，而非阻塞算法不会受到单个线程失败的影响。\n在java 5.0 中，使用原子变量类，比如AtomicInteger和AtomicReference，能够高效地构建非阻塞算法。\n原子变量提供了与volatile类型变量相同的内存语义，同时还额外支持原子更新——使它们能更加理想地用于计数器、序列发生器和统计数据收集等，另外也比基于锁的方案具有更加出色的可伸缩性。\n\n15.1 锁的劣势\n使用一致的加锁协议来协调对共享状态的访问，确保无论哪个线程持有守护变量的锁，它们都能独占访问这些变量，并且对变量的任何修改对其他随后获得同一锁的线程都是可见的。\n\n对于基于锁，并且其操作过度细分的类，当频繁地发生锁的竞争时，调度与真正用于工作的开销间的比值会很可观。\n\nvolatile变量与锁相比是更轻量的同步机制，因为它们不会引起上下文的切换和线程调度。然而，volatile变量与锁相比有一些局限性：\n\n尽管它们提供了相似的可见性保证，但是它们不能用于构建原子化的复合操作。这意味着当一个变量依赖其他变量时，或者当变量的新值依赖于旧值时，是不能用volatile变量的。\n它们不能用于实现可靠的通用工具，比如计数器，或互斥体\n\n\n例如，尽管自增操作看起来像是原子操作，事实上有3个独立操作——获取变量当前值，为该值加一，然后写回更新值。为了不丢失更新，整个的读-改-写操作必须是原子的。\n\n加锁的缺点：\n\n当一个线程正在等待锁，他不能做任何其他事情。\n如果一个线程在持有锁的情况下发生了延迟，那么其他所有需要该锁的线程都不能前进了。\n若阻塞线程优先级高，持有锁的线程优先级低，那么持有锁的线程会永久性阻塞。\n\n\n\n15.2 硬件对并发的支持\n独占锁是一项悲观的技术——它假设最坏情况(如果你不锁门，捣蛋鬼就会闯入，并破坏物品的秩序)，并且会通过获得正确的锁来避免其他线程的打扰，直到作出保证才能继续进行。\n对于细粒度的操作，有另外一种选择通常更加有效——乐观的解决方法。凭借新的方法，我们可以指望不受打扰地完成更新。这个方法依赖于冲突监测，从而能判定更新过程中是否存在来自于其他成员的干涉，在冲突发生的情况下，操作失败，并会重试(也可能不重试)。这个乐观的方案就好比我们常说的：“宽恕比准许更容易”，其中“更容易”意味着“更有效率”。\n针对多处理器系统设计的处理器提供了特殊的指令，用来管理并发访问的共享数据。早期处理器具有原子化的测试并设置(test-and-set)**，获取并增加(fetch-and-increment)以及交换(swap)**指令，这些对于实现互斥已经足够了，并能够用于实现更成熟的并发对象。\n如今，几乎所有现代的处理器都具有一些形式的原子化的读-改-写指令，比如比较并交换(compare-and-swap)**和加载链接/存储条件**(load-linked/store-conditional)。操作系统和JVM使用这些指令来实现锁和并发的数据结构，但是直到Java 5.0 以前这些还不能直接为Java类所使用。\n\n15.2.1 比较并交换\n大多数处理器使用的架构方案都实现了**比较并交换(CAS)**指令。\n\nPowerPC用一对指令实现了相同的功能：链接加载/存储条件。\n\nCAS有3个操作数——内存位置V、旧的预期值A和新值B。当且仅当V符合旧预期值A时，CAS用新值B原子化地更新V的值；否则它什么都不会做。\n\nCAS是一项乐观技术——它抱着成功的希望进行更新，并且如果另一个线程在上次检查后更新了该变量，它能够发现错误。\n  //模拟CAS操作\n  @ThreadSafe\n  public class SimulatedCAS &#123;\n      @GuardedBy(&quot;this&quot;) private int value;\n\n      public synchronized int get() &#123;\n          return value;\n      &#125;\n\n      public synchronized int compareAndSwap(int expectedValue,\n                                             int newValue) &#123;\n          int oldValue = value;\n          if (oldValue == expectedValue)\n              value = newValue;\n          return oldValue;\n      &#125;\n\n      public synchronized boolean compareAndSet(int expectedValue,\n                                                int newValue) &#123;\n          return (expectedValue\n                  == compareAndSwap(expectedValue, newValue));\n      &#125;\n  &#125;\n\n使用CAS的典型模式是：首先从V中读取值A，由A生成新值B，然后使用CAS原子化地把V的值由A改成B，并且期间不能有其他线程改变V的值。因为CAS能够发现来自其他线程的干扰，所以即使不使用锁，它也能够解决原子化地实现读-写-改的问题。\n\n\n15.2.2 非阻塞计数器\n以下代码CasCounter利用CAS实现了线程安全的计数器。自增操作遵循了经典形式——取得旧值，根据它计算出新值(加一)，并使用CAS设定新值。如果CAS失败，立即重试该操作。尽管在竞争十分激烈的情况下，更希望等待或者回退，以避免重试造成的活锁，但是，通常反复重试都是合理的策略。\n\nCasCounter不会发生阻塞，如果其他线程同时更新计数器，它会进行数次重试。\n  //使用CAS实现的非阻塞计数器\n  @ThreadSafe\n  public class CasCounter &#123;\n      private SimulatedCAS value;\n\n      public int getValue() &#123;\n          return value.get();\n      &#125;\n\n      public int increment() &#123;\n          int v;\n          do &#123;\n              v = value.get();\n          &#125; while (v != value.compareAndSwap(v, v + 1));\n          return v + 1;\n      &#125;\n  &#125;\n\n比较\n\n基于CAS的计数器看起来比基于锁的计数器性能差一些；它具有更多的操作和更复杂的控制流，表面看来还依赖于复杂的CAS操作。但是，实际上基于CAS的计数器，性能上远远胜过了基于锁的计数器，即使只有很小的竞争，或者不存在竞争。\n\n\nCAS最重要的缺点是：它强迫调用者处理竞争(通过重试、回退，或者放弃)；然而在锁被获得之前，却可以通过阻塞自动处理竞争。\n\n\n15.2.3 JVM对CAS的支持\n在Java 5.0 中，引入了底层的支持，将int、long和对象的引用暴露给CAS操作，并且JVM把它们编译为底层硬件提供的最有效的方法。\n在支持CAS的平台上，运行时把它们编排成恰当的(多条)机器指令；在最坏的情况下，如果CAS式的指令不可用，JVM会使用自旋锁。\n这些底层的JVM支持，用于那些具有原子化变量的类(java.util.concurrent.atomic中的AtomicXxx)，从而为数字类型和引用类型提供有效的CAS操作；而且，这些原子变量类还用于直接或间接地实现java.util.concurrent中大部分类\n\n15.3 原子变量类\n原子变量比锁更精巧，更轻量，并且在多处理器系统中，对实现高性能的并发代码非常关键。在使用原子变量取代锁的算法中，线程更不易出现延迟，如果它们遇到竞争，也更容易恢复。\n\n原子变量类，提供了广义的volatile变量，以支持原子的、条件的读-写-改操作。AtomicInteger代表一个int值，并提供了get和set方法，它们与读取和写入可变的int有着相同的内存语义。它同样提供了一个compareAndSet方法，以及原子化的插入、递增、递减等方法，这些是为了使用方便。竞争条件下AtomicInteger提供了更好的可伸缩性，因为它可以直接利用硬件对并发的支持。\n\n原子变量类共有12个，分成4组：\n\n计量器\n域更新器(field updater)\n数组\n复合变量\n\n\n最常用的原子变量是计量器：AtomicInteger、AtomicLong、AtomicBoolean以及AtomicReference。他们都支持CAS；AtomicInteger和AtomicLong还支持算术运算。\n\n原子化的数组类(只有Integer、Long和Reference版本的可用)，它的元素是可以被原子化地更新的。原子数组类为数组的元素提供了volatile的访问语义，这是普通数组所没有的特性——volatile类型的数组只针对数组的引用具有volatile语义，而不是它的元素。\n\n\n15.3.1 原子变量是“更佳的volatile”\n原子化地更新持有上下边界的不变类的引用，来缩小竞争条件。以下代码CasNumberRange使用AtomicReference和IntPair来保持状态；通过使用compareAndSet，它能够避开NumberRange的竞争条件，更新上下界。\n\n//使用CAS避免多元的不变约束\n@ThreadSafe\n    public class CasNumberRange &#123;\n    @Immutable\n            private static class IntPair &#123;\n        // INVARIANT: lower &lt;= upper\n        final int lower;\n        final int upper;\n\n        public IntPair(int lower, int upper) &#123;\n            this.lower = lower;\n            this.upper = upper;\n        &#125;\n    &#125;\n\n    private final AtomicReference&lt;IntPair&gt; values =\n            new AtomicReference&lt;IntPair&gt;(new IntPair(0, 0));\n\n    public int getLower() &#123;\n        return values.get().lower;\n    &#125;\n\n    public int getUpper() &#123;\n        return values.get().upper;\n    &#125;\n\n    public void setLower(int i) &#123;\n        while (true) &#123;\n            IntPair oldv = values.get();\n            if (i &gt; oldv.upper)\n                throw new IllegalArgumentException(&quot;Can&#39;t set lower to &quot; + i + &quot; &gt; upper&quot;);\n            IntPair newv = new IntPair(i, oldv.upper);\n            if (values.compareAndSet(oldv, newv))\n                return;\n        &#125;\n    &#125;\n\n    public void setUpper(int i) &#123;\n        while (true) &#123;\n            IntPair oldv = values.get();\n            if (i &lt; oldv.lower)\n                throw new IllegalArgumentException(&quot;Can&#39;t set upper to &quot; + i + &quot; &lt; lower&quot;);\n            IntPair newv = new IntPair(oldv.lower, i);\n            if (values.compareAndSet(oldv, newv))\n                return;\n        &#125;\n    &#125;\n&#125;\n15.3.2 性能比较：锁与原子变量\n伪随机数字生成器(PRNG)\n\n    //使用ReentrantLock实现随机数字生成器\n    @ThreadSafe\n    public class ReentrantLockPseudoRandom extends PseudoRandom &#123;\n        private final Lock lock = new ReentrantLock(false);\n        private int seed;\n\n        ReentrantLockPseudoRandom(int seed) &#123;\n            this.seed = seed;\n        &#125;\n\n        public int nextInt(int n) &#123;\n            lock.lock();\n            try &#123;\n                int s = seed;\n                seed = calculateNext(s);\n                int remainder = s % n;\n                return remainder &gt; 0 ? remainder : remainder + n;\n            &#125; finally &#123;\n                lock.unlock();\n            &#125;\n        &#125;\n    &#125;\n\n\n\n    //使用AtomicInteger实现随机数字生成器\n    @ThreadSafe\n    public class AtomicPseudoRandom extends PseudoRandom &#123;\n        private AtomicInteger seed;\n\n        AtomicPseudoRandom(int seed) &#123;\n            this.seed = new AtomicInteger(seed);\n        &#125;\n\n        public int nextInt(int n) &#123;\n            while (true) &#123;\n                int s = seed.get();\n                int nextSeed = calculateNext(s);\n                if (seed.compareAndSet(s, nextSeed)) &#123;\n                    int remainder = s % n;\n                    return remainder &gt; 0 ? remainder : remainder + n;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n性能比较\n\n\n\n\n图15.1和图15.2展示了模拟低级和中级工作强度下，每个迭代的吞吐量。在低级强度的线程本地计算中，锁和原子变量都经历了激烈的竞争；在强化了的线程本地计算后，线程访问锁和原子变量的频率减少了，因而它们的竞争压力也变小减小了。\n在激烈竞争下，锁胜过原子变量，但是在真实的竞争条件下，原子变量会胜过锁。这是因为锁通过挂起线程来响应竞争，减少了CPU的利用和共享内存总线上的同步通信量。(这与在生产者-消费者线程中，以阻塞生产者来减小消费者负荷，使它们能够赶上进度的设计是类似的。)从另一方面来看，使用原子变量把竞争管理推回给调用类。与大多数基于CAS的算法相比，AtomicPseudoRandom通过不断反复尝试来响应竞争，这通常是正确的，但是在激烈竞争环境下，会带来更多竞争。\n在实践中，原子化的伸缩性比锁更好，因为在典型的竞争级别中，原子性会带来更好的效率。\n\n\n\n\n锁与原子化随竞争度的不同，性能发生的改变阐明了各自的优势和劣势。在中低程度的竞争下，原子化提供更好的可伸缩性；在高强度的竞争下，锁能够更好地帮助我们避免竞争。\n第三条曲线；使用ThreadLocal的PRNG状态实现PseudoRandom。这个实现方案改变了类的行为——每个线程查看自己私有的伪随机数字序列，而不是所有线程共享同一序列——但是如果能够避免的话，不共享状态的开销会更小。我们能够通过更有效地处理竞争改进可伸缩性，但是真正的可伸缩性完全是通过减少竞争实现的。\n\n15.4 非阻塞算法\n一个线程的失败或挂起不应该影响其他线程的失败或挂起，这样的算法被称为非阻塞算法\n如果算法的每一步骤中都有一些线程能够继续执行，那么这样的算法称为**锁自由(lock-free)**算法。\n在线程间使用CAS进行协调，这样的算法如果能够构建正确的话，它既是非阻塞的，又是锁自由的。\n非阻塞算法对死锁和优先级倒置有“免疫性”(但它们可能会出现饥饿和活锁，因为它们允许重进入)。\n\n15.4.1 非阻塞栈//使用Treiber算法的非阻塞栈\n@ThreadSafe\n    public class ConcurrentStack &lt;E&gt; &#123;\n    AtomicReference&lt;Node&lt;E&gt;&gt; top = new AtomicReference&lt;Node&lt;E&gt;&gt;();\n\n    public void push(E item) &#123;\n        Node&lt;E&gt; newHead = new Node&lt;E&gt;(item);\n        Node&lt;E&gt; oldHead;\n        do &#123;\n            oldHead = top.get();\n            newHead.next = oldHead;\n        &#125; while (!top.compareAndSet(oldHead, newHead));\n    &#125;\n\n    public E pop() &#123;\n        Node&lt;E&gt; oldHead;\n        Node&lt;E&gt; newHead;\n        do &#123;\n            oldHead = top.get();\n            if (oldHead == null)\n                return null;\n            newHead = oldHead.next;\n        &#125; while (!top.compareAndSet(oldHead, newHead));\n        return oldHead.item;\n    &#125;\n\n    private static class Node &lt;E&gt; &#123;\n        public final E item;\n        public Node&lt;E&gt; next;\n\n        public Node(E item) &#123;\n            this.item = item;\n        &#125;\n    &#125;\n&#125;\n\nConcurrentStack显示了如何使用原子引用来构建栈。栈是Node元素的一个链表，栈顶作为根，每个元素都包含一个值和一个指向下一个元素的链接。\npush方法创建一个新的链接节点，该节点的next域指向当前的栈顶，然后使用CAS把这个新节点加入到栈中。如果我们使用栈的时候栈顶元素恰为新加入的节点，那么CAS成功了；如果栈顶元素变化了(因为其他线程在我们开始前插入或移除了元素)，CAS就失败了，push方法会根据当前栈的状态更新节点，反复尝试。在这两种情况下，栈在CAS操作后仍然能够保持一致性。\nConcurrentStack中用到的非阻塞算法，其线程安全性源于：compareAndSet既能提供原子性，又能提供可见性，加锁也同样如此。当一个线程改变栈的状态时，它使用具有与写入volatile变量相同的内存效应的compareAndSet。当线程检查栈的时候，通过调用同一个AtomicReference的get方法来实现，它具有与读取volatile变量相同的内存效应。所以任何线程修改都能够安全地发布给其他正在检查列表状态的线程。并且这个列表通过compareAndSet进行修改，更新top的引用或者因发现其他线程的干扰而失败，这些都是原子化地进行的。\n\n15.4.2 非阻塞链表//Michael-Scott非阻塞队列算法中的插入\n@ThreadSafe\npublic class LinkedQueue &lt;E&gt; &#123;\n\n    private static class Node &lt;E&gt; &#123;\n        final E item;\n        final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; next;\n\n        public Node(E item, LinkedQueue.Node&lt;E&gt; next) &#123;\n            this.item = item;\n            this.next = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(next);\n        &#125;\n    &#125;\n\n    private final LinkedQueue.Node&lt;E&gt; dummy = new LinkedQueue.Node&lt;E&gt;(null, null);\n    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; head\n            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);\n    private final AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt; tail\n            = new AtomicReference&lt;LinkedQueue.Node&lt;E&gt;&gt;(dummy);\n\n    public boolean put(E item) &#123;\n        LinkedQueue.Node&lt;E&gt; newNode = new LinkedQueue.Node&lt;E&gt;(item, null);\n        while (true) &#123;\n            LinkedQueue.Node&lt;E&gt; curTail = tail.get();\n            LinkedQueue.Node&lt;E&gt; tailNext = curTail.next.get();\n            if (curTail == tail.get()) &#123;\n                if (tailNext != null) &#123;\n                    // Queue in intermediate state, advance tail\n                    tail.compareAndSet(curTail, tailNext);\n                &#125; else &#123;\n                    // In quiescent state, try inserting new node\n                    if (curTail.next.compareAndSet(null, newNode)) &#123;\n                        // Insertion succeeded, try advancing tail\n                        tail.compareAndSet(curTail, newNode);\n                        return true;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;\n图解\n\n\n一个链接队列比栈更加复杂，因为它需要支持首尾的快速访问。为了实现，它会维护独，立的队首指针和队尾指针。两个指针初始时都指向队列的末尾结点：当前最后一个元素的next指针，即队尾指针。在成功加入新元素时，两个结点都需要更新——原子化更新。\n\n更新需要注意：\n\n第一个成功，第二个失败，队列将处于不一致状态\n两个都成功，另一个线程在两个操作之间访问队列\n\n\n我们需要使用几个窍门来完成这项任务。第一个是即使在多步更新中，也要确保数据结构总能处于一致状态。这样，如果线程B到达时发现线程A在更新中，B可以分辨操作已部分完成，并且直到不能立即开始自己的更新。那么B就开始等待(通过反复检查队列状态)直到A完成更新，这样两个线程就不会相互影响了。\n\n这个方法的缺陷是，如果一个线程在更新中失败，就没有线程能够再访问队列了。\n\n为了使其成为非阻塞算法，我们必须保证一个线程的失败，不会阻止其他线程继续前进。因此，第二个诀窍是，确保如果B到达时发现数据结构正在被A修改，在数据结构中应该有足够多的信息，说明需要B来替代A完成更新。如果B“帮助”A完成其操作，那么B可以进行自己的操作，而不用等待A的操作完成。当A恢复后试图完成其操作，会发现B已经替它完成了。\n\n以上的LinkedQueue展示了Michael-Scott的非阻塞链接队列算法的插入部分，它已经用在了ConcurrentLinkedQueue中。在很多队列算法中，一个空队列都有一个“哨兵(sentinel)节点”或者“虚(dummy)节点”，并且队首指针和队尾指针的初始化都指向哨兵节点。队尾指针永远指向哨兵节点(如果队列为空)，也就是队列的最后一个元素，或者(当操作正在更新队列时)指向倒数第二个元素。图15-3阐释了包含两个元素的队列的正常状态，或者说稳定状态。\n\n插入新的元素涉及两个指针的更新。首先通过更新当前队尾元素的next指针把新节点链接到列表队尾；然后释放队尾指针，指向新的最末元素。在这两个操作之间，队列处于中间状态，如图15-4.在第二次更新后，队列再一次处于稳定状态，如图15-5.\n\n要想同时实现两个窍门的方法是：假设队列处于稳定状态，则尾结点的next域指向null，如果队列处于中间状态，tail.next为非空。所以任何线程都能够通过检查tail.next即时地了解队列状态。进一步而言，如果队列处于中间状态，它能够通过推进队尾指针向前移动一个结点把状态恢复为稳定状态，结束任意线程正在插入元素的操作。\n\n\n15.4.3 原子化的域更新器//在ConcurrentLinkedQueue中使用原子化的域更新器\n\nprivate static class Node&lt;E&gt; &#123;\n    private volatile E item;\n    private volatile Node&lt;E&gt; next;\n\n    private static final \n        AtomicReferenceFieldUpdater&lt;Node, Node&gt; \n        nextUpdater =\n        AtomicReferenceFieldUpdater.newUpdater\n        (Node.class, Node.class, &quot;next&quot;);\n\n    Node(E x) &#123; item = x; &#125;\n\n&#125;\n\n原子化的域更新器类(在Integer、Long，以及Reference版本中可用)，代表着已存在的volatile域基于反射的“视图”，使得CAS能够用于已有的volatile域。更新器类没有构造函数；为了创建，你可以调用newUpdater的工厂方法，声明类和域的名称。域更新器类并不依赖特定的实例；它可以用于更新目标类任何实例的目标域。更新器类提供的原子性保护比普通的原子类差一些，因为你不能保证底层的域不被直接修改——compareAndSet和算术方法只在其他线程使用原子化的域更新器方法时保证其原子性。\n在ConcurrentLinkedQueue中，更新Node的next域是通过使用nextUpdater的compareAndSet方法实现的。这个有点迂回的方案完全是因性能原因使用的。对于频繁分配的、生命周期短暂的对象，比如队列的链接节点，减少每个Node的AtomicReference创建，对于减少插入操作的开销是非常有效的。\n然而，几乎在所有的情况下，普通原子变量表现已经相当不错了——仅仅在很少的情况下需要使用原子化的域更新器。(当你想要保存现有类的串行化形式时，原子化的域更新器会非常有用。)\n\n15.4.4 ABA问题\nCAS：对于内存中的某一个值V，提供一个旧值A和一个新值B。如果提供的旧值A和V相等就把B写入V。这个过程是原子性的。\nCAS执行结果要么成功要么失败，对于失败的情形下一班采用不断重试。或者放弃。\nABA：如果另一个线程修改V值假设原来是A，先修改成B，再修改回成A。当前线程的CAS操作无法分辨当前V值是否发生过变化。\n解决ABA问题相对简单的方案：\n更新一对值，包括引用和版本号。\n\n\n\nsummary\n非阻塞算法通过使用低层级并发原语，比如比较并交换，取代了锁。原子变量类向用户提供了这些低层级原语，也能够当做“更佳的volatile变量”使用，同时提供了整数类和对象引用的原子化更新操作。\n非阻塞算法在设计和实现中很困难，但是在典型条件下能够提供更好的可伸缩性，并能更好地预防活跃度失败。从JVM的一个版本到下一个版本间并发性能的提升很大程度上来源于非阻塞算法的使用，包括在JVM内部以及平台类库。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","同步"]},{"title":"14.构建自定义的同步工具","url":"https://java4u.cn/Java并发编程/Java并发编程/14-构建自定义的同步工具/","content":"\n类库中包含了大量依赖于状态(state-dependent)的类——这些类拥有基于状态的先验条件——FutureTask、Semaphore和BlockingQueue。例如，你不能从一个空队列中移除条目，也不能从一个尚未结束的任务中获取结果；在这些操作可以执行前，你必须等到队列进入“非空”状态，任务进入“完成”状态。\n创建状态依赖类最简单的方法通常是将它构建于已有的状态依赖库之上。如果类库没有提供你需要的功能，你也可以使用语言和类库提供的底层机制，包括内部条件队列、显示的Condition对象和AbstractQueuedSynchronizer框架，构建属于自己的Synchronizer。这一章探究一些实现状态依赖性时要面对的不同选择，以及使用平台提供的状态依赖性机制时需要遵守的不同规则。\n\n14.1 管理状态依赖性\n生产者-消费者的设计经常会使用ArrayBlockingQueue这种有限缓存。一个有限缓存提供的put和take操作，每一个都有先验条件：你不能从空缓存中获取元素，也不能把元素置入已满的缓存中。如果依赖于状态的操作在处理先验条件时失败，可以抛出异常或者返回错误状态(把问题留给调用者)，也可以保持阻塞直到直到对象转入正确的状态。\n\n14.1.1 示例：将先验条件失败传给调用者\n以下代码的GrumpyBoundedBuffer是第一个直接的、简单的有限缓存实现。由于put和take方法都在访问缓存时采用“检查再运行(check-then-act)”逻辑，所以它们都是同步的，以确保独占访问缓存状态。\n\n尽管实现简单，但用起来令人厌烦。因为调用者必须时刻准备捕获异常。\n  //如果有限缓存不满足先验条件，会停滞不前\n  @ThreadSafe\n  public class GrumpyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;\n      public GrumpyBoundedBuffer() &#123;\n          this(100);\n      &#125;\n\n      public GrumpyBoundedBuffer(int size) &#123;\n          super(size);\n      &#125;\n\n      public synchronized void put(V v) throws BufferFullException &#123;\n          if (isFull())\n              throw new BufferFullException();\n          doPut(v);\n      &#125;\n\n      public synchronized V take() throws BufferEmptyException &#123;\n          if (isEmpty())\n              throw new BufferEmptyException();\n          return doTake();\n      &#125;\n  &#125;\n\n  //调用GrumpyBoundedBuffer的客户端逻辑\n  class ExampleUsage &#123;\n      private GrumpyBoundedBuffer&lt;String&gt; buffer;\n      int SLEEP_GRANULARITY = 50;\n\n      void useBuffer() throws InterruptedException &#123;\n          while (true) &#123;\n              try &#123;\n                  String item = buffer.take();\n                  // use item\n                  break;\n              &#125; catch (BufferEmptyException e) &#123;\n                  Thread.sleep(SLEEP_GRANULARITY);\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n\n\n以上的客户端代码不是实现重试逻辑的唯一方式。调用者可以不休眠，而直接重试take操作——一种被称作忙等待或自旋等待的方法。\n若相当长时间内，缓存状态不变，使用这种方法会消耗很多CPU\n若调用者决定休眠，避免消耗过多CPU，但如果缓存状态在调用sleep不久后，很快发生了变化，那么它很容易会“睡过头”。\n\n\n所以，客户端代码身处于自旋产生的低CPU使用率和休眠产生的弱响应性之间的两难境地。折中选择是调用THread.yield，这给调度器一个提示：我现在可以让出一定的时间让另外的线程运行。\n\n14.1.2 示例：利用“轮询加休眠” 实现拙劣的阻塞\n以下的SleepBoundeBuffer尝试通过在put和take操作内部封装相同的“轮询和休眠”重试机制，为每次调用实现了重试逻辑，从而分担调用者的麻烦。如果缓存是空的，take将休眠，直到另一个线程在缓存中置入了一些数据；如果缓存是满的，put将休眠，直到另一个线程移除了一些数据，在缓存中腾出地方来。这个方法封装了对先验条件的管理，简化了缓存的使用——这向正确的方向上迈出了一步。\n\n选择休眠的时间间隔，是在响应性与CPU使用率之间作出的权衡；休眠的间隔越小，响应性越好，但是CPU的消耗也越高。\n  //有限缓存使用了拙劣的阻塞\n  @ThreadSafe\n  public class SleepyBoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;\n      int SLEEP_GRANULARITY = 60;\n\n      public SleepyBoundedBuffer() &#123;\n          this(100);\n      &#125;\n\n      public SleepyBoundedBuffer(int size) &#123;\n          super(size);\n      &#125;\n\n      public void put(V v) throws InterruptedException &#123;\n          while (true) &#123;\n              synchronized (this) &#123;\n                  if (!isFull()) &#123;\n                      doPut(v);\n                      return;\n                  &#125;\n              &#125;\n              Thread.sleep(SLEEP_GRANULARITY);\n          &#125;\n      &#125;\n\n      public V take() throws InterruptedException &#123;\n          while (true) &#123;\n              synchronized (this) &#123;\n                  if (!isEmpty())\n                      return doTake();\n              &#125;\n              Thread.sleep(SLEEP_GRANULARITY);\n          &#125;\n      &#125;\n  &#125;\n\nSleepyBoundedBuffer也给调用者提出了新的要求：处理InterruptedException。\n\n\n\n上述这些将轮询与休眠组合成一个阻塞操作的尝试都不能令人非常满意。如果存在某种挂起线程的方法，能够保证当某个条件成为真时，线程可以及时地苏醒过来，这样就太好了。而这恰恰是条件队列(condition queue)所做的工作。\n\n14.1.3 让条件队列来解决这一切\n条件队列可以让一组线程——称作等待集——以某种方式等待相关条件变成真。不同于传统的队列，它们的元素是数据项；条件队列的元素是等待相关条件的线程。\n\n就像每个Java对象都能当做锁一样，每个对象也能当做条件队列，Object中的wait、notify、notifyAll方法构成了内部条件队列的API。一个对象的内部锁与它的内部条件队列是相关的：为了能够调用对象X中的任一个条件队列方法，你必须持有对象X的锁。这是因为“等待基于状态的条件”机制必须和“维护状态一致性”机制紧密地绑定在一起：除非你能检查状态，否则你不能等待条件；同时，除非你能改变状态，否则你不能从条件等待队列中释放其他的线程。\n\nObject.wait会自动释放锁，并请求OS挂起当前线程，让其他线程获得该锁进而修改对象的状态。当它被唤醒时，它会在返回前重新获得锁。直观上看，调用wait意味着我要去休息了，但是发生了需要关注的事情后叫醒我，调用通知(notification)方法意味着“需要关注的事情发生了”。\n  //有限缓存使用条件队列\n  @ThreadSafe\n  public class BoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;\n      // CONDITION PREDICATE: not-full (!isFull())\n      // CONDITION PREDICATE: not-empty (!isEmpty())\n      public BoundedBuffer() &#123;\n          this(100);\n      &#125;\n\n      public BoundedBuffer(int size) &#123;\n          super(size);\n      &#125;\n\n      // BLOCKS-UNTIL: not-full\n      public synchronized void put(V v) throws InterruptedException &#123;\n          while (isFull())\n              wait();\n          doPut(v);\n          notifyAll();\n      &#125;\n\n      // BLOCKS-UNTIL: not-empty\n      public synchronized V take() throws InterruptedException &#123;\n          while (isEmpty())\n              wait();\n          V v = doTake();\n          notifyAll();\n          return v;\n      &#125;\n\n      // BLOCKS-UNTIL: not-full\n      // Alternate form of put() using conditional notification\n      public synchronized void alternatePut(V v) throws InterruptedException &#123;\n          while (isFull())\n              wait();\n          boolean wasEmpty = isEmpty();\n          doPut(v);\n          if (wasEmpty)\n              notifyAll();\n      &#125;\n  &#125;\n\n以上的BoundedBuffer使用wait和notifyAll实现了有限缓存。这个比休眠版本更高效，而且响应性更佳。用条件队列使得表达和管理状态的依赖性变得更加简单和高效。\n\n\n14.2 使用条件队列\n条件队列让构建有效且可响应的状态依赖类变得容易，但是把它们用错也很容易；关于如何正确使用它们，存在很多规则。\n\n14.2.1 条件谓词\n正确使用条件队列的关键在于识别出对象可以等待的条件谓词。\n条件谓词是先验条件的第一站，它在一个操作与状态之间建立起依赖关系。在有限缓存中，take，条件谓词是“缓存不空”，put，条件谓词是“缓存不满”。条件谓词是由类的状态变量构成的表达式；BaseBoundedBuffer是通过比较count与零，测试是否“缓存不空”；并通过比较count与缓存大小，测试是否“缓存不满”。\n\n\n将条件谓词和与之关联的条件队列，以及在条件队列中等待的操作，都写入文档。\n\n\n加锁、wait方法和条件谓词的条件等待的三元关系\n条件谓词涉及状态变量，而状态变量是由锁保护的，所以在测试条件谓词之前，我们必须先持有锁。锁对象与条件队列对象(wait和notify方法调用的对象)必须也是同一个对象。\n每次调用wait都会隐式地与特定的条件谓词相关联。当调用特定条件谓词的wait时，调用者必须已经持有了与条件队列相关的锁，这个锁必须同时还保护着组成条件谓词的状态变量。\n\n\n\n14.2.2 过早的唤醒\n一个单独的内部条件队列可以与多个条件谓词共同使用。当有人调用notifyAll，从而唤醒了你的线程时，并不意味着你正在等待条件谓词现在变成真了。\n\n因此，当你从wait中唤醒后，都必须再次测试条件谓词，如果条件谓词尚未成真，就继续等待(或失败).\n\n以下是条件等待的规范式\n  //状态依赖方法的规范式\n  void stateDependentMethod() throws InterruptedException&#123;\n      //条件谓词必须被锁守护\n      synchronized(lock)&#123;\n          while(!conditionPredicate())\n              lock.wait();\n          //现在，对象处于期望的状态中    \n      &#125;\n  &#125;\n\n\n\n当使用条件等待时(Object.wait 或者 Condition.await)：\n永远设置一个条件谓词——一些对象状态的测试，线程执行前必须满足它；\n永远在调用wait前测试条件谓词，并且从wait中返回后再次测试；\n永远在循环中调用wait；\n确保构成条件谓词的状态变量被锁保护，而这个锁正是与条件队列相关联的；\n当调用wait、notify或者notifyAll时，要持有与条件队列相关联的锁；并且在检查条件谓词之后、开始执行被保护的逻辑之前，不要释放锁\n\n\n\n14.2.3 丢失的信号\n活跃度失败有死锁和活锁，另一种活跃度失败是丢失的信号(missed signal)。\n当一个线程等待的特定条件已经为真，但是进入等待前检查条件谓词却返回了假，我们称这样就出现了一个丢失的信号。现在线程正在等待一个已经发过的事件给它通知。如果按以上状态依赖方法的规范式的代码架构你的条件等待，你就不会再遇到信号丢失的问题。\n\n14.2.4 通知\n关于条件等待所发生的事情的前一半：等待。另一半是通知。\n在有限缓存中，如果缓存为空，调用take将会阻塞。在缓存变为非空时，为了能够让take解除阻塞，我们必须确保每一条能够让缓存变为非空的代码路径都执行一个通知。在BoundedBuffer中，这种地方只有一处——put在成功地向缓存中加入一个元素后，会调用notifyAll。类似地，take在移除一个元素后调用notifyAll，向任何正在等待“不为满”条件的线程发出通知，缓存已经不为满了。\n\n\n无论何时，当你在等待一个条件，一定要确保有人会在条件谓词变为真时通知你。\n\n\n在条件队列API中有两个通知方法——notify和notifyAll。无论调用哪一个，你都必须持有与条件队列对象相关联的锁。\n调用notify的结果是:JVM会从在这个条件队列中等待的众多线程中挑选一个，并把它唤醒；而调用notifyAll会唤醒所有正在这个条件队列中等待的线程。由于你调用notify和notifyAll时必须持有条件队列对象的锁，这导致等待线程此时不能重新获得锁，无法从wait返回，因此该通知线程应该尽快释放锁，以确保等待线程尽可能快地解除阻塞。\n由于会有多个线程因为不同的原因在同一个条件队列中等待，因此不用notifyAll而使用notify是危险的。这主要是因为单一的通知容易导致同类的线程丢失全部信号。\n\n\n只有同时满足下述条件，才能用单一的notify取代notifyAll：相同的等待者。只有一个条件谓词与条件队列相关，每个线程从wait返回后执行相同的逻辑；并且，一进一出。一个对条件变量的通知，至多只激活一个线程执行。\n\n//在BoundedBuffer.put中使用“依据条件通知”\n@ThreadSafe\npublic class BoundedBuffer &lt;V&gt; extends BaseBoundedBuffer&lt;V&gt; &#123;\n    // CONDITION PREDICATE: not-full (!isFull())\n    // CONDITION PREDICATE: not-empty (!isEmpty())\n    public BoundedBuffer() &#123;\n        this(100);\n    &#125;\n\n    public BoundedBuffer(int size) &#123;\n        super(size);\n    &#125;\n\n    // BLOCKS-UNTIL: not-full\n    public synchronized void put(V v) throws InterruptedException &#123;\n        while (isFull())\n            wait();\n        doPut(v);\n        notifyAll();\n    &#125;\n\n    // BLOCKS-UNTIL: not-empty\n    public synchronized V take() throws InterruptedException &#123;\n        while (isEmpty())\n            wait();\n        V v = doTake();\n        notifyAll();\n        return v;\n    &#125;\n\n    // BLOCKS-UNTIL: not-full\n    // Alternate form of put() using conditional notification\n    public synchronized void alternatePut(V v) throws InterruptedException &#123;\n        while (isFull())\n            wait();\n        boolean wasEmpty = isEmpty();\n        doPut(v);\n        if (wasEmpty)\n            notifyAll();\n    &#125;\n&#125;\n14.2.5 示例：阀门类\n以下代码使用条件等待开发一个可重关闭的ThreadGate。ThreadGate允许阀门打开与关闭。它提供的await方法会阻塞，直到阀门打开。open方法之所以使用notifyAll，是因为对于使用单一通知的“一出一进”检查会在这个类的语意中失败。\n  //使用wait后notifyAll实现可重关闭的阀门\n  @ThreadSafe\n  public class ThreadGate &#123;\n      // CONDITION-PREDICATE: opened-since(n) (isOpen || generation&gt;n)\n      @GuardedBy(&quot;this&quot;) private boolean isOpen;\n      @GuardedBy(&quot;this&quot;) private int generation;\n\n      public synchronized void close() &#123;\n          isOpen = false;\n      &#125;\n\n      public synchronized void open() &#123;\n          ++generation;\n          isOpen = true;\n          notifyAll();\n      &#125;\n\n      // BLOCKS-UNTIL: opened-since(generation on entry)\n      public synchronized void await() throws InterruptedException &#123;\n          int arrivalGeneration = generation;\n          while (!isOpen &amp;&amp; arrivalGeneration == generation)\n              wait();\n      &#125;\n  &#125;\n\n每次关闭阀门时，会递增generation计数器，如果阀门现在是打开的，或者如果线程到达阀门后，阀门就已经打开，那么线程就可以通过await了。\n\n\n14.2.6 子类的安全问题\n使用依据条件的或者单一的通知会引入一些约束，导致子类化变得更加复杂。\n一个依赖于状态的类，要么完全将它的等待和通知协议暴露(并文档化)给子类，要么完全阻止子类参与其中。\n另一种选择就是直接禁止子类化，可以通过把类声明为final类型的，或者通过对子类隐藏条件队列、锁和状态变量来完成。否则，如果子类做的一些事情破坏了基类运用notify的方式，基类需要有能力修复。\n考虑如果有一个无限的阻塞栈，它的pop操作在栈为空的时候被阻塞，但是它的push永远都可以执行。这符合使用单一通知的条件。如果这个类使用的正是单一通知，而且在一个子类中添加了一个阻塞的“弹出两个连续元素”方法，这样就有两种等待者了：等待弹出一个元素的和等待弹出两个元素的。但是如果基类暴露出条件队列，并且已把使用它的协议写入文档中，子类就会在覆写push方法时执行notifyAll，以重新确保安全性。\n\n14.2.7 封装条件队列\n通常，最好可以把条件队列封装起来，这样在使用它的类层次结构之外，是不能访问它的。否则，调用者可能会禁不住诱惑，认为他们理解了你关于等待于通知的协议，然后以一种与你的设计不相符行为使用他们。\n\n14.2.8 入口协议和出口协议\nWellings以“入口协议和出口协议(entry and exit protocols)”的形式刻画了wait和notify的正确使用方法。对于每个依赖于状态的操作，以及每个修改了其他状态的操作，你都应该为其定义并文档化一个入口协议和出口协议。\n入口协议就是操作的条件谓词；出口协议涉及到要检查任何被操作改变的状态变量，确认它们是否引起其他一些条件谓词变为真，如果是，通知相关的条件队列。\n\n14.3 显式的Condition对象\n在某些情况下，当内部锁非常不灵活时，显式锁就可以派上用场。正如Lock是广义的内部锁，Condition也是广义的内部条件队列。\n\n内部条件队列存在缺陷：每个内部锁只能有一个与之相关联的条件队列\n\n不同于内部条件队列，你可以让每个Lock都有任意数量的Condition对象。\n\n而Condition提供了比内部条件队列要丰富地多的特征集：每个锁可以有多个等待集、可中断/不可中断的条件等待、基于时限的等待以及公平/非公平队列之间的选择。\n\nCondition对象继承了与之相关的锁的公平性特性；如果是公平的锁，线程会依照FIFO的顺序从Condition.await中被释放。\n\n以下代码是有限缓存的另一种实现，这次使用了两个Condition，notFull和notEmpty，明确地表示“非满”与“非空”两个条件谓词。当缓存为空时，take阻塞，它等待notEmpty；put向notEmpty发送信号，可以解除任何take所阻塞的线程。\n  @ThreadSafe\n  public class ConditionBoundedBuffer &lt;T&gt; &#123;\n      protected final Lock lock = new ReentrantLock();\n      // CONDITION PREDICATE: notFull (count &lt; items.length)\n      private final Condition notFull = lock.newCondition();\n      // CONDITION PREDICATE: notEmpty (count &gt; 0)\n      private final Condition notEmpty = lock.newCondition();\n      private static final int BUFFER_SIZE = 100;\n      @GuardedBy(&quot;lock&quot;) private final T[] items = (T[]) new Object[BUFFER_SIZE];\n      @GuardedBy(&quot;lock&quot;) private int tail, head, count;\n\n      // BLOCKS-UNTIL: notFull\n      public void put(T x) throws InterruptedException &#123;\n          lock.lock();\n          try &#123;\n              while (count == items.length)\n                  notFull.await();\n              items[tail] = x;\n              if (++tail == items.length)\n                  tail = 0;\n              ++count;\n              notEmpty.signal();\n          &#125; finally &#123;\n              lock.unlock();\n          &#125;\n      &#125;\n\n      // BLOCKS-UNTIL: notEmpty\n      public T take() throws InterruptedException &#123;\n          lock.lock();\n          try &#123;\n              while (count == 0)\n                  notEmpty.await();\n              T x = items[head];\n              items[head] = null;\n              if (++head == items.length)\n                  head = 0;\n              --count;\n              notFull.signal();\n              return x;\n          &#125; finally &#123;\n              lock.unlock();\n          &#125;\n      &#125;\n  &#125;\n\n\n分析\nConditionBoundedBuffer的行为和BoundedBuffer相同，但是它使用条件队列的方式，具有更好的可读性——分析使用多个Condition的类，要比分析一个使用单一内部队列加多个条件谓词的类简单的多。\n通过把两个条件谓词分离到两个等待集中，Condition简化了使用单一通知的条件。\n使用更有效的signal，而不是signalAll，这就会减少相当数量的上下文切换，而且每次缓存操作都会触发对锁的请求。\n就像内置的锁和条件队列一样，当使用显式的Lock和Condition时，也必须要满足锁、条件谓词和条件变量之间的三元关系。\n如果需要使用一些高级特性，比如使用公平队列或者让每个锁对应多个等待集，这时使用Condition要好于使用内部条件队列。\n\n剖析Synchronizer\nReentrantLock和Semaphore的共同点\n\n扮演阀门的角色，每次只允许有限数目的线程通过它\n线程到达阀门后，可以允许通过(lock或acquire成功返回)，可以等待(lock或acquire阻塞)，也可以被取消(tryLock或tryAcquire返回false，指明在允许的时间内，锁或者“许可”不可用)。\n它们都允许可中断的、不可中断的、可限时的请求尝试\n它们都允许选择公平、非公平的等待线程队列。\n\n\n它们的实现都用到一个共同的基类，AbstractQueuedSynchronizer(AQS)。AQS是一个用来构建锁和Synchronizer的框架，使用AQS能够简单且高效地构造出应用广泛的大量的Synchronizer。不仅ReentrantLock和Semaphore是构建于AQS上的，其他的还有CountDownLatch、ReentrantReadWriteLock、SynchronousQueue和FutureTask。\n  //使用lock实现的计数信号量\n  @ThreadSafe\n  public class SemaphoreOnLock &#123;\n      private final Lock lock = new ReentrantLock();\n      // CONDITION PREDICATE: permitsAvailable (permits &gt; 0)\n      private final Condition permitsAvailable = lock.newCondition();\n      @GuardedBy(&quot;lock&quot;) private int permits;\n\n      SemaphoreOnLock(int initialPermits) &#123;\n          lock.lock();\n          try &#123;\n              permits = initialPermits;\n          &#125; finally &#123;\n              lock.unlock();\n          &#125;\n      &#125;\n\n      // BLOCKS-UNTIL: permitsAvailable\n      public void acquire() throws InterruptedException &#123;\n          lock.lock();\n          try &#123;\n              while (permits &lt;= 0)\n                  permitsAvailable.await();\n              --permits;\n          &#125; finally &#123;\n              lock.unlock();\n          &#125;\n      &#125;\n\n      public void release() &#123;\n          lock.lock();\n          try &#123;\n              ++permits;\n              permitsAvailable.signal();\n          &#125; finally &#123;\n              lock.unlock();\n          &#125;\n      &#125;\n  &#125;\n\n在SemaphoreOnLock中，请求许可的操作在两个地方可能会阻塞——一是信号量的状态正在被锁保护着，另外是当许可不可用时。\n\n使用AQS构建的Synchronizer只可能在一个点上发生阻塞，这样降低了上下文切换的开销，并提高了吞吐量。\n\n\n14.5 AbstractQueuedSynchronizer\n了解一些标准的Synchronizer是如何实现，有助于理解它们的运作机理。\n\n一个基于AQS的Synchronizer所执行的基本操作，是一些不同形式的获取(acquire)和释放(release)。\n\n获取操作是状态依赖的操作，总能够阻塞。借助锁和信号量，“获取”的含义变得相当直观——获取锁或者许可——并且调用者可能不得不去等待，直到Synchronizer处于可发生的状态。\nCountDownLatch的请求意味着“等待，直到闭锁到达它的终止态”\nFutureTask则意味着“等待，直到任务已经完成”\n\n\n“释放”不是一个可阻塞的操作\n释放可以允许线程在请求执行前阻塞。\n\n\n为了让一个类具有状态依赖性，它必须拥有一些状态。同步类中有一些状态需要管理，这项任务落在了AQS上：它管理一个关于状态信息的单一整数，状态信息可以通过protected类型的getState、setState和compareAndSetState等方法进行操作。这可以用于表现任何状态；\n\n例如，ReentrantLock用它来表现拥有它的线程已经请求了多少次锁\nSemaphore用它来表现剩余的许可数\nFutureTask用它来表现任务的状态(尚未开始、运行、完成和取消)\n\n\nSynchronizer也可以自己管理一些额外的状态变量；\n\n例如，ReentrantLock保存了当前锁的所有者的追踪信息，这样它就能区分出是重进入(reentrant)的还是竞争的(contended)条件锁、\n\n\n\nAQS的获取与释放\n获取操作可能是独占的，就像ReentrantLock一样；\n也可能是非独占的，就像Semaphore和CountDownLatch一样。这取决于不同的Synchronizer\n\n\n\n\n一个获取操作分为两步。\n\n第一步，Synchronizer判断当前状态是否允许被获得；如果是，就让线程执行，如果不是，获取操作阻塞或失败。这个判断是由Synchronizer的语意决定的举例来说，如果想成功地获取锁，锁必须是未被占有的；而如果想成功的获取闭锁，闭锁必须未处于终止状态。\n第二步包括了可能需要更新的状态；一个想获取Synchronizer的线程会影响到其他线程是否能够获取它。例如，获取锁的操作将锁的状态从“未被占有”改变为“已被占有”；从Semaphore中获取许可的操作会减少剩余许可的数量。另一方面，一个线程对闭锁的请求操作却不会影响到其他线程是否能够获取它，所以获取闭锁的操作不会改变闭锁的状态。\n\n\n支持独占获取的Synchronizer应该实现tryAcquire、tryRelease和isHeldExclusive这几个受保护的方法\n\n而支持共享获取的Synchronizer应该实现tryAcquireShared和TryReleaseShared。\n\nAQS中的acquire、acquireShared、release和releaseShared这些方法，会调用在Synchronizer子类中这些方法的try版本，以此决定是否执行该操作。\n\nSynchronizer的子类会根据其acquire和release的语意，使用getState、setState以及compareAndSetState来检查并更新状态，然后通过返回的状态值告知基类这次“获取”或“释放”的尝试是否成功。\n\n举例来说，从tryAcquireShared返回一个负值，说明获取操作失败；返回0说明Synchronizer是被独占获取的；返回正值说明Synchronizer是被非独占获取的。\n\n对于tryRelease和tryReleaseShared方法来说，如果能够释放一些正在尝试获取Synchronizer的线程，解除这些线程的阻塞，那么这两个方法将返回true。\n\n\n14.5.1 一个简单的闭锁\n以下代码中的OneShotLatch是一个使用AQS实现的二元闭锁。它包含两个公共方法：await和signal，相当于获取和释放操作。最初，闭锁是关闭的；任何调用await的线程都会阻塞，直到打开闭锁。一旦闭锁被一个signal调用打开，等待中的线程就会被释放，而且随后到达闭锁的线程也被允许执行。\n\n在OneShotLatch中，AQS类型的状态管理着闭锁的状态——关闭(0)或打开(1)。await方法调用AQS的acquireSharedInterruptibly，后者随后请求OneShotLatch中的tryAcquireShared方法。\n\ntryAcquireShared的实现必须返回一个值，表明请求操作能否进行。\n\n如果闭锁已经事先打开，tryAcquireShared会返回成功，并允许线程通过；\n否则它会返回一个值，表明获取请求的尝试失败。acquireSharedInterruptibly方法处理失败的方式，是把线程置入一个队列中，该队列中的元素都是等待中的线程。\n\n\n类似的，signal调用releaseShared，进而导致tryReleaseShared被调用。tryReleaseShared的实现无条件地把闭锁的状态设置为打开，(通过返回值)表明Synchronizer处于完全被释放的状态。这让AQS要求所有等待中的线程尝试去重新请求Synchronizer，并且，由于tryAcquireShared会返回成功，所以这次请求操作会成功。\n  //二元闭锁使用AbstractQueuedSynchronizer\n  @ThreadSafe\n  public class OneShotLatch &#123;\n      private final Sync sync = new Sync();\n\n      public void signal() &#123;\n          sync.releaseShared(0);\n      &#125;\n\n      public void await() throws InterruptedException &#123;\n          sync.acquireSharedInterruptibly(0);\n      &#125;\n\n      private class Sync extends AbstractQueuedSynchronizer &#123;\n          protected int tryAcquireShared(int ignored) &#123;\n              // Succeed if latch is open (state == 1), else fail\n              return (getState() == 1) ? 1 : -1;\n          &#125;\n\n          protected boolean tryReleaseShared(int ignored) &#123;\n              setState(1); // Latch is now open\n              return true; // Other threads may now be able to acquire\n\n          &#125;\n      &#125;\n  &#125;\n\n\n14.6 java.util.concurrent的Synchronizer类中的AQS\njava.util.concurrent中很多可阻塞的类，比如，ReentrantLock、Semaphore、ReentrantReadWriteLock、CountDownLatch、SynchronousQueue和FutureTask，全部是用AQS构建的。\n\n14.6.1 ReentrantLock\nReentrantLock只支持独占的获取操作，因此它实现了tryAcquire、tryRelease和isHeldExclusively\n\n以下代码为，非公平版本的tryAcquire。ReentrantLock使用同步状态持有锁获取操作的计数，还使用ExclusiveOwnerThread的set和get方法来操作当前拥有的线程标识符。\n\n只有在当前线程刚刚获取到锁，或者刚刚释放了锁的时候，才会修改ExclusiveOwnerThread。\n\n当一个线程尝试去获取锁时，tryAcquire会首先请求锁的状态。如果锁未被占有，它会尝试更新锁的状态，表明锁已被占有。因为状态可能在被观察后的几条指令中被修改了，所以tryAcquire使用compareAndSetState来尝试原子地更改状态，表明这个锁现在已经被占有，并确保状态自最后一次观察后没有被修改过。假设锁状态表明它已经被占有，如果当前线程是锁的拥有者，那么获取计数会递减；如果当前线程不是锁的拥有者，那么获取操作的尝试会失败。\n\nReentrantLock还利用了AQS内置的对多条件变量和多等待集的支持。Lock.newCondition返回一个ConditionObject的新实例，这是一个AQS的内部类。\n  //非公平的ReentrantLock中tryAcquire的实现\n  /**\n   * Performs non-fair tryLock.  tryAcquire is\n   * implemented in subclasses, but both need nonfair\n   * try for trylock method.\n   */\n  final boolean nonfairTryAcquire(int acquires) &#123;\n      final Thread current = Thread.currentThread();\n      int c = getState();\n      if (c == 0) &#123;\n          if (compareAndSetState(0, acquires)) &#123;\n              setExclusiveOwnerThread(current);\n              return true;\n          &#125;\n      &#125;\n      else if (current == getExclusiveOwnerThread()) &#123;\n          int nextc = c + acquires;\n          if (nextc &lt; 0) // overflow\n              throw new Error(&quot;Maximum lock count exceeded&quot;);\n          setState(nextc);\n          return true;\n      &#125;\n      return false;\n  &#125;\n\n\n14.6.2 Semaphore 和 CountDownLatch\nSemaphore使用AQS类型的同步状态持有当前可用许可的数量。\n\nnonfairTryAcquireShared首先计算剩余许可的数量，\n\n如果没有足够的许可，会返回一个值，表明获取操作失败\n如果还有充足的许可剩余，nonfairTryAcquireShared会使用compareAndSetState，尝试原子地递减许可的计数。如果成功(这意味着自从许可计数被最后一次看到后，没有被改变过)，会返回一个值，表明获取操作成功。返回值同样加入了是否允许其他共享获取尝试能否成功的信息，如果可以的话，其他等待的线程同样会解除阻塞。\n\n\n无论是没有足够的许可，还是tryAcquireShared可以原子地更新许可计数，以响应获取操作时，while循环都会终止。尽管任何给定的compareAndSetState调用，都可能由于与另一个线程的竞争而失败，这使它会重试。在重试过合理的次数后，两个终止条件中的一个会变成真。\n\n类似的，tryReleaseShared会递增许可计数，这会潜在地解除等待中的线程的阻塞，不断地重试直到成功的更新。tryReleaseShared的返回值表明，释放操作是否可以解除其他线程的阻塞。\n  //Semaphore$Sync的 nonfairTryAcquireShared 和tryReleaseShared方法\n  final int nonfairTryAcquireShared(int acquires) &#123;\n      for (;;) &#123;\n          int available = getState();\n          int remaining = available - acquires;\n          if (remaining &lt; 0 ||\n              compareAndSetState(available, remaining))\n              return remaining;\n      &#125;\n  &#125;\n\n  protected final boolean tryReleaseShared(int releases) &#123;\n      for (;;) &#123;\n          int current = getState();\n          int next = current + releases;\n          if (next &lt; current) // overflow\n              throw new Error(&quot;Maximum permit count exceeded&quot;);\n          if (compareAndSetState(current, next))\n              return true;\n      &#125;\n  &#125;\n\n\n\n\n\nCountDownLatch使用AQS的方式与Semaphore相似：同步状态持有当前的计数。countDown方法调用release，后者会导致计数器递减，并且在计数器已经到达零的时候，解除所有等待线程的阻塞；await调用acquire，如果计数器已经到达零，acquire会立即返回，否则它会被阻塞。\n\n14.6.4 ReentrantReadWriteLock\nReadWriteLock的接口要求了两个锁——一个读者锁和一个写者锁——但是在基于AQS的ReentrantReadWriteLock实现中，一个单独的AQS子类管理了读和写的加锁。\nReentrantReadWriteLock使用了16位的状态为写锁(write-lock)计数，使用另一个16位的状态为读锁(read-lock)计数。对读锁的操作使用共享的获取与释放的方法；对写锁的操作使用独占的获取与释放的方法。\nAQS在内部维护一个等待线程的队列，持续追踪一个线程是否被独占请求或者被共享访问。在ReentrantReadWriteLock中，当锁可用时，如果位于队列头部的线程同时也正准备写访问，线程会得到锁；如果位于队列头部的线程正在准备读访问，那么队列中所有首个写线程之前的线程都会得到锁。\n\nsummary\n如果你需要实现一个依赖于状态的类——如果不能满足依赖于状态的前提条件，类的方法必须阻塞——最佳的策略通常是将它构建于现有的类库之上，比如Semaphore、BlockingQueue或者CountDownLatch。\n但是，有时现有的类库不能提供足够的功能；在这种情况下，可以使用内部条件队列、显式Condition对象或者AbstractQueuedSynchronizer，来构建属于自己的Synchronizer。\n由于”管理状态的独立性”机制必须紧密依赖于”确保状态一致性”机制，所以内部条件队列与内部锁紧密地绑定到了一起。类似地，显式的Condition是与显式的Lock也是紧密地绑定到一起的，相比于内部条件队列，它还提供了一个可扩展的特征集，包括”多等待集每锁”，可中断或不可中断的条件等待，公平或非公平的队列，以及基于最终时限的等待。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","同步"]},{"title":"13.显式锁","url":"https://java4u.cn/Java并发编程/Java并发编程/13-显示锁/","content":"\n在Java 5.0之前，用于调节共享对象访问的机制只有synchronized和volatile\nJava 5.0 提供了新的选择：ReentrantLock。\nReentrantLock并不是作为内部锁的替代，而是当内部锁被证明受到局限时，提供可选择的高级特性。\n\n13.1 Lock 和 ReentrantLock\nLock接口，定义了一些抽象的锁操作\n与内部加锁机制不同，Lock提供了\n无条件\n可轮询\n定时\n可中断的锁获取操作\n\n\n所有加锁和解锁的方法都是显式的。\n\n\n\n        public interface Lock &#123;\n            void lock();\n            void lockInterruptibly() throws InterruptedException;\n            boolean tryLock(long time, TimeUnit unit) throws InterruptedException;\n            void unlock();\n            Condition newCondition();\n        &#125;\n\nReentrantLock实现了Lock接口，提供了与synchronized相同的互斥和内存可见性的保证。\n获得ReentrantLock锁与退出synchronized块有相同的内存语义。\nReentrantLock提供了与synchronized一样的可重入加锁的语义。\n与synchronized相比，ReentrantLock为处理不可用的锁提供了更多灵活性。\n\n\n\n\n为什么要创建与内部锁如此相似的机制呢？\n内部锁大部分情况下，功能正常但是有局限性：\n不能中断那些正在等待获取锁的线程\n并且在请求锁失败的情况下，必须无限等待\n内部锁必须在获取它们的代码块中被释放\n\n\n\n\nReentrantLock不能完全替代synchronized的原因：它更加危险，因为当程序的控制权离开了守护的块时，不会自动清除锁。\n\n    //使用ReentrantLock保护对象状态\n    Lock lock = new ReentrantLock();\n    ...\n    lock.lock();\n    try&#123;\n        //更新对象的状态\n        //捕获异常，必要时恢复到原来的不变约束\n    &#125; finally&#123;\n        lock.unlock();\n    &#125;\n13.1.1 可轮询的和可定时的锁请求\n可定时的与可轮询的锁获取模式，是由tryLock方法实现，与无条件的锁获取相比，它具有更完善的错误恢复机制。\n内部锁中，死锁致命。解决死锁唯一方法是重启程序。唯一预防方法是构建时不出错，所以不可能允许不一致的锁顺序。\n可定时的与可轮询的锁提供了另一个选择：可以规避死锁的发生。\n\n\n\n\n如果你不能获得所有需要的锁，那么使用可定时的与可轮询的获取方式(tryLock)使你能够重新拿到控制权，它会释放你已经获得的这些锁，然后再重新尝试(或者至少会记录这个失败抑或采取其他措施)。\n\n以下代码可以避免锁顺序死锁：使用tryLock试图获得两个锁，如果不能同时获得两个，就回退，并重新尝试。休眠时间由一个特定的组件管理，并由一个随机组件减少活锁发生的可能性。如果一定时间内，没有能获得所有需要的锁，transferMoney返回一个失败状态，这样操作就能优雅地失败了。\n  //使用tryLock避免锁顺序死锁\n  public class DeadlockAvoidance &#123;\n      private static Random rnd = new Random();\n\n      public boolean transferMoney(Account fromAcct,\n                                   Account toAcct,\n                                   DollarAmount amount,\n                                   long timeout,\n                                   TimeUnit unit)\n              throws InsufficientFundsException, InterruptedException &#123;\n          long fixedDelay = getFixedDelayComponentNanos(timeout, unit);\n          long randMod = getRandomDelayModulusNanos(timeout, unit);\n          long stopTime = System.nanoTime() + unit.toNanos(timeout);\n\n          while (true) &#123;\n              if (fromAcct.lock.tryLock()) &#123;\n                  try &#123;\n                      if (toAcct.lock.tryLock()) &#123;\n                          try &#123;\n                              if (fromAcct.getBalance().compareTo(amount) &lt; 0)\n                                  throw new InsufficientFundsException();\n                              else &#123;\n                                  fromAcct.debit(amount);\n                                  toAcct.credit(amount);\n                                  return true;\n                              &#125;\n                          &#125; finally &#123;\n                              toAcct.lock.unlock();\n                          &#125;\n                      &#125;\n                  &#125; finally &#123;\n                      fromAcct.lock.unlock();\n                  &#125;\n              &#125;\n              if (System.nanoTime() &lt; stopTime)\n                  return false;\n              NANOSECONDS.sleep(fixedDelay + rnd.nextLong() % randMod);\n          &#125;\n      &#125;\n\n      private static final int DELAY_FIXED = 1;\n      private static final int DELAY_RANDOM = 2;\n\n      static long getFixedDelayComponentNanos(long timeout, TimeUnit unit) &#123;\n          return DELAY_FIXED;\n      &#125;\n\n      static long getRandomDelayModulusNanos(long timeout, TimeUnit unit) &#123;\n          return DELAY_RANDOM;\n      &#125;\n\n      static class DollarAmount implements Comparable&lt;DollarAmount&gt; &#123;\n          public int compareTo(DollarAmount other) &#123;\n              return 0;\n          &#125;\n\n          DollarAmount(int dollars) &#123;\n          &#125;\n      &#125;\n\n      class Account &#123;\n          public Lock lock;\n\n          void debit(DollarAmount d) &#123;\n          &#125;\n\n          void credit(DollarAmount d) &#123;\n          &#125;\n\n          DollarAmount getBalance() &#123;\n              return null;\n          &#125;\n      &#125;\n\n      class InsufficientFundsException extends Exception &#123;\n      &#125;\n  &#125;\n\n\n13.1.2　可中断的锁获取操作－　正如定时锁的获得操作允许在限时活动内部使用独占锁，可中断的锁获取操作允许在可取消的活动中使用。\n//可中断的锁获取请求\npublic class InterruptibleLocking &#123;\n    private Lock lock = new ReentrantLock();\n\n    public boolean sendOnSharedLine(String message)\n            throws InterruptedException &#123;\n        lock.lockInterruptibly();\n        try &#123;\n            return cancellableSendOnSharedLine(message);\n        &#125; finally &#123;\n            lock.unlock();\n        &#125;\n    &#125;\n\n    private boolean cancellableSendOnSharedLine(String message) throws InterruptedException &#123;\n        /* send something */\n        return true;\n    &#125;\n\n&#125;\n13.1.3 非块结构的锁\n在内部锁中，获取和释放这样成对的行为是块结构的——总是在其获得的相同的基本程序块中释放锁，而不考虑控制权是如何退出阻塞块的。自动释放锁简化了程序的分析，并避免了潜在的代码错误造成的麻烦，但是有时需要更灵活的加锁规则。\n减小锁的粒度可提高可伸缩性。分离锁时不同的哈希链在哈希容器中使用不同的锁。允许不同的线程独立地操作链表的不同部分。\n\n13.2 对性能的考量\nReentrantLock提供的竞争上的性能要远远优于内部锁。\n有越多的资源花费在锁的管理和调度上，那留给应用程序的就会越少。\n更好的实现锁的方式会使用更少的系统调用，发生更少的上下文切换，在共享的内存总线上发起更少的内存同步通信。\n\n13.3 公平性\nReentrantLock构造函数提供了两种公平性的选择：创建非公平锁(默认)或者公平锁。\nSemaphore同样提供了公平和非公平的获取顺序\n在公平锁中，如果锁已经被其他线程占有，新的请求线程会加入到等待队列，或者已经有些线程在等待锁了；\n在非公平的锁中，线程只有当锁正在被占用时才会等待。\n\n\n\n公平是好的，不公平不好，对么？\n当发生加锁的时候，公平会因为挂起和重新开始线程的代价带来巨大的性能开销。\n实践中，统计上的公平性保证——承诺一个阻塞的线程最终能够获得锁——通常已经够用了，比自由情况下的开销小得多。有些算法依赖于公平的队列，确保它们的正确性，但是有一些例外。在多数情况下，非公平锁性能的优势超过了公平地排队。\n如果不必要，不要为公平性付出代价。\n当持有锁的时间相对较长，或者请求锁的平均时间间隔比较长，那么使用公平锁是比较好的。\n\n13.4 在synchronized 和 ReentrantLock之间进行选择\nReentrantLock的性能胜过内部锁，Java 6 中时略微胜过，Java5.0 中大大超越。\n\n为什么不放弃使用synchronized而鼓励使用新的并发ReentrantLock呢？\n内部锁相比于显式锁仍然具有很大的优势。这个标识更为人们所熟悉，也更简洁，而且很多现有的程序已经在使用内部锁了——混合这两者会造成混淆，反而并更易发生错误。\n\nReentrantLock绝对是最危险的同步工具；如果你忘记在finally块中调用unlock，程序会产生问题。\n\n在内部锁不能满足需求，需要使用ReentrantLock的情况下才应该使用。\n\n需要使用以下高级特性：\n可定时的\n可轮询的\n可中断的锁获取操作\n公平队列\n非块结构的锁\n\n\n未来的性能改进可能更倾向于synchronized而不是ReentrantLock。因为synchronized是内置于JVM的，它能够进行优化，比如\n\n对线程限制的锁对象的锁省略，\n粗化锁来减小内部锁的同步性；\n\n\n\n13.5 读-写锁\nReentrantLock 实现了标准的互斥锁：一次最多只有一个线程能够持有相同ReentrantLock。\n\n但是互斥通常作为保护数据一致性的很强的加锁约束，因此过分地限制了并发性。\n\n互斥是保守的加锁策略，避免了“写/写” 和“写/读” 的重叠，但是同样避开了“读/读”的重叠。\n\n在很多情况下，数据结构是“频繁被读取”的——它们是可变的，有时候会被改变，但多数访问只进行读操作。此时，如果能够放宽，允许多个读者同时访问数据结构就非常好了。只要每个线程保证能够读到最新的数据，并且在读者读数据的时候没有其他线程修改数据，就不会发生问题。\n\n这就是读-写锁允许的情况：一个资源能够被多个读者访问，或者被一个写者访问，两者不能同时进行。\n  //ReadWriteLock接口\n  public interface ReadWriteLock&#123;\n      Lock readLock();\n      Lock writeLock();\n  &#125;\n\n\n\n读-写锁实现的加锁策略允许多个同时存在的读者，但是只允许一个写者。\n读-写锁的设计是用来进行性能改进的，使得特定情况下能够有更好的并发性。\n读取和写入锁之间的互动可以有很多种实现。ReadWriteLock的一些实现选择如下：\n释放优先。当写者释放写入锁，并且读者和写者都排在队列中，应该选择哪个——读者，写者，还是先请求的那个呢？\n读者闯入。如果锁由读者获得，但是有写者正在等待，那么新到达的写者应该被授予读取的权利么？还是应该等待？允许读者闯入到写者之前提高了并发性，但是却带来了写者饥饿的风险。\n重进入。读取锁和写入锁允许重入么？\n降级。如果线程持有写入的锁，它能够在不释放该锁的情况下获取读取锁么？这可能会造成写者“降级”为一个读取锁，同时不允许其他写者修改这个被守护的资源。\n升级。读取锁能够优先于其他的读者和写者升级为一个写入锁么？大多数读-写锁的实现并不支持升级，因为在没有显式的升级操作的情况下，很容易造成死锁。(如果两个读者同时试图升级到同一个写入锁，并都不释放读取锁。)\n\n\n\n\n\n\nReentrantReadWriteLock为两个锁提供了可重进入的加锁语义。可构造为非公平或公平。\n\n在公平的锁中，选择权交给等待时间最长的线程；如果锁由读者获得，而一个线程请求写入锁，那么不再允许读者获得读取锁，直到写者被受理，并且已经释放了写入锁。\n在非公平的锁中，线程允许访问的顺序是不定的。由写者降级为读者是允许的；从读者升级为写者是不允许的(尝试这样的行为会导致死锁)。\n\n\n与ReentrantLock相同，ReentrantReadWriteLock的写入锁有一个唯一的所有者，并只能被获得了该锁的线程释放。Java 5.0 中，读取锁的行为更类似于一个Semaphore，只维护活跃的读者数量，而不考虑它们的身份。这个行为在Java 6中获得了修改，现在也可以保持追踪哪些线程已经获得了读者锁。\n\n当锁被持有的时间相对较长，并且大部分操作都不会改变锁守护的资源，那么读-写锁能够改进并发性。以下代码，ReadWriteMap使用了ReentrantReadWriteLock来包装Map，使得它能够在多线程间被安全地共享，并仍然能够避免“读-写”或者“写-写”冲突。适用于需要为LinkedHashMap这种可替换元素的Map提供更多的并发访问。\n  //用读写锁包装的Map\n  public class ReadWriteMap &lt;K,V&gt; &#123;\n      private final Map&lt;K, V&gt; map;\n      private final ReadWriteLock lock = new ReentrantReadWriteLock();\n      private final Lock r = lock.readLock();\n      private final Lock w = lock.writeLock();\n\n      public ReadWriteMap(Map&lt;K, V&gt; map) &#123;\n          this.map = map;\n      &#125;\n\n      public V put(K key, V value) &#123;\n          w.lock();\n          try &#123;\n              return map.put(key, value);\n          &#125; finally &#123;\n              w.unlock();\n          &#125;\n      &#125;\n\n      public V remove(Object key) &#123;\n          w.lock();\n          try &#123;\n              return map.remove(key);\n          &#125; finally &#123;\n              w.unlock();\n          &#125;\n      &#125;\n\n      public void putAll(Map&lt;? extends K, ? extends V&gt; m) &#123;\n          w.lock();\n          try &#123;\n              map.putAll(m);\n          &#125; finally &#123;\n              w.unlock();\n          &#125;\n      &#125;\n\n      public void clear() &#123;\n          w.lock();\n          try &#123;\n              map.clear();\n          &#125; finally &#123;\n              w.unlock();\n          &#125;\n      &#125;\n\n      public V get(Object key) &#123;\n          r.lock();\n          try &#123;\n              return map.get(key);\n          &#125; finally &#123;\n              r.unlock();\n          &#125;\n      &#125;\n\n      public int size() &#123;\n          r.lock();\n          try &#123;\n              return map.size();\n          &#125; finally &#123;\n              r.unlock();\n          &#125;\n      &#125;\n\n      public boolean isEmpty() &#123;\n          r.lock();\n          try &#123;\n              return map.isEmpty();\n          &#125; finally &#123;\n              r.unlock();\n          &#125;\n      &#125;\n\n      public boolean containsKey(Object key) &#123;\n          r.lock();\n          try &#123;\n              return map.containsKey(key);\n          &#125; finally &#123;\n              r.unlock();\n          &#125;\n      &#125;\n\n      public boolean containsValue(Object value) &#123;\n          r.lock();\n          try &#123;\n              return map.containsValue(value);\n          &#125; finally &#123;\n              r.unlock();\n          &#125;\n      &#125;\n  &#125;\n\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","显式锁"]},{"title":"12.测试并发程序","url":"https://java4u.cn/Java并发编程/Java并发编程/12-测试并发程序/","content":"\n并发类的测试基本分为两类：\n\n安全性测试：什么坏事都没有发生过\n活跃性测试：好的事情终究会发生\n\n\n与活跃度测试相关的是性能测试。性能可以通过很多方式来测量，其中包括：\n\n吞吐量：在一个并发任务集里，已完成任务所占的比例；\n响应性：从请求到完成一些动作之间的延迟(也被称作等待时间)；\n可伸缩性：增加更多的资源(通常是指CPU)，就能提高(或者缓解短缺)吞吐量。\n\n\n\n12.1 测试正确性\nSemaphoreBoundedBuffer实现一个基于数组的定长队列\nput和take方法可阻塞并受控于一对计数信号量\navailableItems代表可以从缓存中删除的元素的个数，初始值为0\navailableSpaces代表可以插入到缓存的元素的个数，初始值为缓存的大小\n\n\n\n\ntake操作首先请求一个许可(permit)，这个许可从availableItems中获得。\n如果缓存不为空，请求立即成功，否则请求会被阻塞，直到缓存不空为止。\n一旦获得了许可，take会删除缓存中的下一个元素，同时还释放一个许可给availableSpaces信号量。\n\n    //利用Semaphore实现的有限缓存\n    @ThreadSafe\n    public class SemaphoreBoundedBuffer &lt;E&gt; &#123;\n        private final Semaphore availableItems, availableSpaces;\n        @GuardedBy(&quot;this&quot;) private final E[] items;\n        @GuardedBy(&quot;this&quot;) private int putPosition = 0, takePosition = 0;\n\n        public SemaphoreBoundedBuffer(int capacity) &#123;\n            if (capacity &lt;= 0)\n                throw new IllegalArgumentException();\n            availableItems = new Semaphore(0);\n            availableSpaces = new Semaphore(capacity);\n            items = (E[]) new Object[capacity];\n        &#125;\n\n        public boolean isEmpty() &#123;\n            return availableItems.availablePermits() == 0;\n        &#125;\n\n        public boolean isFull() &#123;\n            return availableSpaces.availablePermits() == 0;\n        &#125;\n\n        public void put(E x) throws InterruptedException &#123;\n            availableSpaces.acquire();\n            doInsert(x);\n            availableItems.release();\n        &#125;\n\n        public E take() throws InterruptedException &#123;\n            availableItems.acquire();\n            E item = doExtract();\n            availableSpaces.release();\n            return item;\n        &#125;\n\n        private synchronized void doInsert(E x) &#123;\n            int i = putPosition;\n            items[i] = x;\n            putPosition = (++i == items.length) ? 0 : i;\n        &#125;\n\n        private synchronized E doExtract() &#123;\n            int i = takePosition;\n            E x = items[i];\n            items[i] = null;\n            takePosition = (++i == items.length) ? 0 : i;\n            return x;\n        &#125;\n    &#125;\n12.1.1 基本的单元测试\n基本的单元测试与我们在顺序化上下文中所做的事情类似\n先创建一个有限缓存\n再调用它的方法\n最后断言它的后验条件和不变约束\n\n\n\n12.1.2 测试阻塞操作\n如果一个方法应该在某些条件下被阻塞，那么测试这种行为时，只有在线程没有执行完毕前，测试才是成功的。测试方法的阻塞，类似于测试方法抛出的异常；如果方法可以正常返回，则意味着失败。\n\n12.1.3 测试安全性\n\n12.1.4 测试资源管理\n测试的另一个方面是测试类没有做它不应该做的，比如资源泄露。\n\n12.1.5 使用回调\n回调用户提供的代码，有助于创建测试用例；回调常常发生在一个对象生命周期的已知点上，这些点提供了很好的机会，来断言不变约束。例如，ThreadPoolExecutor就把调用转到了任务的Runnable和ThreadFactory上。\n\n12.1.6 产生更多的交替操作\n有一个有用的技巧可以提高交替操作的数量，来更有效地探索程序的状态空间，那就是在访问共享状态的操作期间，使用Thread.yield激发更多的上下文切换。\n\n12.2 测试性能\n性能测试通常是功能测试的延伸。\n\n12.2.1 扩展PutTakeTest，加入时间特性\n与其测量一个单一操作的耗时，我们不如选择对整个运行计时，然后除以操作的数量，得到每个操作的耗时，这样可以获得更精确测试值。\n\n12.2.2 比较多种算法\n\n12.2.3 测量响应性\n知道一个独立的动作完成要花费多少时间，也很重要。这种情况下，要测量的是服务时间的差异性。\n\n12.3 避免性能测试的陷阱12.3.1 垃圾回收\n有两种策略可以避免垃圾回收时对你的结果带来的误差。\n\n第一种策略是，确保在测试运行的整个期间，垃圾回收根本不会执行(通过调用JVM时使用-verbose:gc可以做到)。\n第二种策略是，你能确保执行测试期间垃圾回收器运行多次，这样测试程序能够充分反映出运行期间的分配与垃圾回收的开销。\n\n\n通常后一种策略更佳——它需要更长的测试时间，并且更可能反映现实环境下的性能。\n\n\n12.3.2 动态编译\n对于像Java这样的动态编译语言，编写和解读它们的性能基准测试，要比C或C++这样的静态编译语言困难得多。HotSpot JVM结合了字节码解释和动态编译。当一个类被首次加载后，JVM会以字节码的方式执行。如果一个方法运行得足够频繁，动态编译器最终会将它挑出来，转换成本机代码；当编译完成后，执行方式由解释执行转换到直接执行。\n有一种方式可以避免编译对你的结果产生影响，那就是让你的程序长时间(至少几分钟)，这样编译过程和解释执行仅仅占了总体运行时间的很小一部分。\n另一种方法是让代码先进行不做测量的“热身”运动，使它得以充分执行，这样在开始计时前，代码就被完全编译了。在HotSpot中，运行程序时使用-XX:+PrintCompilation，那么程序会在动态编译运行时打印出信息，你可以通过它来验证动态编译发生在测试运行前，而不是运行中。\n\n12.3.3 代码路径的非真实取样\n### 不切实际的竞争程度\n- 并发的应用程序总是交替执行两种非常不同的工作：\n    - 第一是访问共享数据，比如从共享工作队列中获取下一个任务\n    - 第二是线程本地的计算。\n- 依赖于两种工作类型的相关特性，应用程序会经历不同级别的竞争，并表现出不同的性能与伸缩性行为。\n\n12.3.5 死代码的消除\n优化过的编译器擅长发现并遗弃死代码，这些代码不会对结果产生任何影响。\n由于基准测试通常不会进行任何计算，它们就成为了这类优化的目标。\n\n12.4 测试方法补遗\n测试的目标不是更多的发现错误，而是提高信心，相信代码能够如期地工作。\n\n12.4.1 代码审查\n好处：\n不仅可以发现错误\n通常还能改善描述实现细节的注释的质量，降低了后期维护的成本和风险。\n\n\n\n12.4.2 静态分析工具\nFindBugs包含下列并发相关的错误模式的侦测器\n不一致的同步性\n调用Thread.run\n未释放的锁\n空synchronized块\n双检查锁\n从构造函数中启动线程\n通知错误\n条件等待错误\n误用Lock和Condition\n休眠或等待时持有锁\n自旋循环\n\n\n\n12.4.3 面向方面的测试技术\nAOP\n\n12.4.4 统计与剖析工具\n内置的JMX代理为监控线程行为提供了有限的特性。ThreadInfo类就包含了线程的当前状态，而且当线程被阻塞时，它还包含了引起阻塞的锁或者条件队列的信息。如果激活了“线程竞争监视器”特性(由于对性能的影响，这个属性默认是关闭的)，ThreadInfo还会包括很多线程阻塞等待一个锁或通知的时间，以及它花费在等待上累计的时间。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发"]},{"title":"11.性能和可伸缩性","url":"https://java4u.cn/Java并发编程/Java并发编程/11-性能和可伸缩性/","content":"\n使用线程最主要的原因是提高性能。使用线程可以使程序更加充分的发挥出闲置的处理能力，从而更好的利用资源；并能够使程序在现有任务正在运行的情况下立刻开始着手处理新的任务，从而提高系统的响应性。\n\n11.1 性能的思考\n改进性能意味着用更少的资源做更多的事情。\n资源包括CPU周期、内存、网络带宽、I/O带宽、数据库请求、磁盘空间、以及其他一些资源。\n当活动的运行因某个特定资源受阻时，我们称之为受限于该资源：受限于CPU，受限于数据库。\n虽然目标是提高性能，但是使用多线程总会引入一些性能开销：与协调线程相关的开销(加锁、信号、内存同步)，增加的上下文切换，线程的创建和消亡，以及调度的开销。当线程被过度使用后，这些开销会超过吞吐量响应性和计算能力带来的补偿。\n另一方面一个没有经过良好并发设计的应用程序，甚至比相同功能的顺序的程序性能更差。\n为了实现更好的性能，我们需要更有效的利用现有的处理资源，使CPU尽可能处于忙碌状态。\n\n11.1.1 性能“遭遇”可伸缩性\n应用程序可以从很多个角度来衡量：\n服务时间、等待时间、(衡量有多快)\n吞吐量、生产量、可伸缩性、(衡量有多少)\n效率、\n\n\n\n\n可伸缩性指的是：当增加计算资源的时候(比如增加额外的CPU数量、内存、存储器、I/O带宽)，吞吐量和生产量能够得到相应的改进。\n\n\n传统调优用最小代价完成相同工作，比如通过缓存来重用以前计算的结果。为可伸缩性调优时，需要用更多的资源做更多的事情。\n在Server应用程序中，“有多少”往往比“有多快”受到更多的关注。\n\n11.1.2 对性能的权衡进行评估\n大多数性能的决定需要多个变量，并且高度依赖于发生的环境。在决定某个方案比其他方案“更快”之前，先问你自己一些问题：\n你所谓的更快指的是什么\n在什么样的条件下你的方案能够真正运行的更快？在轻负载还是重负载下？大数据集还是小数据集？是否支持你的测量标准的答案？\n这些条件在你的环境中发生的频率？是否支持你的测量标准的答案？\n这些代码在其他环境的不同条件下被用到的可能性？\n你用什么样隐含的代价，比如增加的开发风险或维护性，换取了性能的提高？这个权衡的决定是否正确？\n\n\n测评。不要臆测。\n免费的perfbar应用程序可以给你一张相当不错的图表，告诉你CPU究竟是如何忙碌地工作，并且你的目标通常是保持CPU的忙碌，这便是一个很好的方式，使你能够评估你是否需要性能调节，或者你调节的效果如何。\n\n11.2 Amdahl定律\n大多数并发程序由一系列并行和串行化的片段组成。Amdahl定律描述了在一个系统中，基于可并行化和串行化的组件各自所占的比重，程序通过获得额外的计算资源，理论上能够加速多少。如果F是必须串行化执行的比重，那么Amdahl定律告诉我们，在一个N处理器的机器中，我们最多可以加速：\n\n　　　　　　　　\n　　　　　　\n\n所有的并发程序都有一些串行源。\n\n11.2.1 定性地应用Amdahl定律\n当我们评估一个算法的时候，考虑其在成百甚至上千个处理器的情况下受到的限制，能够帮助我们洞察伸缩性的极限的出现。例如，用来减小锁的粒度：分拆锁(把一个锁分拆成两个)，分离锁(把一个锁分拆成多个锁)。透过Amdahl定律来审视它们，我们发现把一个锁分拆成两个，看上去没能在利用多处理器上帮助我们很多，但是分离锁的效果却很好，因为分离出的数量可随着处理器数量的增加而增长。\n\n11.3 线程引入的开销\n单线程程序即不存在调度问题，也不存在同步的开销，不需要使用锁来保证数据结构的一致性。调度和线程内部的协调都要付出性能的开销；对于性能改进的线程来说，并行带来的性能优势必须超过并发锁引入的开销。\n\n11.3.1 切换上下文\n如果主线程是唯一可调度的线程，它绝不会排除在调度之外。从另一方面看，如果可运行的线程数大于CPU的数量，那么OS最终会强行换出正在执行的线程，从而使其他线程能够使用CPU。这会引起上下文切换，它会保存当前运行线程的执行上下文，并重建新调入线程的执行上下文。\n切换上下文是要付出代价的；线程的调度需要操控OS和JVM中共享的数据结构。你的程序与OS、JVM使用相同的CPU；CPU在JVM和OS的代码花费越多时间，意味着用于你的程序的时间就越少。但是JVM和OS活动的花费并不是切换上下文开销的唯一来源。当一个新的线程被换入后，它所需要的数据可能不在当前处理器本地的缓存中，所以切换上下文会引起缓存缺失的小恐慌，因此线程在第一次调度的时候会运行的稍慢一些。即使有很多其他正在等待的线程，调度程序也会为每一个可运行的线程分配一个最小执行时间的定额。就是因为这个原因：它分期偿付切换上下文的开销，获得更多不中断的执行时间，从整体上提高了吞吐量(以损失响应性为代价)。\n当线程因为竞争一个锁而被阻塞时，JVM通常会将这个线程挂起，允许它被换出。如果线程频繁发生阻塞，那线程就不能完整使用它的调度限额了。一个程序发生越多的阻塞(阻塞I/O，等待竞争锁，或者等待条件变量)，与受限于CPU的程序相比，就会造成越多的上下文切换，这增加了调度的开销，并减少了吞吐量。\n切换上下文真正的开销根据不同的平台而变化，但是一条好的经验性原则是：在大多数同用的处理器中，上下文切换的开销相当于5000到10000个时钟周期，或者几微秒。\nUnix系统的vmstat命令和Windows系统的perfmon工具都能报告上下文切换次数和内核占用的时间等信息。高内核占用率(超过10%)通常象征繁重的调度活动，这很可能是由I/O阻塞，或竞争锁引起的。\n\n11.3.2 内存同步\n性能的开销有几个来源。synchronized和volatile提供的可见性保证要求使用一个特殊的、名为存储关卡(memory barrier)的指令，来刷新缓存，使缓存无效，刷新硬件的写缓冲，并延迟执行的传递。存储关卡可能同样会对性能产生影响，因为它们抑制了其他编译器的优化；在存储关卡中，大多数操作是不能被重排序的。\n\n现代的JVM能够通过优化，解除经确证不存在竞争的锁，从而减少额外的同步。\n\n更加成熟的JVM可以使用逸出分析来识别本地对象的引用并没有在堆中暴露，并且因此成为线程本地的。\n\n以下代码的getStoogeNames中，对List仅有的引用是本地变量stooges，栈限制的变量自动默认为线程本地的。在本地执行getStoogeNames，至少需要获取/释放Vector的锁4次，每个add一次，toString一次，然而，一个聪明运行时编译器，能够合并这些调用，然后发现stooges和它的内部状态一直没有逸出，因此这4次对锁的请求就可以被消除了。\n  //锁省略的候选程序\n   public final class ThreeStooges &#123;\n      private final Set&lt;String&gt; stooges = new HashSet&lt;String&gt;();\n\n      public ThreeStooges() &#123;\n          stooges.add(&quot;Moe&quot;);\n          stooges.add(&quot;Larry&quot;);\n          stooges.add(&quot;Curly&quot;);\n      &#125;\n\n      public boolean isStooge(String name) &#123;\n          return stooges.contains(name);\n      &#125;\n\n      public String getStoogeNames() &#123;\n          List&lt;String&gt; stooges = new Vector&lt;String&gt;();\n          stooges.add(&quot;Moe&quot;);\n          stooges.add(&quot;Larry&quot;);\n          stooges.add(&quot;Curly&quot;);\n          return stooges.toString();\n      &#125;\n  &#125;\n\n即使没有逸出分析，编译器同样可以进行锁的粗化，把邻近的synchronized块用相同的锁合并起来。在getStoogeNames中，JVM如果使用锁的粗化，可能会把3个add调用结合起来，并对toString使用单独的锁请求和释放，在synchronized块的内部，利用启发式方法产生同步开销，而不是指令式方法。这不仅仅减少了同步的开销，同时也给予优化者更大的代码块，很可能成就了进一步的优化。\n\n一个线程中的同步也可能影响到其他线程的性能。同步造成了共享内存总线上的通信量；这个总线的带宽是有限的，所有进程都共享这条总线。如果线程必须竞争同步带宽，所有使用到同步的线程都会受阻。\n\n\n11.3.3 阻塞\n非竞争的同步可以由JVM完全掌控，而竞争的同步可能需要OS的活动，这会增大开销。当锁为竞争性的时候，失败的线程必然发生阻塞。JVM既能自旋等待，或者在操作系统中挂起这个被阻塞的线程。\n自旋等待适合短期的等待，挂起适合长期的等待。\n阻塞归因于锁的竞争，线程持有这样的锁：当它释放该锁的时候，它必须通知OS，重新开始因该锁而阻塞的线程。\n\n11.4 减少锁的竞争\n串行化会损害可伸缩性，上下文切换会损害性能。竞争性的锁会同时导致这两种损失，所以减少锁的竞争能够改进性能和可伸缩性。\n访问独占锁守护的资源是串行的——一次只能有一个线程访问它。当然，我们有更好的理由使用锁，比如避免数据过期，但是这样的安全性是用很大的代价换来的。对锁长期的竞争会限制可伸缩性。\n\n\n并发程序中，对可伸缩性首要的威胁是独占的资源锁\n\n\n有两个原因影响着锁的竞争性：\n锁被请求的频率\n每次持有该锁的时间\n\n\n两者乘积足够小，大多数请求锁的尝试是非竞争的，但是请求量特别大，线程将会阻塞以等待锁；在极端的情况下，处理器将会闲置，即使仍有大量的工作等着完成。\n有3中方式减少锁的竞争：\n减少持有锁的时间；\n减少请求锁的频率\n或者用协调机制取代独占锁，从而允许更强的并发性。\n\n\n\n11.4.1 缩小锁的范围(“快进快出”)\n减少竞争发生可能性的有效方式是尽可能缩短把持锁的时间。这可以通过把与锁无关的代码移出synchronized块来实现，尤其是那些花费昂贵的操作，以及那些潜在的阻塞操作，比如I/O操作。\n  //持有锁超过必要的时间\n  @ThreadSafe\n  public class AttributeStore &#123;\n      @GuardedBy(&quot;this&quot;) private final Map&lt;String, String&gt;\n              attributes = new HashMap&lt;String, String&gt;();\n\n      public synchronized boolean userLocationMatches(String name,\n                                                      String regexp) &#123;\n          String key = &quot;users.&quot; + name + &quot;.location&quot;;\n          String location = attributes.get(key);\n          if (location == null)\n              return false;\n          else\n              return Pattern.matches(regexp, location);\n      &#125;\n  &#125;\n\n以下代码减少锁持续的时间\n  @ThreadSafe\n  public class BetterAttributeStore &#123;\n      @GuardedBy(&quot;this&quot;) private final Map&lt;String, String&gt;\n              attributes = new HashMap&lt;String, String&gt;();\n\n      public boolean userLocationMatches(String name, String regexp) &#123;\n          String key = &quot;users.&quot; + name + &quot;.location&quot;;\n          String location;\n          synchronized (this) &#123;\n              location = attributes.get(key);\n          &#125;\n          if (location == null)\n              return false;\n          else\n              return Pattern.matches(regexp, location);\n      &#125;\n  &#125;\n\n缩小userLocationMatches方法中锁守护的范围，大大减少了调用中遇到锁住情况的次数。由Amdahl定律得知，这消除了可伸缩性的一个阻碍，因为串行化的代码少了。\n\n因为AttributeStore只有一个状态变量，attributes，我们可用代理线程安全的技术。通过使用线程安全的Map来取代。\n\n\n11.4.2 减小锁的粒度\n减小持有锁的时间比例的另一种方式是让线程减少调用它的频率。\n\n这可用通过分拆锁(lock splitting)**和分离锁(lock striping)**来实现，也就是采用相互独立的锁，守卫多个独立的状态变量，在改变之前，它们都是由一个锁守护的。这些技术减小了锁发生时的粒度，潜在实现了更好的可伸缩性——但是使用更多的锁同样会增加死锁的风险。\n\n应当分拆锁的候选程序\n  @ThreadSafe\n  public class ServerStatusBeforeSplit &#123;\n      @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; users;\n      @GuardedBy(&quot;this&quot;) public final Set&lt;String&gt; queries;\n\n      public ServerStatusBeforeSplit() &#123;\n          users = new HashSet&lt;String&gt;();\n          queries = new HashSet&lt;String&gt;();\n      &#125;\n\n      public synchronized void addUser(String u) &#123;\n          users.add(u);\n      &#125;\n\n      public synchronized void addQuery(String q) &#123;\n          queries.add(q);\n      &#125;\n\n      public synchronized void removeUser(String u) &#123;\n          users.remove(u);\n      &#125;\n\n      public synchronized void removeQuery(String q) &#123;\n          queries.remove(q);\n      &#125;\n  &#125;\n\n使用分拆的锁重构ServerStatus\n  @ThreadSafe\n  public class ServerStatusAfterSplit &#123;\n      @GuardedBy(&quot;users&quot;) public final Set&lt;String&gt; users;\n      @GuardedBy(&quot;queries&quot;) public final Set&lt;String&gt; queries;\n\n      public ServerStatusAfterSplit() &#123;\n          users = new HashSet&lt;String&gt;();\n          queries = new HashSet&lt;String&gt;();\n      &#125;\n\n      public void addUser(String u) &#123;\n          synchronized (users) &#123;\n              users.add(u);\n          &#125;\n      &#125;\n\n      public void addQuery(String q) &#123;\n          synchronized (queries) &#123;\n              queries.add(q);\n          &#125;\n      &#125;\n\n      public void removeUser(String u) &#123;\n          synchronized (users) &#123;\n              users.remove(u);\n          &#125;\n      &#125;\n\n      public void removeQuery(String q) &#123;\n          synchronized (users) &#123;\n              queries.remove(q);\n          &#125;\n      &#125;\n  &#125;\n\n分拆锁之后，每个新的更精巧的锁，相比于那些原始的粗糙锁，将会看到更少的通信量。\n\n\n11.4.3 分离锁\n把一个锁竞争激烈的锁分拆成两个，很可能形成两个竞争激烈的锁。\n\n分拆锁有时候可以被扩展，分成可大可小加锁块的集合，并且它们归属于相互独立的对象，这样的情况就是分离锁。例如，ConcurrentHashMap的实现使用了一个包含16个锁的Array，每一个锁都守护Hash Bucket的1 / 16；Bucket N由第N mod 16个锁来守护。假设哈希提供合理的拓展特性，并且关键字能够以统一的方式访问，这将会把对于锁的请求减少到约为原来的1 / 16。这项技术使得ConcurrentHashMap能够支持16个并发的Writer。\n\n分离锁的一个负面作用是：对容器加锁，进行独占访问更加困难，并且更加昂贵了。通常，一个操作可以通过获取最多不超过一个锁来进行，但是有个别的情况需要对整个容器加锁，比如当ConcurrentHashMap的值需要被扩展、重排，放入一个更大的Bucket时。这是获取所有分离的锁的最典型的例子。\n\n以下代码，StripedMap阐释了基于哈希的Map实现，其中用到了锁分离。他拥有N_LOCKS个锁，每一个守护Bucket的一个子集，大部分方法，比如get，只需要得到一个Bucket锁。有些方法需要获得所有的锁，但是如clear方法实现的那样，并不需要同时获得所有这些锁。\n  //基于哈希的map中使用分离锁\n  @ThreadSafe\n  public class StripedMap &#123;\n      // Synchronization policy: buckets[n] guarded by locks[n%N_LOCKS]\n      private static final int N_LOCKS = 16;\n      private final Node[] buckets;\n      private final Object[] locks;\n\n      private static class Node &#123;\n          Node next;\n          Object key;\n          Object value;\n      &#125;\n\n      public StripedMap(int numBuckets) &#123;\n          buckets = new Node[numBuckets];\n          locks = new Object[N_LOCKS];\n          for (int i = 0; i &lt; N_LOCKS; i++)\n              locks[i] = new Object();\n      &#125;\n\n      private final int hash(Object key) &#123;\n          return Math.abs(key.hashCode() % buckets.length);\n      &#125;\n\n      public Object get(Object key) &#123;\n          int hash = hash(key);\n          synchronized (locks[hash % N_LOCKS]) &#123;\n              for (Node m = buckets[hash]; m != null; m = m.next)\n                  if (m.key.equals(key))\n                      return m.value;\n          &#125;\n          return null;\n      &#125;\n\n      public void clear() &#123;\n          for (int i = 0; i &lt; buckets.length; i++) &#123;\n              synchronized (locks[i % N_LOCKS]) &#123;\n                  buckets[i] = null;\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n\n11.4.4 避免热点域\n分拆锁和分离锁能够改进可伸缩性，因为它们能够使不同线程操作不同的数据或者(相同数据结构的不同部分)，而不会发生相互干扰。能够从分析锁受益的程序，通常是那些对锁的竞争普遍大于对锁守护数据竞争的程序。如果一个锁守护两个独立变量X和Y，线程A想要访问X，而线程B想要访问Y，这两个线程没有竞争任何数据，然而它们竞争相同的锁。\n独立的计数器可以提高类似size方法的速度，却使改进可伸缩性变得更难，因为每一个修改map的操作都要更新这个共享的计数器。计数器被称为“热点域(hot field)，因为每个变化操作都要访问它。\n为避免这个问题，ConcurrentHashMap通过枚举每个条目获得size，并把这个值加入到每个条目，而不是维护一个全局计数。为了避免列举所有元素，ConcurrentHashMap为每一个条目维护一个独立的计数域。同样由分离的锁守护。\n\n11.4.5 独占锁的替代方法\n用于减轻竞争锁带来的影响的第三种技术是提前使用独占锁，这有助于使用更友好的并发方式进行共享状态的管理。这包括使用：\n并发容器\n读写锁\n不可变对象\n原子变量\n\n\nReadWriteLock实行了一个多读者单写者加锁规则：只要没有更改，那么多个读者可以并发访问共享资源，但是写者必须独占获得锁。、\n原子变量提供了能够减少更新“热点域”的方式，如静态计数器、序列发生器、或者对链表数据结构头结点的引用。原子变量类提供了针对整数或对象引用的非常精妙的原子操作(因此更具有可伸缩性)，并且使用现代处理器提供的低层并发原语，比如比较并交换实现。\n\n11.4.6 检测CPU利用率\n当我们测试可伸缩性的时候，我们的目标通常是保持处理器的充分利用。Unix系统的vmstat和mpstat，或者Windows的perfmon都可以查看处理器忙碌状况。\n如果CPU没有完全利用，可能以下原因：\n不充足的负载。\nI/O限制。\n外部限制。比如数据库，或者Web Service\n锁竞争。使用Profiling工具能够告诉你，程序中存在多少个锁的竞争，哪些锁很抢手。\n\n\n\n11.4.7 向“对象池”说“不”\n针对对象的慢生命周期，很多程序员都会选择使用对象池化技术，这项技术中，对象会被循环使用，而不是由垃圾收集器回收并在需要时重新分配。在单线程化的程序中，即使考虑到减少的垃圾收集开销，对象化池技术对于所有不那么昂贵的对象仍然存在性能缺失。\n在并发中，池化表现的更糟糕。当线程分配新的对象时，需要线程内部非常细微的协调，因为分配运算通常使用线程本地的分配块来消除对象堆中的大部分同步。\n\n11.5 比较Map的性能\n单线程化的ConcurrentHashMap的性能比同步的HashMap的性能稍好一些，而且在并发应用中，这种作用就十分明显了。\n同步Map的整个Map存在一个锁，所以一次只有一个线程能够访问map\nConcurrentHashMap并没有对成功的读操作加锁，对写操作和真正需要锁的操作的读操作使用了分离锁的方法。所以多线程并发访问Map，而不被阻塞。\n\n11.6 减少上下文切换的开销\n很多任务引入的操作都会发生阻塞；在运行和阻塞这两个状态之间转换需要使用上下文切换。\n服务器应用程序发生阻塞的一个缘由是在处理请求期间产生日志消息；\n并发系统在多数锁为非竞争锁的时候会有更好的性能，因为请求竞争性的锁意味着更多的上下文切换。代码如果造成更多的上下文切换意味着产生更小的吞吐量。\n\nsummary\n使用线程最主要的目的是利用多处理器资源\n在并发程序性能讨论中，我们通常更关注吞吐量和可伸缩性，而没有强调自然服务时间。\nAmdahl定律告诉我们，程序的可伸缩性是由必须连续执行的代码比例决定的。\n因为Java程序中串行化首要的来源是独占的资源锁，所以可伸缩性通常可以通过以下这些方式提升：\n减少用于获取锁的时间，\n减小锁的粒度\n减少锁的占用时间\n用非独占或非阻塞锁来取代独占锁\n\n\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","性能和可伸缩性"]},{"title":"10.避免活跃度危险","url":"https://java4u.cn/Java并发编程/Java并发编程/10-避免活跃度危险/","content":"\n安全性和活跃度通常相互牵制。我们使用锁来保证线程安全，但是滥用锁可能引起**锁顺序死锁(lock-ordering deadlock)**。\n我们使用线程池和信号量来约束资源的使用，但是却不能知晓那些管辖范围内的活动可能形成的**资源死锁(resource deadlock)**。\n这一章将讲述一些引发活跃度失败的原因，以及避免发生这些失败的方法。\n\n10.1 死锁\n经典的“哲学家进餐问题”很好的解释了死锁。\n当一个线程永远占有一个锁，而其他线程尝试去获得这个锁，那么它们将永远被阻塞。当线程A占有锁L时，想要获得锁M，但是同时，线程B持有M，并尝试获得L，两个线程将永远等待下去。这种情况是死锁最简单的形式(或称**致命的拥抱,deadly embrace)**，发生在多个线程因为环路的锁依赖关系而永远等待的情况下。(把这些线程假想为有向图的节点，图的边表现了这个关系：线程A等待线程B占有的资源，如果图最后连成了一个环路，那么死锁也就产生了。)\n数据库系统的设计就针对了监测死锁，以及从死锁中恢复。一个事务可能需要取得许多锁，并可能一直持有这些锁，直到所有事务提交。如此说来两个事务非常有可能发生死锁，但这却并不常见。数据库服务器当它监测到一个事务集发生了死锁，它会选择牺牲者，使它退出事务。这个牺牲者释放的资源，使得其他事务能够继续进行。应用程序可以重新执行那个被强行退出的事务，现在这个事务可能就能够成功完成了，因为所有跟它竞争资源的事务都已经完成了。\nJVM在解决死锁方面与数据库服务不同，当一个Java线程集发生死锁时，这些线程永远不能使用了。恢复应用程序健康的唯一方式就是中止并重启，然后寄希望于不要再发生同样的事情。\n死锁出现往往在高负载之下。\n\n10.1.1 锁顺序死锁\n以下代码的LeftRightDeadlock存在死锁风险。leftRight和rightLeft分别获得left锁和right锁。如果一个线程调用了leftRight，另一个线程调用了rightLeft，那么可能会发生死锁。\n  //简单的锁顺序死锁(不要这样做)\n  public class LeftRightDeadlock &#123;\n      private final Object left = new Object();\n      private final Object right = new Object();\n\n      public void leftRight() &#123;\n          synchronized (left) &#123;\n              synchronized (right) &#123;\n                  doSomething();\n              &#125;\n          &#125;\n      &#125;\n\n      public void rightLeft() &#123;\n          synchronized (right) &#123;\n              synchronized (left) &#123;\n                  doSomethingElse();\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\nLeftRightDeadlock发生死锁的原因是:两个线程试图通过不同的顺序获得多个相同的锁。如果请求的顺序相同，就不会出现循环的锁依赖现象，也就不会产生死锁了。\n\n如果所有线程以通过的固定秩序获得锁，程序就不会出现锁顺序死锁问题了。\n\n\n\n10.1.2 动态的锁顺序死锁\n以下代码看似无害，它把资金从一个账户转入另一个账户。在执行转账之前要获得Account对象的锁，为了账目的平衡要保证更新操作是原子化的，同时不能破坏固有约束，比如一个账户的余额不能为负数。\n  //动态加锁顺序产生的死锁(不要这样做)\n  public class DynamicOrderDeadlock &#123;\n      // Warning: deadlock-prone!\n      public static void transferMoney(Account fromAccount,\n                                       Account toAccount,\n                                       DollarAmount amount)\n              throws InsufficientFundsException &#123;\n          synchronized (fromAccount) &#123;\n              synchronized (toAccount) &#123;\n                  if (fromAccount.getBalance().compareTo(amount) &lt; 0)\n                      throw new InsufficientFundsException();\n                  else &#123;\n                      fromAccount.debit(amount);\n                      toAccount.credit(amount);\n                  &#125;\n              &#125;\n          &#125;\n      &#125;\n\n      static class DollarAmount implements Comparable&lt;DollarAmount&gt; &#123;\n          // Needs implementation\n\n          public DollarAmount(int amount) &#123;\n          &#125;\n\n          public DollarAmount add(DollarAmount d) &#123;\n              return null;\n          &#125;\n\n          public DollarAmount subtract(DollarAmount d) &#123;\n              return null;\n          &#125;\n\n          public int compareTo(DollarAmount dollarAmount) &#123;\n              return 0;\n          &#125;\n      &#125;\n\n      static class Account &#123;\n          private DollarAmount balance;\n          private final int acctNo;\n          private static final AtomicInteger sequence = new AtomicInteger();\n\n          public Account() &#123;\n              acctNo = sequence.incrementAndGet();\n          &#125;\n\n          void debit(DollarAmount d) &#123;\n              balance = balance.subtract(d);\n          &#125;\n\n          void credit(DollarAmount d) &#123;\n              balance = balance.add(d);\n          &#125;\n\n          DollarAmount getBalance() &#123;\n              return balance;\n          &#125;\n\n          int getAcctNo() &#123;\n              return acctNo;\n          &#125;\n      &#125;\n\n      static class InsufficientFundsException extends Exception &#123;\n      &#125;\n  &#125;\n\n如果两个线程同时调用transferMoney，一个从X向Y转账，另一个从Y向X转账，那么就会发生死锁：\n\nA:transferMoney(myAccount, yourAccount, 10);\nB:transferMoney(yourAccount, myAccount, 20);\n\n\n在偶发的时序中，A会获得myAccount的锁，并等待yourAccount的锁，然而B此时持有yourAccount的锁，正在等待myAccount的锁。\n\n这样的死锁可以通过获得锁时，查看是否嵌套来检查。为了解决这个问题，必须制定锁的顺序，并且在整个应用程序中，获得锁都必须遵守这个既定的顺序。\n\n我们在制定对象顺序的时候，可以使用System.indentityHashCode这样一种方式，它会返回Object.hashCode所返回的值。以下代码为transferMoney的又一个版本，它使用了System.identityHashCode定义了锁的顺序。虽然它带来了一些新的代码，但是它能够减少死锁发生的可能性。\n  //制定锁的顺序来避免死锁\n  public class InduceLockOrder &#123;\n      private static final Object tieLock = new Object();\n\n      public void transferMoney(final Account fromAcct,\n                                final Account toAcct,\n                                final DollarAmount amount)\n              throws InsufficientFundsException &#123;\n          class Helper &#123;\n              public void transfer() throws InsufficientFundsException &#123;\n                  if (fromAcct.getBalance().compareTo(amount) &lt; 0)\n                      throw new InsufficientFundsException();\n                  else &#123;\n                      fromAcct.debit(amount);\n                      toAcct.credit(amount);\n                  &#125;\n              &#125;\n          &#125;\n          int fromHash = System.identityHashCode(fromAcct);\n          int toHash = System.identityHashCode(toAcct);\n\n          if (fromHash &lt; toHash) &#123;\n              synchronized (fromAcct) &#123;\n                  synchronized (toAcct) &#123;\n                      new Helper().transfer();\n                  &#125;\n              &#125;\n          &#125; else if (fromHash &gt; toHash) &#123;\n              synchronized (toAcct) &#123;\n                  synchronized (fromAcct) &#123;\n                      new Helper().transfer();\n                  &#125;\n              &#125;\n          &#125; else &#123;\n              synchronized (tieLock) &#123;\n                  synchronized (fromAcct) &#123;\n                      synchronized (toAcct) &#123;\n                          new Helper().transfer();\n                      &#125;\n                  &#125;\n              &#125;\n          &#125;\n      &#125;\n\n      interface DollarAmount extends Comparable&lt;DollarAmount&gt; &#123;\n      &#125;\n\n      interface Account &#123;\n          void debit(DollarAmount d);\n\n          void credit(DollarAmount d);\n\n          DollarAmount getBalance();\n\n          int getAcctNo();\n      &#125;\n\n      class InsufficientFundsException extends Exception &#123;\n      &#125;\n  &#125;\n\n若出现哈希冲突，使用加时赛锁，保证一次只有一个线程执行这个有风险的操作以未知的顺序获得锁，从而减少死锁发生的可能性。\n\n如果Account具有唯一的不可变的，并且具有可比性的key，比如账号，那么制定锁的顺序就更加容易了：通过key来排定对象顺序，这样能省去加时赛锁的需要。\n\n死锁在真实的系统中是个很严重的问题。以下代码在大多数系统下都会很快发生死锁。\n  //开始一个循环，它在典型条件下制定死锁\n  public class DemonstrateDeadlock &#123;\n      private static final int NUM_THREADS = 20;\n      private static final int NUM_ACCOUNTS = 5;\n      private static final int NUM_ITERATIONS = 1000000;\n\n      public static void main(String[] args) &#123;\n          final Random rnd = new Random();\n          final Account[] accounts = new Account[NUM_ACCOUNTS];\n\n          for (int i = 0; i &lt; accounts.length; i++)\n              accounts[i] = new Account();\n\n          class TransferThread extends Thread &#123;\n              public void run() &#123;\n                  for (int i = 0; i &lt; NUM_ITERATIONS; i++) &#123;\n                      int fromAcct = rnd.nextInt(NUM_ACCOUNTS);\n                      int toAcct = rnd.nextInt(NUM_ACCOUNTS);\n                      DollarAmount amount = new DollarAmount(rnd.nextInt(1000));\n                      try &#123;\n                          DynamicOrderDeadlock.transferMoney(accounts[fromAcct], accounts[toAcct], amount);\n                      &#125; catch (DynamicOrderDeadlock.InsufficientFundsException ignored) &#123;\n                      &#125;\n                  &#125;\n              &#125;\n          &#125;\n          for (int i = 0; i &lt; NUM_THREADS; i++)\n              new TransferThread().start();\n      &#125;\n  &#125;\n\n\n10.1.3 协作对象间的死锁\n获取多重的锁并不总是像在LeftRightDeadlock或者transferMoney中那么明显；可能不是在同一个方法中请求两个锁。以下代码中相互协作的类，他可能用于出租车调遣系统。Taxi代表个体出租车，具有位置和方向两个属性；dispatcher代表一组出租车。\n  //协作对象间的锁顺序死锁(不要这样做)\n  public class CooperatingDeadlock &#123;\n      // Warning: deadlock-prone!\n      class Taxi &#123;\n          @GuardedBy(&quot;this&quot;) private Point location, destination;\n          private final Dispatcher dispatcher;\n\n          public Taxi(Dispatcher dispatcher) &#123;\n              this.dispatcher = dispatcher;\n          &#125;\n\n          public synchronized Point getLocation() &#123;\n              return location;\n          &#125;\n\n          public synchronized void setLocation(Point location) &#123;\n              this.location = location;\n              if (location.equals(destination))\n                  dispatcher.notifyAvailable(this);\n          &#125;\n\n          public synchronized Point getDestination() &#123;\n              return destination;\n          &#125;\n\n          public synchronized void setDestination(Point destination) &#123;\n              this.destination = destination;\n          &#125;\n      &#125;\n\n      class Dispatcher &#123;\n          @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; taxis;\n          @GuardedBy(&quot;this&quot;) private final Set&lt;Taxi&gt; availableTaxis;\n\n          public Dispatcher() &#123;\n              taxis = new HashSet&lt;Taxi&gt;();\n              availableTaxis = new HashSet&lt;Taxi&gt;();\n          &#125;\n\n          public synchronized void notifyAvailable(Taxi taxi) &#123;\n              availableTaxis.add(taxi);\n          &#125;\n\n          public synchronized Image getImage() &#123;\n              Image image = new Image();\n              for (Taxi t : taxis)\n                  image.drawMarker(t.getLocation());\n              return image;\n          &#125;\n      &#125;\n\n      class Image &#123;\n          public void drawMarker(Point p) &#123;\n          &#125;\n      &#125;\n  &#125;\n\n尽管没有方法显式的获得两个锁，不同的setLocation和getImage的调用者同样可以获得两个锁。如果一个线程调用setLocation作为对GPS接收器更新的响应，它首先更新出租车的位置，然后检查其是否到达了目的地，如果已经到达，那么它会通知Dispatcher，它需要一个新的目标。因为setLocation和notifyAvailable都是synchronized方法，调用setLocation的线程获取了Taxi的锁，然后又获取了Dispatcher的锁(一次一个)。正如在LeftRightDeadlock中发生的，两个锁被两个线程以不同顺序占有，产生死锁风险。\n\n\n\n在持有锁的时候调用外部方法是在挑战活跃度问题。外部方法可能会获得其他锁(产生死锁的风险)，或者遭遇严重超时的阻塞。当你持有锁的时候会延迟其他试图获得该锁的线程。\n\n10.1.4 开放调用\n由于不能知道调用的另一方发生的事情，在持有锁的时候调用一个外部方法很难进行分析，因此是危险的。\n\n当调用的方法不需要持有锁时，这被称为**开放调用(open call)**，依赖于开放调用的类会具有更好的行为，并且比那些需要获得锁才能调用的方法相比，更容易与其它的类合作。\n\n使用开放调用来避免死锁类似于使用封装来提供线程安全：尽管我们能够保证在没有封装的情况下构建线程安全的程序，但是对一个有效封装的类进行线程安全分析，要比分析没有封装的类容易的多。类似的，分析一个完全依赖于开放调用的程序的程序活跃度，比分析那些非开放调用的程序更简单。尽量让你自己使用开放调用，这要比获得多重锁后识别代码路径更简单，因此可以确保一致的顺序获得锁。\n  //使用开放调用来避免协作对象之间的死锁\n  class CooperatingNoDeadlock &#123;\n      @ThreadSafe\n      class Taxi &#123;\n          @GuardedBy(&quot;this&quot;) private Point location, destination;\n          private final Dispatcher dispatcher;\n\n          public Taxi(Dispatcher dispatcher) &#123;\n              this.dispatcher = dispatcher;\n          &#125;\n\n          public synchronized Point getLocation() &#123;\n              return location;\n          &#125;\n\n          public synchronized void setLocation(Point location) &#123;\n              boolean reachedDestination;\n              synchronized (this) &#123;\n                  this.location = location;\n                  reachedDestination = location.equals(destination);\n              &#125;\n              if (reachedDestination)\n                  dispatcher.notifyAvailable(this);\n          &#125;\n\n          public synchronized Point getDestination() &#123;\n              return destination;\n          &#125;\n\n          public synchronized void setDestination(Point destination) &#123;\n              this.destination = destination;\n          &#125;\n      &#125;\n  &#125;\n\n\n\n在程序中尽量使用开放调用。依赖于开放调用的程序，相比那些在持有锁的时候还调用外部方法的程序，更容易进行死锁自由度的分析。\n\n\n重新构建synchronized块有时会使开放调用产生出乎预料的结果，因为它使得一个原子操作变为非原子操作。有时候，这样损失了原子性的操作是完全可以接受的；更新出租车的位置，并通知分派程序这辆车已经准备好随时待命，这两件事并不需要成为原子操作。\n但是有时原子性的损失会引发问题，这里你需要使用另一种技术来实现原子性。构建一个并发的对象。这能够防止其他线程尝试进入，这胜于使用锁来避免其他线程进入代码的临界区。\n\n10.1.5 资源死锁\n当线程间相互等待对方持有的锁，并且谁都不会释放自己的锁时就会发生死锁，当线程持有和等待的目标变为资源时，会发生与之类似的死锁。\n假设你有两个放入池中的资源，比如分别是到两个数据库的连接池。资源池通过信号量实现，当池为空的时候发生阻塞。如果一个任务需要连接到两个数据库，并且两个资源并不是按照相同顺序进行调用的的，线程A可能持有至数据库D1的连接，并等待连接到数据库D2，而线程B持有至D2的连接并等待到D1的连接。\n另一种形式的基于资源的死锁是线程饥饿死锁。需要等待其他任务的结果的任务是生成线程饥饿死锁的来源；有界池和相互依赖的任务不能放在一起使用。\n\n10.2 避免和诊断死锁\n如果一个程序一次至多获得一个锁，那么就不会产生锁顺序死锁。当然这并不现实。锁的顺序必须是你设计工作的一部分：尽量减少潜在锁之间的交互数量，遵守并文档化该锁顺序协议。\n在使用定义良好的锁的程序中，监测代码中死锁自由度的策略分为两个部分：\n首先识别什么地方会获取多个锁，对这些示例进行全局的分析，确保它们锁的顺序在程序中保持一致。\n尽可能使用开放调用，这样做能够从根本上简化分析的难度。\n\n\n\n10.2.1 尝试定时的锁\n另一项监测死锁和从死锁中恢复的技术，是使用每个显式Lock类定时tryLock特性，来替代使用内部锁机制。\n在内部锁的机制中，只要没有获得锁，就会永远保持等待，而显式的锁使你能够定义超时的时间，在规定时间之后tryLock还没有获得锁就返回失败。\n\n10.2.2 通过线程转储分析死锁\n预防死锁是你面临的最大问题，JVM使用**线程转储(thread dump)**来帮助你识别死锁的发生。线程转储包括\n每个运行中线程的栈追踪信息，\n以及与之相似并随之发生的异常。\n锁的信息，比如哪个锁由哪个线程获得，其中获得这些锁的栈结构，以及阻塞线程正在等待的锁究竟是哪一个。\n\n\n\n10.3 其他的活跃度危险\n尽管死锁使我们遇到的最主要的活跃度危险，并发程序中仍然可能遇到一些其他的活跃度危险，包括：饥饿，丢失信号和活锁。\n\n10.3.1 饥饿\n当线程访问它所需要的资源时却被永久拒绝，以至于不能再继续进行，这样就发生了**饥饿(starvation)**；最常见的引发饥饿的资源是CPU周期。在Java应用程序中，使用线程的优先级不当可能引起饥饿。在锁中执行无终止的构建也可能引起饥饿(无限循环，或者无尽等待资源)，因为其他需要这个锁的线程永远不可能得到它。\n线程API定义了是个优先级级别，并对应到操作系统响应的调度优先级中。\n\n\n抵制使用线程优先级的诱惑，因为这会增加平台依赖性，并且可能引起活跃度问题，大多数并发应用程序可以对所有线程使用相同的优先级。\n\n10.3.2 弱响应性\n除饥饿以外的另一个问题是弱响应性，在GUI应用程序中使用的后台线程的情况下，这是很常见的。把耗时任务分载到后台线程中，这样就不会造成用户界面冻结了。\nCPU密集型的后台任务会影响响应性，因为它们会与事件线程共同竞争CPU的微周期。\n不良的锁管理也可能引起弱响应性。如果一个线程长时间占有一个锁，其他想要访问该容器的线程就必须等待很长事件。\n\n10.3.3 活锁\n**活锁(livelock)**是线程中活跃度失败的另一种形式，尽管没有被阻塞，线程却仍然不能继续，因为它不断重试相同的操作，却总是失败。\n活锁通常发生在消息处理应用程序中，如果消息处理失败的话，其中传递消息的底层架构会回退整个事务，并把它置回队首。如果消息处理程序对某种特定类型的消息处理存在bug，每次处理都会失败，那么每一次这个消息都会被从队列中取出，传递到存在问题的处理器，然后发生事务回退。因为这条消息又会到队首，处理器会不断被这样重复调用，并返回重复结果。这就是通常成为**毒药信息(poison message)**的问题。信息处理线程并没有发生阻塞，但是永远都不会前进了。这种形式的活锁通常来源于过渡的的错误恢复代码，误将不可修复的错误当做是可修复的错误。\n活锁同样发生在多个相互协作的线程间，当它们为了彼此间响应而修改了状态，使得没有一个线程能够继续前进，那么就发生了活锁。这好比两个过于礼貌的人在半路相遇：他们都避开对方的路，于是在另外一条路上又相遇了。所以就这样不停地一直避让下去了…\n解决这些多样的活锁的一种方案是对重试机制引入一些随机性。\n例如，在以太网络上，两个基站尝试使用相同的载波发送数据包，包会发送冲突。基站发现了冲突，并且都在稍后重发。如果它们都非常精确地在一秒后重试，它们又会发送冲突，并不断冲突下去，导致数据包永远不能发送，即使有大量的带宽都是闲置的。\n为了避免这种情况发生，我们通过用一个随机组件使它们进行等待。\n\n\n在并发程序中，通过随机等待和撤回来进行重试能够相当有效地避免活锁的发生。\n\nsummary\n活跃度失败是很严重的问题，因为除了短时间地中止应用程序，没有任何机制可以恢复这种失败。\n最常见的活跃度失败是锁顺序死锁。应该在设计时就避免锁顺序死锁：确保多个线程在获得多个锁时，使用一致的顺序。\n最好的解决方法是在程序中使用开放调用。这会大大减少一个线程一次请求多个锁的情况，并且使这样的多重锁请求的发生更加明显。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","避免活跃度危险"]},{"title":"09.GUI应用程序","url":"https://java4u.cn/Java并发编程/Java并发编程/09-GUI应用程序/","content":"\n几乎所有的GUI工具集都实现为**单线程化子系统(single-threaded)**，意味着所有GUI的活动都被限制在一个单独的线程中，这其中就包括了Swing和SWT。\n\n9.1 为什么GUI是单线程化的\n早期的GUI应用程序就是单线程化的，GUI在“主事件循环”进行处理。现代的GUI框架使用了一个略微不同的模型：模型创建了一个专门的线程，**事件派发线程(event dispatch thread，EDT)**来处理GUI事件。\n\n9.1.1 顺序事件处理\n任务依次处理，不会交迭\n不利的一面：如果一个任务处理时间长，其他任务必须等。\n\n9.1.2 Swing中的线程限制\n所有的Swing组件(比如JButton和JTable)和数据模型(TableModel和TreeModel)都被限制于事件线程中，所以任何访问它们的代码必须在事件线程中运行。GUI对象不用同步，仅仅依靠线程限制来保持一致性。\n\n\nSwing的单线程规则：Swing的组件和模型只能在事件分派线程中被创建、修改和请求。\n\n    //使用Executor实现的SwingUtillities\n    public class SwingUtilities &#123;\n        private static final ExecutorService exec =\n                Executors.newSingleThreadExecutor(new SwingThreadFactory());\n        private static volatile Thread swingThread;\n\n        private static class SwingThreadFactory implements ThreadFactory &#123;\n            public Thread newThread(Runnable r) &#123;\n                swingThread = new Thread(r);\n                return swingThread;\n            &#125;\n        &#125;\n\n        public static boolean isEventDispatchThread() &#123;\n            return Thread.currentThread() == swingThread;\n        &#125;\n\n        public static void invokeLater(Runnable task) &#123;\n            exec.execute(task);\n        &#125;\n\n        public static void invokeAndWait(Runnable task)\n                throws InterruptedException, InvocationTargetException &#123;\n            Future f = exec.submit(task);\n            try &#123;\n                f.get();\n            &#125; catch (ExecutionException e) &#123;\n                throw new InvocationTargetException(e);\n            &#125;\n        &#125;\n    &#125;\n\nGuiExecutor是一个Executor，它把任务的执行委托给SwingUtilities完成。\n  //构建于SwingUtilities之上的Executor\n  public class GuiExecutor extends AbstractExecutorService &#123;\n      // Singletons have a private constructor and a public factory\n      private static final GuiExecutor instance = new GuiExecutor();\n\n      private GuiExecutor() &#123;\n      &#125;\n\n      public static GuiExecutor instance() &#123;\n          return instance;\n      &#125;\n\n      public void execute(Runnable r) &#123;\n          if (SwingUtilities.isEventDispatchThread())\n              r.run();\n          else\n              SwingUtilities.invokeLater(r);\n      &#125;\n\n      public void shutdown() &#123;\n          throw new UnsupportedOperationException();\n      &#125;\n\n      public List&lt;Runnable&gt; shutdownNow() &#123;\n          throw new UnsupportedOperationException();\n      &#125;\n\n      public boolean awaitTermination(long timeout, TimeUnit unit)\n              throws InterruptedException &#123;\n          throw new UnsupportedOperationException();\n      &#125;\n\n      public boolean isShutdown() &#123;\n          return false;\n      &#125;\n\n      public boolean isTerminated() &#123;\n          return false;\n      &#125;\n  &#125;\n\n\n9.2 短期的GUI任务\n短期的任务可以把全部动作留在事件线程中完成；而对于耗时的任务，则应该将一些工作负荷分压到另一个线程中\n\n9.3 耗时GUI任务\n成熟的GUI应用程序可能会运行一些耗时的任务，以致于超过了用户预期的时间，比如拼写检查、后台编辑或者获取远程资源。这些任务必须在另外的线程中运行，而使GUI在它们运行中可以作出响应。\n对于耗时任务，可缓存线程池是个不错的选择。\n\n9.3.1 取消\n最简单的方法是使用Future，他就是设计用来管理可取消任务的。\n如果你调用Future的cancel。并设置mayInterruptIfRunning参数为true，Future的实现可以中断一个执行运行中的任务的线程。如果你编写的任务能处理中断，那么被取消后可以提前返回。\n\n    public class ListenerExamples &#123;\n        private static ExecutorService exec = Executors.newCachedThreadPool();\n\n        private final JButton colorButton = new JButton(&quot;Change color&quot;);\n        private final Random random = new Random();\n\n        private void backgroundRandom() &#123;\n            colorButton.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent e) &#123;\n                    colorButton.setBackground(new Color(random.nextInt()));\n                &#125;\n            &#125;);\n        &#125;\n\n\n        //将耗时任务绑定到可视化组件中\n        private final JButton computeButton = new JButton(&quot;Big computation&quot;);\n\n        private void longRunningTask() &#123;\n            computeButton.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent e) &#123;\n                    exec.execute(new Runnable() &#123;\n                        public void run() &#123;\n                            /* Do big computation */\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n        &#125;\n\n\n        private final JButton button = new JButton(&quot;Do&quot;);\n        private final JLabel label = new JLabel(&quot;idle&quot;);\n\n        //提供用户反馈的耗时任务\n        private void longRunningTaskWithFeedback() &#123;\n            button.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent e) &#123;\n                    button.setEnabled(false);\n                    label.setText(&quot;busy&quot;);\n                    exec.execute(new Runnable() &#123;\n                        public void run() &#123;\n                            try &#123;\n                                /* Do big computation */\n                            &#125; finally &#123;\n                                GuiExecutor.instance().execute(new Runnable() &#123;\n                                    public void run() &#123;\n                                        button.setEnabled(true);\n                                        label.setText(&quot;idle&quot;);\n                                    &#125;\n                                &#125;);\n                            &#125;\n                        &#125;\n                    &#125;);\n                &#125;\n            &#125;);\n        &#125;\n\n        private final JButton startButton = new JButton(&quot;Start&quot;);\n        private final JButton cancelButton = new JButton(&quot;Cancel&quot;);\n        private Future&lt;?&gt; runningTask = null; // thread-confined\n\n        //取消耗时任务，轮询线程的中断状态，并且在中断时提前返回\n        private void taskWithCancellation() &#123;\n            startButton.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent e) &#123;\n                    if (runningTask != null) &#123;\n                        runningTask = exec.submit(new Runnable() &#123;\n                            public void run() &#123;\n                                while (moreWork()) &#123;\n                                    if (Thread.currentThread().isInterrupted()) &#123;\n                                        cleanUpPartialWork();\n                                        break;\n                                    &#125;\n                                    doSomeWork();\n                                &#125;\n                            &#125;\n\n                            private boolean moreWork() &#123;\n                                return false;\n                            &#125;\n\n                            private void cleanUpPartialWork() &#123;\n                            &#125;\n\n                            private void doSomeWork() &#123;\n                            &#125;\n\n                        &#125;);\n                    &#125;\n                    ;\n                &#125;\n            &#125;);\n\n            cancelButton.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent event) &#123;\n                    if (runningTask != null)\n                        runningTask.cancel(true);\n                &#125;\n            &#125;);\n        &#125;\n\n\n        private void runInBackground(final Runnable task) &#123;\n            startButton.addActionListener(new ActionListener() &#123;\n                public void actionPerformed(ActionEvent e) &#123;\n                    class CancelListener implements ActionListener &#123;\n                        BackgroundTask&lt;?&gt; task;\n                        public void actionPerformed(ActionEvent event) &#123;\n                            if (task != null)\n                                task.cancel(true);\n                        &#125;\n                    &#125;\n                    final CancelListener listener = new CancelListener();\n                    listener.task = new BackgroundTask&lt;Void&gt;() &#123;\n                        public Void compute() &#123;\n                            while (moreWork() &amp;&amp; !isCancelled())\n                                doSomeWork();\n                            return null;\n                        &#125;\n\n                        private boolean moreWork() &#123;\n                            return false;\n                        &#125;\n\n                        private void doSomeWork() &#123;\n                        &#125;\n\n                        public void onCompletion(boolean cancelled, String s, Throwable exception) &#123;\n                            cancelButton.removeActionListener(listener);\n                            label.setText(&quot;done&quot;);\n                        &#125;\n                    &#125;;\n                    cancelButton.addActionListener(listener);\n                    exec.execute(task);\n                &#125;\n            &#125;);\n        &#125;\n    &#125;\n9.3.2 进度和完成标识\n使用Future表现一个耗时任务，可以极大的简化取消的实现。类似的，FutureTask中也有一个done钩子函数，可以方便任务完成后的通知。后台Callable完成后，会调用done。通过由done触发一个事件线程中已经完成的任务，我们能够构建BackgroundTask类，它提供一个可在事件线程中调用的onCompletion钩子函数。\n  //支持取消、完成和进度通知的后台任务类\n  public abstract class BackgroundTask &lt;V&gt; implements Runnable, Future&lt;V&gt; &#123;\n      private final FutureTask&lt;V&gt; computation = new Computation();\n\n      private class Computation extends FutureTask&lt;V&gt; &#123;\n          public Computation() &#123;\n              super(new Callable&lt;V&gt;() &#123;\n                  public V call() throws Exception &#123;\n                      return BackgroundTask.this.compute();\n                  &#125;\n              &#125;);\n          &#125;\n\n          protected final void done() &#123;\n              GuiExecutor.instance().execute(new Runnable() &#123;\n                  public void run() &#123;\n                      V value = null;\n                      Throwable thrown = null;\n                      boolean cancelled = false;\n                      try &#123;\n                          value = get();\n                      &#125; catch (ExecutionException e) &#123;\n                          thrown = e.getCause();\n                      &#125; catch (CancellationException e) &#123;\n                          cancelled = true;\n                      &#125; catch (InterruptedException consumed) &#123;\n                      &#125; finally &#123;\n                          onCompletion(value, thrown, cancelled);\n                      &#125;\n                  &#125;;\n              &#125;);\n          &#125;\n      &#125;\n\n      protected void setProgress(final int current, final int max) &#123;\n          GuiExecutor.instance().execute(new Runnable() &#123;\n              public void run() &#123;\n                  onProgress(current, max);\n              &#125;\n          &#125;);\n      &#125;\n\n      // Called in the background thread\n      protected abstract V compute() throws Exception;\n\n      // Called in the event thread\n      protected void onCompletion(V result, Throwable exception,\n                                  boolean cancelled) &#123;\n      &#125;\n\n      protected void onProgress(int current, int max) &#123;\n      &#125;\n\n      // Other Future methods just forwarded to computation\n      public boolean cancel(boolean mayInterruptIfRunning) &#123;\n          return computation.cancel(mayInterruptIfRunning);\n      &#125;\n\n      public V get() throws InterruptedException, ExecutionException &#123;\n          return computation.get();\n      &#125;\n\n      public V get(long timeout, TimeUnit unit)\n              throws InterruptedException,\n              ExecutionException,\n              TimeoutException &#123;\n          return computation.get(timeout, unit);\n      &#125;\n\n      public boolean isCancelled() &#123;\n          return computation.isCancelled();\n      &#125;\n\n      public boolean isDone() &#123;\n          return computation.isDone();\n      &#125;\n\n      public void run() &#123;\n          computation.run();\n      &#125;\n  &#125;\n\n\n9.3.3 SwingWorker\nSwingWorker类提供取消、完成的通知，以及进度指示。\n\n9.4 共享数据模型\nSwing的表现对象(包括TableModel、TreeModel这些数据模型)是被限制在事件线程中的。\n举个例子，你可以使用树控件来显示远程文件系统的内容。在你显示控件之前，并不用枚举完整的文件系统——那样做会花费大量的时间和内存。树应该在展开结点时惰性组装起来。即使只枚举远程卷上的单一目录，也会花费很长的时间，所以你可以考虑在后台任务中执行枚举。后台任务完成后，你还必须设法把数据送入树中。可以通过使用线程安全的树模型来实现：让invokeLater安排一个任务，把数据从后台任务中“推入”事件线程；或者也可以让事件线程池轮询查看数据是否可用。\n\n9.4.1 线程安全的数据模型\n只要阻塞不过度影响响应性，多线程操作数据的问题就可以通过线程安全的数据模型来解决。如果数据模型支持精细的并发，事件线程和后台线程就能够共享它，而且不存在响应性的问题。\n\n9.4.2 分拆数据模型\n应用程序的数据模型既包含表现域，又包含应用域，我们称这种应用程序是**分拆模型(split-model)的设计\n如果一个数据模型必须被多个线程共享，而且实现一个线程安全模型的尝试却由于阻塞、一致性或者复杂度等原因而失败，这时就可以考虑运用分拆模型设计。\n\n\n\n9.5 其他形式的单线程子系统\n一些原生库要求所有对库的访问，甚至System.loadLibrary加载库时，必须在同一个线程中运行。借用GUI框架的方法，可以简单的为访问原生库创建一个专门的线程或者一个单线程化的Executor，然后提供一个代理对象拦截所有对线程限制对象的调用，把拦截的调用当做任务提交给前面创建的线程中。Future和newSingleThreadExecutor的组合可以简化这项工作；代理方法调用submit提交任务，然后立即调用Future.get等待结果。\n\nsummary\nGUI框架几乎都是作为单线程化子系统实现的，所有与表现相关的代码都作为任务在一个事件线程中运行。\n因为只有唯一一个线程，耗时任务会损害响应性，所以它们应该在后台线程中运行。\n像SwingWorker以及本章中构建BackgroundTask这些助手类，提供了取消、进度指示、完成指示的支持、无论是GUI组件还是非GUI组件，都能借助它们简化耗时任务的开发。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","GUI应用程序"]},{"title":"08.应用线程池","url":"https://java4u.cn/Java并发编程/Java并发编程/08-应用线程池/","content":"\n本章关注在配置和调整线程池时用的高级选项，讲述了使用任务执行框架的过程中需要注意的危险，还提供了一些使用Executor更高级的例子。\n\n8.1 任务与执行策略间的隐性耦合\n前面我们声称Executor框架可以将任务的提交与执行策略解耦，其实有点言过其实了。尽管Executor框架为制定和修改执行策略提供了相当大的灵活性，但是并非所有的任务都能适合所有的执行策略。有些类型的任务需要明确地指定一个执行策略，包括：\n依赖性任务。多数运行良好的任务是独立的:它们不依赖于时序，或者其他任务的结果与边界效应。当线程池中运行的任务都是独立的时候，你就可以随意地改变池的长度和配置，这样做不会影响到性能以外的任何事情。另一方面，如果你提交给线程池的任务要依赖于其他的任务，你就隐式地给执行策略带来了约束，这样你必须仔细地管理执行策略以避免活跃度的问题。\n采用线程限制的任务。单线程化的Executor相比于任意的线程池，可以对同步作出更强的承诺。它可以保证任务不会并发地执行，允许你放宽任务代码对线程安全的要求。可以把对象限制带任务线程中，这使得任务线程所执行的任务在访问该对象时，不需要同步，即使那些资源不是线程安全的亦如此。这会在任务与执行策略之间形成隐式的耦合——任务需要它们的Executor来确保单线程化。如果你将Executor从一个单线程化改为一个线程池的话，就会失去线程安全性。\n对响应时间敏感的任务。比如，GUI。\n使用ThreadLocal的任务。ThreadLocal让每一个线程可以保留一份变量的私有“版本”。但是，只要条件允许，Executor就会随意重用这些线程。标准的Executor实现是：在需求不高时回收空闲的线程，在需求增加时添加新的线程，如果任务抛出了异常，就会用一个全新的工作者线程取代出错的那个。只有当线程本地(thread-local)值的生命周期被限制在当前的任务中时，在池的某线程中使用ThreadLocal才有意义；在线程池中，不应该用ThreadLocal传递任务间的数值。\n\n\n\n\n当任务是同类的、独立的时候，线程池才有最佳的工作表现。如果将耗时的与短期的任务混在一起，除非线程池很大，否则会有“塞车”的风险；如果提交的任务要依赖于其他的任务，除非池是无限的，否则有产生死锁的风险。幸运的是，那些典型的基于网络的服务器应用程序——Web服务器、邮件服务器、文件服务器——它们的请求通常都是同类的、独立的。\n\n\n一些任务具有这样的特征：需要或者排斥某种特定的执行策略。对其他任务具有依赖性的任务，就会对线程池的要求足够大，来保证它所依赖的任务不必排队或者不被拒绝；采用线程限制的任务需要顺序执行。把这些需求都写入文档，这样将来的维护者就不会使用一个与原先相悖的执行策略，而破坏安全性或活跃度了。\n\n8.1.1 线程饥饿死锁\n在线程池中，如果一个任务依赖于其他任务的执行，就可能产生死锁。对于一个单线程化的Executor，一个任务将另一个任务提交到相同的Executor中，并等待新提交的任务的结果，这总会引发死锁。第二个任务滞留在工作队列总，直到第一个任务完成，但第一个任务不会完成，因为它在等待第二个任务的完成。\n在一个大的线程池中，如果所有线程执行的任务都阻塞在线程池中，等待着仍然处于同一工作队列中的其他任务。那么会有同样的问题，即**线程饥饿死锁(thread starvation deadlock)**，满足以下叙述就会发生：\n\n\n只要池任务开始了无限期的阻塞，其目的是等待一些资源或条件，此时只有另一个池任务的活动才能使那些条件成立，比如等待返回值或者另一个任务的边界效应。除非你能保证这个池足够大，否则会发生线程饥饿死锁。\n\n\n以下代码演示了线程饥饿死锁。ReaderPageTask向Executor提交了两个附加的任务，来完成获取页眉、页脚、渲染页面、等待获取页眉和页脚任务的结果，以及将页眉、页面主体和页脚结合到最终页面中这一系列的工作。作为一个单线程化的Executor，ThreadDeadlock会经常死锁。类似的，如果池不够足够大，所有任务在它们自身进行协调时会遇到关卡(barrier)，这也会引起线程饥饿死锁。\n  //在单线程化的Executor中死锁的任务**(不要这样做)**\n  public class ThreadDeadlock &#123;\n      ExecutorService exec = Executors.newSingleThreadExecutor();\n\n      public class RenderPageTask implements Callable&lt;String&gt; &#123;\n          public String call() throws Exception &#123;\n              Future&lt;String&gt; header, footer;\n              header = exec.submit(new LoadFileTask(&quot;header.html&quot;));\n              footer = exec.submit(new LoadFileTask(&quot;footer.html&quot;));\n              String page = renderBody();\n              // Will deadlock -- task waiting for result of subtask\n              return header.get() + page + footer.get();\n          &#125;\n\n          private String renderBody() &#123;\n              // Here&#39;s where we would actually render the page\n              return &quot;&quot;;\n          &#125;\n      &#125;\n  &#125;\n\n\n\n无论何时，你提交了一个非独立的Executor任务，要明确出现线程饥饿死锁的可能性，并且，在代码或者配置文件以及其他可以配置Executor的地方，任何有关池的大小和配置约束都要写入文档。\n\n8.1.2 耗时操作\n如果任务由于过长的时间周期而阻塞，那么即使不可能出现死锁，线程池的响应性也会变得很差。耗时任务会造成线程池堵塞，还会拖长服务时间，即使小任务也不能幸免。耗时操作的数目会期望线程有一个稳定的数量，如果线程池的大小相对于这个数字来说太小，那么最后可能所有的线程都会处于运行耗时任务的状态中，从而就会影响响应性。\n有一项技术可以用来缓解耗时操作带来的影响，这就是限定任务等待资源的时间，而不是无限制的等下去。大多数阻塞方法，都同时有限时和非限时两个版本，比如Thread.join、BlockingQueue.put、CountDownLatch.await和Selector.select。如果等待超时，你可以把任务标识为失败，中止它或者把它重新放回队列，准备之后执行。\n\n8.2 定制线程池的大小\n线程池合理的长度取决于未来提交的任务类型和所部署系统的特征。\n一个线程池过大，那么线程对稀缺的CPU和内存资源的竞争，会导致内存的高使用量，还可能耗尽资源\n如果过小，由于存在很多可用的处理器资源，却未在工作，会对吞吐量造成损失。\n为了正确定制线程池的长度，需要理解计算环境，资源预算，和任务的自身特点。部署系统中按章了多少个CPU？多少内存？任务主要执行的是计算、I/O还是一些混合操作？它们是否需要像JDBC Connection这样的稀缺资源？如果你有不同类别的任务，它们拥有差别很大的行为，那么请考虑使用多个线程池，这样每个线程池可以根据不同任务的工作负载进行调节。\n对于计算密集型任务，一个有N个处理器的系统通常通过使用一个N + 1 个线程的线程池来获得最优的利用率(计算密集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个额外的线程，可以确保在这种情况下CPU周期不会中断工作)。\n给定下列定义：\nN_CPU = CPU的数量\nU = 目标CPU的使用率，0 &lt;= U &lt;= 1\nW / C = 等待时间与计算时间的比率\n\n\n为保持处理器达到期望的使用率，最优的池的大小等于：N_threads = N_CPU * U * (1 + W / C)\n你可以使用Runtime来获得CPU的数目 int N_CPUS = Runtime.getRuntime().availableProcessors();\n当然CPU周期不是唯一可以使用线程池管理的资源。其他可以约束资源池大小的资源包括：内存、文件句柄、套接字句柄和数据库连接等。计算这些类型资源池的大小约束非常简单：首先累加出每一个任务需要的这些资源的总量，然后除以可用的总量。所得的结果是池大小的上限。\n当任务需要池化的资源时，比如，数据库连接，那么线程池的长度和资源池的长度会相互影。如果每一个任务都需要一个数据库连接，那么连接池的大小就限制了线程池的有效大小；类似的，当线程池中的任务是连接池的唯一消费者时，那么线程池的大小反而又会限制连接池的有效大小。\n\n8.3 配置ThreadPoolExecutor\nThreadPoolExecutor 为一些Executor提供了基本的实现：newCachedThreadPool，newFixedThreadPool和newScheduledThreadPool这些工厂返回。\n\n如果默认不满足需求，可以通过构造函数实例化一个。以下代码为最通用的一个。\n  //ThreadPoolExecutor通用的构造函数\n  public ThreadPoolExecutor(int corePoolSize,\n                            int maximumPoolSize,\n                            long keepAliveTime,\n                            TimeUnit unit,\n                            BlockingQueue&lt;Runnable&gt; workQueue,\n                            ThreadFactory threadFactory,\n                            RejectedExecutionHandler handler)\n\n\n8.3.1 线程的创建与销毁\n核心池大小、最大池大小和存活时间共同管理着线程的创建与销毁。\n\n核心池大小是目标的大小；线程池的实现试图维护池的大小：即使没有任务执行，池的大小也等于核心池的大小，并且直到工作队列充满前，池都不会创建更多的线程。\n最大池大小是可同时活动的线程数的上限。\n如果一个线程已经闲置的时间超过了存活时间，它将成为一个被回收的候选者，如果当前的池的大小超过了核心池的大小，线程池会终止它。\n\n\n通过调节核心大小和存活时间，可以促进线程池归还空闲线程占有的资源，让这些资源可以用于更有用工作。(折中的办法：回收空闲线程也有额外延迟，而需求增加后，必须重新创建回收的线程)\n\nnewFixedThreadPool工厂为请求的池设置了核心池的大小和最大池的大小，而且池永远不会超时；\n\nnewCachedThreadPool将最大池的大小设置为Integer.MAX_VALUE，核心池的大小设置为零，超时设置一分钟，这样创建出来的是可无限扩大的线程池，会在需求量减少的情况下减少线程数量。\n\n\n8.3.2 管理队列任务\n有限线程池限制了可以并发执行的任务的数量。\n\n如果新请求到达的频率超过了线程池能够处理它们的速度，请求将在队列中等候有了线程池，这些多出来的请求会在一个Executor管理的Runnable队列中等待，而不是作为竞争CPU资源的线程队列。使用Runnable和一个清单结点来表现一个等待中的请求，的确比使用一个线程要便宜很多。但是如果客户抛给服务器的请求快过了服务器可以处理它们的速度，就仍然存在耗尽资源的风险。\n\n即使通常平均请求率都很稳定，也难免会突然激增。尽管队列有助于缓和瞬时的任务激增，但是如果任务持续快速地到来，你最终还是必须要遏制住请求达到率，以避免耗尽内存。即使没有耗尽内存，响应时间也会随着任务队列的增长而逐渐变糟。\n\nThreadPoolExecutor运行你提供一个BlockingQueue来持有等待执行的任务。任务排队有三种基本方法：\n\n无限队列\n有限队列\n同步移交(synchronous handoff)\n\n\nnewFixedThreadPool 和newSingleThreadPool默认使用的是一个无限的LinkedBlockingQueue。如果所有的工作者线程都处于忙碌状态，任务将会在队列中等候。如果任务持续地快速到达，超过了它们被执行的速度，队列也会无限制地增加。\n\n一个稳妥的资源管理策略是使用有限队列，比如ArrayBlockingQueue或者有限的LinkedBlockingQueue以及PriorityBlockingQueue。有界队列有助于避免资源耗尽的情况发生，但是它又引入了新的问题：当队列已满后，新的任务怎么办？有很多**饱和策略(saturation policie)**可以处理这个问题。对于一个有界队列，队列的长度与池的长度必须一起调节。一个大队列加一个小池，可以控制对内存和CPU的使用，还可以减少上下文切换，但是要接受潜在吞吐量约束的开销。\n\n对于庞大或者无限的池，你也可以使用SynchronousQueue，完全绕开队列，将任务直接从生产者移交给工作者线程。SynchronousQueue并不是一个真正的队列，而是一种管理直接在线程间移交信息的机制。为了把一个元素放入到SynchronousQueue中，必须有另外一个线程正在等待接受移交的任务。SynchronousQueue是一个有价值的选择。newCachedThreadPool工厂就使用了它。\n\n使用LinkedBlockingQueue或ArrayBlockingQueue这种FIFO的队列，会造成任务以它们到达的顺序开始执行。如果想进一步控制任务执行顺序，你还可以使用PriorityBlockingQueue，他通过优先级安排任务。自然顺序或者Comparator都可以定义优先级。\n\n\n\nnewCachedThreadPool工厂提供了比定长的线程池更好的队列等候性能，它是Executor的一个很好的默认选择。出于资源管理的目的，当你需要限制当前任务的数量，一个定长的线程池就是很好的选择。就像一个接受网络客户端请求的服务器应用程序，如果不进行限制，就会很容易因为过载而遭受攻击。\n\n\n只有当任务彼此独立时，才能使有限线程池或者有限工作队列的使用是合理的。倘若任务之间相互依赖，有限的线程池或队列就可能引起线程饥饿死锁；使用一个无限的池配置可以避免这类问题，就像newCachedThreadPool所做的。\n\n8.3.3 饱和策略\n当一个有限队列充满后，饱和策略开始起作用。ThreadPoolExecutor的饱和策略可以通过调用setRejectedExecutionHandler来修改(如果任务提交到了一个已经被关闭的Executor时，也会用到饱和策略)。JDK提供了几种不同的RejectedExecutionHandler实现，每一个都实现了不同的饱和策略：AbortPolicy、CallerRunsPolicy、DiscardPolicy和DiscardOldestPolicy\n\n默认的“中止”(abort)策略会引起execute抛出未检查的RejectedExecutionException；调用者可以捕获这个异常，然后编写能满足自己需求的处理代码。\n当最新提交任务不能进入队列等待执行时，“遗弃(discart)”策略会默认放弃这个任务，该策略还会尝试去重新提交新任务。\n“调用者运行(caller-runs)”策略的实现形式，既不会丢弃哪个任务，也不会抛出任何异常。它会把一些任务推回到调用者那里，以此减缓新任务流。它不会在池线程中执行最新提交的任务，但是它会在一个调用了execute的线程中执行。\n\n\n现在修改WebServer的例子，让它使用有限队列和调用者运行策略。当所有的池线程都被占用，而且工作队列已充满后，下一个任务会在主线程中执行。主线程调用execute执行这个任务。因为这将会花费一些时间，所以主线程在一段时间内不能提交任何任务。同时这也给工作者线程时间来追赶进度。这期间主线程也不会调用accept，所以外来的请求不会出现在应用程序中，而会在TCP层的队列中等候。如果持续高负载的话，最终会由TCP层判断它的连接请求队列是否已经排满，如果排满就开始丢弃请求任务。当服务器过载时，它的负荷会逐渐的外移——从池线程到工作队列到应用程序再到TCP层，最终转嫁到用户头上——这使得服务器在高负载下可以平缓的劣化。\n\nExecutor创建时可以同时选择饱和策略，并对执行策略进行其他改变。以下代码阐释了如何创建一个定长的线程池，它使用“调用者运行”饱和策略\n  //创建一个可变长的线程池，使用受限队列和调用者运行饱和策略\n  ThreadPoolExecutor executor = new ThreadPoolExecutor(\n              N_THREADS,\n              N_THREADS,\n              0L,\n              TimeUnit.MILLISECONDS,\n              new LinkedBlockingQueue&lt;Runnable&gt;(CAPACITY)\n              );\n  executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());\n\n当工作队列充满后，并没有预置的饱和策略来阻塞execute，但是使用Semaphore可以实现这个效果。Semaphore会限制任务注入率(injection rate)、以下代码演示了这一点。这种方法使用一个非受限队列，设置Semaphore的限制范围等于在池的大小上加上你希望允许的可以排队的任务数量，以为Semaphore限制的是当前执行的任务数和等待执行的任务数。\n  //使用Semaphore来遏制任务的提交\n  public class BoundedExecutor &#123;\n      private final Executor exec;\n      private final Semaphore semaphore;\n\n      public BoundedExecutor(Executor exec, int bound) &#123;\n          this.exec = exec;\n          this.semaphore = new Semaphore(bound);\n      &#125;\n\n      public void submitTask(final Runnable command)\n              throws InterruptedException &#123;\n          semaphore.acquire();\n          try &#123;\n              exec.execute(new Runnable() &#123;\n                  public void run() &#123;\n                      try &#123;\n                          command.run();\n                      &#125; finally &#123;\n                          semaphore.release();\n                      &#125;\n                  &#125;\n              &#125;);\n          &#125; catch (RejectedExecutionException e) &#123;\n              semaphore.release();\n          &#125;\n      &#125;\n  &#125;\n\n\n8.3.4 线程工厂\n无论何时，线程池需要创建一个线程，都要通过一个线程工厂来完成。默认的线程工厂创建一个新的、非后台(nondaemon)的线程，并没有特殊的配置。ThreadFactory只有唯一的方法：newThread，它会在线程池需要创建一个新线程时调用。\n  public interface ThreadFactory&#123;\n      Thread newThread(Runnable r);\n  &#125;\n\n以下代码演示了一个自定义的线程工厂。他实例化一个新的MyAPPThread，并且向构造函数中传递池的名称，这样可以在线程转储和错误信息中分辨出线程来自哪个池。MyAPPThread也可以用于应用程序的其他地方，这样所有的线程都能利用它的这一可调试特性\n  //定制的线程工厂\n  public class MyThreadFactory implements ThreadFactory &#123;\n      private final String poolName;\n\n      public MyThreadFactory(String poolName) &#123;\n          this.poolName = poolName;\n      &#125;\n\n      public Thread newThread(Runnable runnable) &#123;\n          return new MyAppThread(runnable, poolName);\n      &#125;\n  &#125;\n\n以下代码，它让你可以给线程提供名字，设置自定义UncaughtExceptionHandler，以此向Logger中写入信息，还能够维护统计信息，记录已经创建与销毁的线程数，最后可以选择线程在创建或终止时，把调试消息写入日志。\n  //子定义的线程基类\n  public class MyAppThread extends Thread &#123;\n      public static final String DEFAULT_NAME = &quot;MyAppThread&quot;;\n      private static volatile boolean debugLifecycle = false;\n      private static final AtomicInteger created = new AtomicInteger();\n      private static final AtomicInteger alive = new AtomicInteger();\n      private static final Logger log = Logger.getAnonymousLogger();\n\n      public MyAppThread(Runnable r) &#123;\n          this(r, DEFAULT_NAME);\n      &#125;\n\n      public MyAppThread(Runnable runnable, String name) &#123;\n          super(runnable, name + &quot;-&quot; + created.incrementAndGet());\n          setUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123;\n              public void uncaughtException(Thread t,\n                                            Throwable e) &#123;\n                  log.log(Level.SEVERE,\n                          &quot;UNCAUGHT in thread &quot; + t.getName(), e);\n              &#125;\n          &#125;);\n      &#125;\n\n      public void run() &#123;\n          // Copy debug flag to ensure consistent value throughout.\n          boolean debug = debugLifecycle;\n          if (debug) log.log(Level.FINE, &quot;Created &quot; + getName());\n          try &#123;\n              alive.incrementAndGet();\n              super.run();\n          &#125; finally &#123;\n              alive.decrementAndGet();\n              if (debug) log.log(Level.FINE, &quot;Exiting &quot; + getName());\n          &#125;\n      &#125;\n\n      public static int getThreadsCreated() &#123;\n          return created.get();\n      &#125;\n\n      public static int getThreadsAlive() &#123;\n          return alive.get();\n      &#125;\n\n      public static boolean getDebug() &#123;\n          return debugLifecycle;\n      &#125;\n\n      public static void setDebug(boolean b) &#123;\n          debugLifecycle = b;\n      &#125;\n  &#125;\n\n\n8.3.5 构造后再定制ThreadPoolExecutor\n创建后通过setters进行修改。\n如果将ExecutorService暴露给不信任的代码，不希望它会被修改，可以用一个unconfigurableExecutorService包装它。\n\n8.4 扩展ThreadPoolExecutor\nThreadPoolExecutor可扩展，它提供了几个钩子让子类去覆写——beforeExecute、afterExecute和terminated——这些可以用来扩展ThreadPoolExecutor行为。\n执行任务的线程会调用钩子函数beforeExecute和afterExecute，用它们添加日志。时序、监视器或统计信息收集的功能。\n无论任务是正常从run中返回，还是抛出一个异常，afterExecute都会被调用(EError不会)。\n如果beforeExecute抛出了一个RuntimeException，任务将不被执行，afterExecute也不会被调用。\n\n\nterminated钩子会在线程池完成关闭动作后调用，也就是当所有任务都已经完成并且所有工作者线程也已经关闭后，会执行terminated。它可以用来释放Executor在生命周期里分配到的资源，还可以发出通知、记录日志或者完成统计信息。\n\n8.4.1 示例：给线程池加入统计信息\n以下代码的TimingThreadPool显示了一个定制的线程池，它通过使用beforeExecute、afterExecute和terminated，加入了日志和统计收集功能。为了监控任务的运行时，beforeExecute必须记录开始时间并把它存储到一个afterExecute可以找到的地方。因为钩子函数是在执行任务的线程中被调用，因此beforeExecute可以把值存入到一个ThreadLocal中，就可以让afterExecute获得那个值。TimingThreadPool使用了一对AtomicLong，分别用于追踪已处理的任务数和处理时间的总和，最后使用terminated钩子将平均任务时间的日志消息打印出来。\n  //扩展线程池以提供日志和计时功能\n  public class TimingThreadPool extends ThreadPoolExecutor &#123;\n\n      public TimingThreadPool() &#123;\n          super(1, 1, 0L, TimeUnit.SECONDS, null);\n      &#125;\n\n      private final ThreadLocal&lt;Long&gt; startTime = new ThreadLocal&lt;Long&gt;();\n      private final Logger log = Logger.getLogger(&quot;TimingThreadPool&quot;);\n      private final AtomicLong numTasks = new AtomicLong();\n      private final AtomicLong totalTime = new AtomicLong();\n\n      protected void beforeExecute(Thread t, Runnable r) &#123;\n          super.beforeExecute(t, r);\n          log.fine(String.format(&quot;Thread %s: start %s&quot;, t, r));\n          startTime.set(System.nanoTime());\n      &#125;\n\n      protected void afterExecute(Runnable r, Throwable t) &#123;\n          try &#123;\n              long endTime = System.nanoTime();\n              long taskTime = endTime - startTime.get();\n              numTasks.incrementAndGet();\n              totalTime.addAndGet(taskTime);\n              log.fine(String.format(&quot;Thread %s: end %s, time=%dns&quot;,\n                      t, r, taskTime));\n          &#125; finally &#123;\n              super.afterExecute(r, t);\n          &#125;\n      &#125;\n\n      protected void terminated() &#123;\n          try &#123;\n              log.info(String.format(&quot;Terminated: avg time=%dns&quot;,\n                      totalTime.get() / numTasks.get()));\n          &#125; finally &#123;\n              super.terminated();\n          &#125;\n      &#125;\n  &#125;\n\n\n8.5 并归递归算法\n如果一个循环的每次迭代都是独立的，并且我们不必等待所有的迭代都完成后再一起处理，那么我们可以使用Executor把一个顺序的循环转化为并行的循环，如下边的processSequentially和processInParallel\n  //把顺序执行转换为并行执行\n  void processSequentially(List&lt;Element&gt; elements) &#123;\n      for (Element e : elements)\n          process(e);\n  &#125;\n\n  void processInParallel(Executor exec, List&lt;Element&gt; elements) &#123;\n      for (final Element e : elements)\n          exec.execute(new Runnable() &#123;\n              public void run() &#123;\n                  process(e);\n              &#125;\n          &#125;);\n  &#125;\n\n调用processInParallel会比调用processSequentially更快地得到返回，因为只要所有的下载任务都进入了Executor的队列，processInParallel就会立刻返回，而不用等到这些任务全部完成。如果你需要提交一个任务集并等待它们完成，那么可以使用ExecutorService.invokeAll；当所有结果都可用后，你可以使用CompletionService来获取结果。\n\n\n\n每个迭代彼此独立，并且完成循环体中每个迭代的工作，意义都足够重大，足以弥补管理一个新任务的开销时，这个顺序循环是适合并行化的。\n\n\n循环并行化同样可以应用于一些递归设计中；通常递归算法的内部会存在顺序循环，这些循环可以以上代码的方式进行并行化。一种简单的情况是，每个迭代都不需要来自于它所调用的迭代的结果。举个例子，以下代码sequentialRecursive以深度优先遍历一棵树，并在每个结点上执行计算，把结果放入一个容器中。修改后的版本parallelRecursive，同样进行深度优先遍历，但是它并不是在访问结点时进行计算，而是为每个结点都提交一个任务来完成计算。\n      //把顺序递归转换为并行递归\n      public &lt;T&gt; void sequentialRecursive(List&lt;Node&lt;T&gt;&gt; nodes,\n                                          Collection&lt;T&gt; results) &#123;\n          for (Node&lt;T&gt; n : nodes) &#123;\n              results.add(n.compute());\n              sequentialRecursive(n.getChildren(), results);\n          &#125;\n      &#125;\n\n      public &lt;T&gt; void parallelRecursive(final Executor exec,\n                                        List&lt;Node&lt;T&gt;&gt; nodes,\n                                        final Collection&lt;T&gt; results) &#123;\n          for (final Node&lt;T&gt; n : nodes) &#123;\n              exec.execute(new Runnable() &#123;\n                  public void run() &#123;\n                      results.add(n.compute());\n                  &#125;\n              &#125;);\n              parallelRecursive(exec, n.getChildren(), results);\n          &#125;\n      &#125;\n\n当parallelRecursive返回的时候，树上的每个结点都已经被访问过了(不过遍历的过程仍然是顺序的：只有对compute的调用才是并行执行的)，每个节点的计算任务已经进入Executor的工作队列。parallelRecursive的调用者可以创建一个Executor用来遍历，并使用shutdown和awaitTermination，等待所有的结果。就像以下代码：\n  //等待并行运算的结果\n  public &lt;T&gt; Collection&lt;T&gt; getParallelResults(List&lt;Node&lt;T&gt;&gt; nodes)\n          throws InterruptedException &#123;\n      ExecutorService exec = Executors.newCachedThreadPool();\n      Queue&lt;T&gt; resultQueue = new ConcurrentLinkedQueue&lt;T&gt;();\n      parallelRecursive(exec, nodes, resultQueue);\n      exec.shutdown();\n      exec.awaitTermination(Long.MAX_VALUE, TimeUnit.SECONDS);\n      return resultQueue;\n  &#125;    \n\n\n8.5.1 示例：谜题框架\n这项技术的一种有趣的应用是解决谜题，它所解决的谜题包括从一些初始状态寻找到达目标状态的转换序列，比如类似于“搬箱子”、“Hi-Q”、“Instant Insanity”和其他的棋牌谜题。\n\n我们这样定义一个谜题，它包含了一个初始位置，一个目标位置，为了确定起点与目标之间的有效移动，还包含一个规则集。规则集有两部分：计算一个清单，包含始于给定位置的合法移动；计算移动到某位置的可能结果。以下代码演示了这个谜题的抽象；类型参数P和M代表了位置和移动的类。根据这个接口，我们可以写一个简单的顺序执行的解决者，它会在谜题空间中查找，直到找到一个解答，或者找遍了整个空间而没发现答案。\n  //类似于“搬箱子”谜题的抽象\n  public interface Puzzle &lt;P, M&gt; &#123;\n      P initialPosition();\n\n      boolean isGoal(P position);\n\n      Set&lt;M&gt; legalMoves(P position);\n\n      P move(P position, M move);\n  &#125;\n\n以下代码的PuzzleNode代表一个位置，经过一系列的移动后到达该位置。它有一个move引用，move创建了当前位置和前一个PuzzleNode。我们沿着PuzzleNode链接逐步后退，可以重新构建出到达当前位置的移动序列。\n  //谜题解决者框架的链结点\n  public class PuzzleNode &lt;P, M&gt; &#123;\n      final P pos;\n      final M move;\n      final PuzzleNode&lt;P, M&gt; prev;\n\n      public PuzzleNode(P pos, M move, PuzzleNode&lt;P, M&gt; prev) &#123;\n          this.pos = pos;\n          this.move = move;\n          this.prev = prev;\n      &#125;\n\n      List&lt;M&gt; asMoveList() &#123;\n          List&lt;M&gt; solution = new LinkedList&lt;M&gt;();\n          for (PuzzleNode&lt;P, M&gt; n = this; n.move != null; n = n.prev)\n              solution.add(0, n.move);\n          return solution;\n      &#125;\n  &#125;\n\n以下代码的SequentialPuzzleSolver演示了一个谜题框架的顺序化解决器，它在谜题空间中执行一个深度优先搜索，并会在发现一个解答(不必是最短的方案)后终止。\n  //顺序化的谜题解决者\n  public class SequentialPuzzleSolver &lt;P, M&gt; &#123;\n      private final Puzzle&lt;P, M&gt; puzzle;\n      private final Set&lt;P&gt; seen = new HashSet&lt;P&gt;();\n\n      public SequentialPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) &#123;\n          this.puzzle = puzzle;\n      &#125;\n\n      public List&lt;M&gt; solve() &#123;\n          P pos = puzzle.initialPosition();\n          return search(new PuzzleNode&lt;P, M&gt;(pos, null, null));\n      &#125;\n\n      private List&lt;M&gt; search(PuzzleNode&lt;P, M&gt; node) &#123;\n          if (!seen.contains(node.pos)) &#123;\n              seen.add(node.pos);\n              if (puzzle.isGoal(node.pos))\n                  return node.asMoveList();\n              for (M move : puzzle.legalMoves(node.pos)) &#123;\n                  P pos = puzzle.move(node.pos, move);\n                  PuzzleNode&lt;P, M&gt; child = new PuzzleNode&lt;P, M&gt;(pos, move, node);\n                  List&lt;M&gt; result = search(child);\n                  if (result != null)\n                      return result;\n              &#125;\n          &#125;\n          return null;\n      &#125;\n  &#125;\n\n改写前一个解决者并加强一些并发性，我们就可以同时判断目标条件和计算下一步移动。因为计算一次移动的过程，几乎和计算其他移动的过程是彼此独立的。如果有多个处理器可用，就能减少寻找方案所花费的时间。\n\n以下代码的ConcurrentPuzzleSolver使用了内部类SolverTask，SolverTask同时扩展PuzzleNode并实现了Runnable。大多数工作是在run中完成的：首先计算下一步可能的位置集，从中除去已经到达的位置，然后判断是否已经成功完成，最后要把尚未搜索的位置提交给Executor。\n  //并发版的谜题解决者\n  public class ConcurrentPuzzleSolver &lt;P, M&gt; &#123;\n      private final Puzzle&lt;P, M&gt; puzzle;\n      private final ExecutorService exec;\n      private final ConcurrentMap&lt;P, Boolean&gt; seen;\n      protected final ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt; solution = new ValueLatch&lt;PuzzleNode&lt;P, M&gt;&gt;();\n\n      public ConcurrentPuzzleSolver(Puzzle&lt;P, M&gt; puzzle) &#123;\n          this.puzzle = puzzle;\n          this.exec = initThreadPool();\n          this.seen = new ConcurrentHashMap&lt;P, Boolean&gt;();\n          if (exec instanceof ThreadPoolExecutor) &#123;\n              ThreadPoolExecutor tpe = (ThreadPoolExecutor) exec;\n              tpe.setRejectedExecutionHandler(new ThreadPoolExecutor.DiscardPolicy());\n          &#125;\n      &#125;\n\n      private ExecutorService initThreadPool() &#123;\n          return Executors.newCachedThreadPool();\n      &#125;\n\n      public List&lt;M&gt; solve() throws InterruptedException &#123;\n          try &#123;\n              P p = puzzle.initialPosition();\n              exec.execute(newTask(p, null, null));\n              // block until solution found\n              PuzzleNode&lt;P, M&gt; solnPuzzleNode = solution.getValue();\n              return (solnPuzzleNode == null) ? null : solnPuzzleNode.asMoveList();\n          &#125; finally &#123;\n              exec.shutdown();\n          &#125;\n      &#125;\n\n      protected Runnable newTask(P p, M m, PuzzleNode&lt;P, M&gt; n) &#123;\n          return new SolverTask(p, m, n);\n      &#125;\n\n      protected class SolverTask extends PuzzleNode&lt;P, M&gt; implements Runnable &#123;\n          SolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) &#123;\n              super(pos, move, prev);\n          &#125;\n\n          public void run() &#123;\n              if (solution.isSet()\n                      || seen.putIfAbsent(pos, true) != null)\n                  return; // already solved or seen this position\n              if (puzzle.isGoal(pos))\n                  solution.setValue(this);\n              else\n                  for (M m : puzzle.legalMoves(pos))\n                      exec.execute(newTask(puzzle.move(pos, m), m, this));\n          &#125;\n      &#125;\n  &#125;\n\n为了避免无限循环，顺序版本的解决者维护了一个保存先前已搜索到的位置的Set；ConcurrentPuzzleSolver使用ConcurrentHashMap也是出于同样的目的。这种做法提供了线程安全性，还避免了依据条件更新共享容器时固有的竞争条件，因为ConcurrentHashMap使用了putIfAbsent，可以原子化地添加一个位置，当且仅当这个位置先前是不存在的。ConcurrentPuzzleSolver使用内部线程池的工作队列保留搜索的状态，而不是调用栈。\n\n并发的方法还用一种限制形式换取了另一个可能更加适合这个问题域的有利条件。顺序版本的程序执行的深度优先的搜索，所以搜索的能力是受可用栈的大小限制的。并发版本的程序执行的广度优先的搜索，因此不会受到栈大小的影响(但是仍然可用耗尽内存：待搜索的或已搜索的位置集超出了可用的内存)。\n\n为了发现一个解法后可以停止搜索行为，我们需要一种方式来检查是否有哪个线程已经找到了一个方案。如果我们想接受第一个被发现的方案，我们只有在还没发现任何解法时才去更新方案。这些条件描述了一种闭锁的行为，具体的说，是一种可携带结果的闭锁。以下代码的ValueLatch使用CountDownLatch提供了我们需要的闭锁行为，并且使用锁保证了方案仅被设置一次。\n  //ConcurrentPuzzleSolver使用可携带结果的闭锁\n  @ThreadSafe\n  public class ValueLatch &lt;T&gt; &#123;\n      @GuardedBy(&quot;this&quot;) private T value = null;\n      private final CountDownLatch done = new CountDownLatch(1);\n\n      public boolean isSet() &#123;\n          return (done.getCount() == 0);\n      &#125;\n\n      public synchronized void setValue(T newValue) &#123;\n          if (!isSet()) &#123;\n              value = newValue;\n              done.countDown();\n          &#125;\n      &#125;\n\n      public T getValue() throws InterruptedException &#123;\n          done.await();\n          synchronized (this) &#123;\n              return value;\n          &#125;\n      &#125;\n  &#125;\n\n每个任务首先会先向闭锁请求方案，如果方案已被发现，就停止。在找到一个方案之前，主线程需要等待；ValueLatch中的getValue会一直阻塞，直到有线程设置了value。ValueLatch为我们提供了方法来持有value，这样它只有在第一次调用时才进行设置。调用者能够检查value是否被设置，而且调用者可以阻塞，等候value被设置。第一次调用setValue，会更新方案，并且消耗CountDownLatch，从getValue中释放主解决器线程。\n\n第一个发现解法的线程还会关闭Executor，以拒绝接受新的任务。为了避免处理RejectedExecutionException，我们可以设置一个拒绝执行处理器，让它丢弃已提交的任务。于是，所有未完成的任务最终还会运行完成，然而任何后续的执行新任务的尝试都会默认为失败，允许终止Executor。\n\nConcurrentPuzzleSolver还不能很好的处理“不存在任何方案的”的情况。solvehi在getSolution的调用中永远等下去。一种可能的方法是：维护一个活动解决者任务的计数器，当计数器减到0时，就将将结果方案设置为null，代码如下：\n  //能感知任务不存在的解决者\n  public class PuzzleSolver &lt;P,M&gt; extends ConcurrentPuzzleSolver&lt;P, M&gt; &#123;\n      PuzzleSolver(Puzzle&lt;P, M&gt; puzzle) &#123;\n          super(puzzle);\n      &#125;\n\n      private final AtomicInteger taskCount = new AtomicInteger(0);\n\n      protected Runnable newTask(P p, M m, PuzzleNode&lt;P, M&gt; n) &#123;\n          return new CountingSolverTask(p, m, n);\n      &#125;\n\n      class CountingSolverTask extends SolverTask &#123;\n          CountingSolverTask(P pos, M move, PuzzleNode&lt;P, M&gt; prev) &#123;\n              super(pos, move, prev);\n              taskCount.incrementAndGet();\n          &#125;\n\n          public void run() &#123;\n              try &#123;\n                  super.run();\n              &#125; finally &#123;\n                  if (taskCount.decrementAndGet() == 0)\n                      solution.setValue(null);\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n发现一个解法所花费的时间，仍然可能比我们期望的要长；因此我们可以给解决器设置几种额外的中止条件。\n\n其中之一是时间限制；可以通过在ValueLatch中实现一个限时版本的getValue(它将会使用await的timed版本)，就能简单地做到这一点。如果getValue超时，程序会声明一个失败，并关闭Executor。\n另一种中断条件是与谜题相关的标准，比如只搜索某个确定的数量的位置。或者，我们也可以提供一个取消机制，让用户自己决定何时停止搜索。\n\n\n\nsummary\n对于并发执行的任务，Executor框架是强大且灵活的。\n它提供了大量可调节的选项，比如创建和关闭线程的策略，处理队列任务的策略，处理过剩任务的策略，并且提供了几个钩子函数用于扩展它的行为。\n一些类型的任务需要特定的执行策略，而一些调节参数组合在一起后可能会产生意外的结果\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","应用线程池"]},{"title":"07.取消和关闭","url":"https://java4u.cn/Java并发编程/Java并发编程/07-取消和关闭/","content":"\n启动任务和线程都很容易。大多数时候，我们通常允许它们在结束任务后自行停止。但是，有时候我们希望任务或线程自然结束之前就停止它们，可能因为用户取消了操作，或者应用程序需要快速关闭。\n要做到安全、快速、可靠的停止任务或线程并不容易。Java没有提供任何机制，来安全地强迫线程停止手头的工作。它提供中断——一个协作机制，使一个线程能够要求另一个线程停止当前的工作。\n这种协作方法是必须的，因为我们很少需要一个任务、线程或者服务立即停止，立即停止会导致共享的数据结构处于不一致的状态。任务和服务可以这样编码：当要求它们停止时，它们首先会清除当前进程中的工作，然后再终止。这提供了更好的灵活性，因为任务代码本身比发出取消请求的代码更明确应该清除什么。\n\n7.1 任务取消\n当外部代码能够在活动自然完成之前，把它更改为完成状态，那么这个活动被称为**可取消的(cancellable)**。我们可能会因为很多原因取消一个活动：\n\n用户请求的取消。用户点击程序界面上的“cancel”按钮，或者通过管理接口请求取消，比如JMX(Java Management Extensions)。\n限时活动。一个应用程序，需要在有限的时间内搜索问题空间，并且在规定的时间内选择最好的解决方案。如果计时器超时，正在搜索的任务会被取消。\n应用程序事件。一个应用程序对问题空间进行分解搜索，使不同的任务搜索问题空间中不同的区域。当一个任务发现了解决方案，所有其他仍在工作的搜索会被取消。\n错误。一个Web Crawler搜索几个相关页面，并把页面或概要数据存储到硬盘。当Crawler的任务遭遇错误(比如，磁盘空间已满)，那么所有的搜索任务都会被取消，不过很可能会记录它们当前的状态，这样售后可以重新启动。\n关闭。当一个程序或者服务关闭时，必须对正在处理的和等待处理的工作进行一些操作。一个优雅的关闭，可能允许当前的任务完成；在一个更加紧迫的关闭中，当前的任务就可能被取消了。\n\n\n在Java中，没有哪一种用来停止线程的方式是绝对安全的，因此没有哪一种方式优先用来停止任务。这里只有选择相互协作的机制，通过协作，使任务和代码遵循一个统一的协议，用来请求取消(cancellation)。\n\n在这些的协作机制中，有一种会设置“cancellation requested”标志，任务会定期查看；如果发现标志被设置过，任务就会提前结束。以下代码，PrimeGenerator的功能是列举素数，直到它被取消。\n  //使用volatile域保存取消状态\n  public class PrimeGenerator implements Runnable &#123;\n      private static ExecutorService exec = Executors.newCachedThreadPool();\n\n      @GuardedBy(&quot;this&quot;) private final List&lt;BigInteger&gt; primes\n              = new ArrayList&lt;BigInteger&gt;();\n      private volatile boolean cancelled;\n\n      public void run() &#123;\n          BigInteger p = BigInteger.ONE;\n          while (!cancelled) &#123;\n              p = p.nextProbablePrime();\n              synchronized (this) &#123;\n                  primes.add(p);\n              &#125;\n          &#125;\n      &#125;\n\n      public void cancel() &#123;\n          cancelled = true;\n      &#125;\n\n      public synchronized List&lt;BigInteger&gt; get() &#123;\n          return new ArrayList&lt;BigInteger&gt;(primes);\n      &#125;\n\n      static List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException &#123;\n          PrimeGenerator generator = new PrimeGenerator();\n          exec.execute(generator);\n          try &#123;\n              SECONDS.sleep(1);\n          &#125; finally &#123;\n              generator.cancel();\n          &#125;\n          return generator.get();\n      &#125;\n  &#125;\n\ncancel方法会设置cancelled标志，主循环会在搜索下一个素数之前，轮询检查这个标志。\n\n下列代码展示一个使用PrimeGenerator类的例子，让素数生成器运行一秒钟后就取消。生成器没有必要严格在一秒内停止，这时因为请求取消的时间和run循环的下一次检查之间可能存在延迟。cancel方法由finally块调用，来保证即使在调用sleep被中断的情况下，素数生成器也能被取消。如果cancel没有被调用，寻找素数的线程会永远运行下去，占用CPU的周期，使JVM不能正常退出。\n  //生成素数的程序运行一秒钟\n  @ThreadSafe\n  public class PrimeGenerator implements Runnable &#123;\n      private static ExecutorService exec = Executors.newCachedThreadPool();\n\n      @GuardedBy(&quot;this&quot;) private final List&lt;BigInteger&gt; primes\n              = new ArrayList&lt;BigInteger&gt;();\n      private volatile boolean cancelled;\n\n      public void run() &#123;\n          BigInteger p = BigInteger.ONE;\n          while (!cancelled) &#123;\n              p = p.nextProbablePrime();\n              synchronized (this) &#123;\n                  primes.add(p);\n              &#125;\n          &#125;\n      &#125;\n\n      public void cancel() &#123;                                                 \n          cancelled = true;\n      &#125;\n\n      public synchronized List&lt;BigInteger&gt; get() &#123;\n          return new ArrayList&lt;BigInteger&gt;(primes);\n      &#125;\n\n      static List&lt;BigInteger&gt; aSecondOfPrimes() throws InterruptedException &#123;\n          PrimeGenerator generator = new PrimeGenerator();\n          exec.execute(generator);\n          try &#123;\n              SECONDS.sleep(1);\n          &#125; finally &#123;\n              generator.cancel();\n          &#125;\n          return generator.get();\n      &#125;\n  &#125;\n\n一个可取消的任务必须拥有**取消策略(cancellation policy)**，这个策略详细说明了关于取消的“how”，“when”，“what”——其他代码如何请求取消该任务，任务在什么时候检查取消的请求是否到达，响应取消请求的任务中应有的行为。\n\n考虑现实世界中停止支付支票的例子。对于如何提交一个停止支付的请求，何时响应以保证这个请求一定会被处理，以及当支付真的被停止后还要遵守哪些流程，比如通知其他银行参与进来，对付款人的账户进行评估，这些银行都有相关的规定。这些流程和保证加在一起组成了支票支付的取消策略。\n\nPrimeGenerator使用了简单的取消政策：客户端代码通过调用cancel请求取消，PrimeGenerator每次搜索素数前检查是否有取消请求，当发现取消请求时就退出。\n\n\n7.1.1 中断\nPrimerGenerator中的取消机制最终会导致寻找素数的任务退出，但是并不是立刻发生，需要花费一些时间。但是如果一个任务使用这个方案调用一个阻塞方法，比如BlockingQueue.put，我们可能会遇到一个更严重的问题——任务可能永远都不检查取消标志，因此永远不会终结。\n\n以下代码的BrokenPrimeProducer揭示了这个问题。生产者线程生成素数，并把它们放入一个阻塞队列。如果生产者的速度超过了消费者，队列会被填满，put方法会被阻塞。当put方法被阻塞的时候，消费者如果试图去取消生产者的任务，会发生什么事情呢？它会调用cancel方法设置cancelled标志——但是此时生产者永远不可能检查这个标志了，因为它已经被put方法阻塞住了(又因为消费者此时已经停止从队列中取出素数，所以put方法会一直保持阻塞状态)。\n  //不可靠的取消把生产者置与阻塞的操作中(不要这样做)\n  class BrokenPrimeProducer extends Thread &#123;\n      private final BlockingQueue&lt;BigInteger&gt; queue;\n      private volatile boolean cancelled = false;\n\n      BrokenPrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;\n          this.queue = queue;\n      &#125;\n\n      public void run() &#123;\n          try &#123;\n              BigInteger p = BigInteger.ONE;\n              while (!cancelled)\n                  queue.put(p = p.nextProbablePrime());\n          &#125; catch (InterruptedException consumed) &#123;\n          &#125;\n      &#125;\n\n      public void cancel() &#123;\n          cancelled = true;\n      &#125;\n  &#125;\n\n特定阻塞类库的方法支持中断。线程中断是一个协作机制，一个线程给另一个线程发送信号(signal)，通知它在方便或者可能的情况下停止正在做的工作，去做其他事情。\n\n\n    在API和语言规范中，并没有把中断与任何取消的语义绑定起来，但是，实际上，\n    使用中断来处理取消之外的任何事情都是不明智的，并且很难支撑起更大的作用。\n\n每一个线程都有一个boolean类型的中断状态(interrupted status)；在中断的时候，这个中断状态被设置为true。Thread包含其他用于中断线程的方法，以及请求线程中断状态的方法，以下代码给出。interrupt方法中断目标线程，并且isInterrupt返回目标线程的中断状态。静态的interrupted方法名并不理想，它仅仅能够清除当前线程的中断状态，并返回它之前的值；这是清除中断状态唯一的方法。\n  //线程的中断方法\n  public class Thread&#123;\n      public void interrupt()&#123;...&#125;\n      public boolean isInterrupted()&#123;...&#125;\n      public static boolean interrupted()&#123;...&#125;\n  &#125;\n\n\n\n阻塞库函数，比如：Thread.sleep和Object.wait，试图监测线程何时被中断，并提前返回。它们对中断的响应状态表现为：清除中断状态，抛出InterruptedException；这表示阻塞操作因为中断的缘故提前结束。JVM并没有对阻塞方法发现中断的速度作出保证，不过在现实中这样的响应何时比较迅速的。\n\n当线程在并不处于阻塞状态的情况下发生中断时，会设置线程的中断状态，然后一直等到被取消的活动获取中断状态，来检查是否发生了中断。通过这样的方法使中断变“粘”——如果不触发InterruptedExecption，中断状态会一直保持，直到有人特意去清除中断状态。\n  调用interrupt并不意味着必然停止目标线程正在进行的工作；\n  它仅仅传递了请求中断的消息\n\n我们对中断本身最好的理解应该是:它并不会真正中断一个正在运行的线程；它仅仅是发出中断请求，线程自己会在下一个方便的时刻中断(这些时刻被成为取消点，cancellation point)。有一些方法对这样的请求很重视，比如wait、sleep和join方法，当它们接到中断请求时会抛出一个异常，或者进入中断状态就已经被设置了。运行良好的方法能够完全忽略这样的请求，只要它们把中断请求置于适当的位置上，留给调用代码进行处理。运行不好的方法可能会掩藏中断请求，这样会使调用栈中的其他的代码失去对其作出响应的机会。\n\n静态的interrupted应该小心使用，因为它会清除并发线程的中断状态。如果你调用了interrupted，并且返回了true，你必须对其进行处理，除非你想掩盖这个中断——你可以抛出InterruptedException，或者通过再次调用interrupt来保存中断状态。\n\nBrokenPrimeProducer解释了为什么常用的取消机制不能与可阻塞的库函数进行良好互动的原因。如果你的任务代码响应中断，那么你可以使用中断作为你的取消机制，并利用很多库类对中断的支持。\n  中断通常是实现取消最明智的选择。\n\nBrokenPrimeProducer可以通过使用中断，而不是boolean标志来请求取消(cancellation)，这将很容易解决问题。正如如下代码所示。在每一个迭代循环中，存在两个点可能发现中断:在调用阻塞的put方法时，以及在循环开始处显式地采集到中断状态时。在这里，因为调用了阻塞的put方法，显式的检测并不是绝对必要的，但是这种检测会使PrimeProducer对中断具有更好的响应性。这是因为它在耗时的任务——寻找素数——开始之前就检查了中断，而不是在任务完成之后才去检查。当我们调用可中断的阻塞方法时，通常并不能得到期望的响应，对中断状态进行显式的检测会对此有一定的帮助。\n  //通过使用中断进行取消\n  public class PrimeProducer extends Thread &#123;\n      private final BlockingQueue&lt;BigInteger&gt; queue;\n\n      PrimeProducer(BlockingQueue&lt;BigInteger&gt; queue) &#123;\n          this.queue = queue;\n      &#125;\n\n      public void run() &#123;\n          try &#123;\n              BigInteger p = BigInteger.ONE;\n              while (!Thread.currentThread().isInterrupted())\n                  queue.put(p = p.nextProbablePrime());\n          &#125; catch (InterruptedException consumed) &#123;\n              /* Allow thread to exit */\n          &#125;\n      &#125;\n\n      public void cancel() &#123;\n          interrupt();\n      &#125;\n  &#125;\n\n\n7.1.2 中断策略\n正如需要为任务指定取消策略一样，也应该制定线程中断策略(interrupt policy)。一个中断策略决定线程如何应对中断请求——当发现中断请求时，它会做什么(如果确实响应中断的话)，哪些工作单元对于中断来说是原子操作，以及在多快的时间里响应中断。\n\n中断策略中最有意义的是对线程级(thread-level)和服务级(service level)取消的规定：尽可能迅速退出，如果需要的话进行清理，可能的话通知其拥有的实体，这个线程已经退出。很可能建立其他中断策略，比如暂停和重新开始，但是那些具有非标准中断策略的线程或线程池，需要被约束于那些引用了该策略的任务中。\n\n任务不会在自己拥有的线程中执行；它们借用属于服务的线程，比如线程池。\n\n当检查到中断请求时，任务并不需要放弃所有事情——它可以选择推迟，直到更合适的时机。\n\n任务代码不应该猜测中断对于它的执行策略意味着什么，取消代码也不应该对任何线程的中断策略进行假设。线程应该只能够被线程的所有者中断；所有者可以把线程的中断策略信息封装到一个合适的取消机制中，比如关闭(shutdown)方法中。\n  因为每一个线程都有自己的中断策略，所以你不应该中断线程，\n  除非你知道中断对这个线程意味着什么。\n\n\n7.1.3 响应中断\n当你调用可中断的阻塞函数时，比如Thread.sleep或者BlockingQueue.put，有两种处理InterruptedException的实用策略：\n\n传递异常(很肯能发生在特定任务的清除时)，使你的方法也成为可中断的阻塞方法；\n或者保存中断状态，上层调用栈中的代码能够对其进行处理。\n\n\n传递InterruptedException只需要简单地把InterruptedException添加到throws字句中，正如以下的getNextTask所示\n  //向调用者传递InterruptedException\n  BlockingQueue&lt;Task&gt; queue;\n  ...\n  public Task getNextTask() throws InterruptedException&#123;\n      return queue.take();\n  &#125;\n\n如果不想或是不能传递中断异常(或许因为任务被定义成Runnable类型)，需要找另外一种方式保存中断请求。实现这个目的的标准方法是再次电泳interrupt来恢复中断状态。不应该掩盖中断异常，在catch块中捕获到异常却什么也不做。\n  只有实现了线程中断策略的代码才可以接收中断请求。\n  通用目的的任务和库的代码绝不应该接受中断请求。\n\n有一些活动不支持取消，却仍可以调用可中断的阻塞方法，那么它们必须在循环中调用这些方法，当发现中断后重新尝试。在这样的情况下，它们应该如以下代码所示的，在本地保存中断状态，并在返回前恢复状态，而不是立刻上前捕获InterruptedException。过早设置中断可能会引起无限循环，因为大多数可中断的阻塞方法在入口时检查中断状态，并且如果该状态已被设置，那么就立刻抛出InterruptedException。\n  //不可取消的任务在退出前保存中断\n  public class NoncancelableTask &#123;\n      public Task getNextTask(BlockingQueue&lt;Task&gt; queue) &#123;\n          boolean interrupted = false;\n          try &#123;\n              while (true) &#123;\n                  try &#123;\n                      return queue.take();\n                  &#125; catch (InterruptedException e) &#123;\n                      interrupted = true;\n                      // fall through and retry\n                  &#125;\n              &#125;\n          &#125; finally &#123;\n              if (interrupted)\n                  Thread.currentThread().interrupt();\n          &#125;\n      &#125;\n\n      interface Task &#123;\n      &#125;\n  &#125;\n\n取消可能涉及state，而不是中断状态(status)：中断可以用来获得线程的关注，同时，中断线程在其他地方存储下来的信息，可以用来进一步说明被中断的线程(访问这些信息时，要确保使用同步)。\n\n例如，一个工作者线程的所有者为ThreadPoolExecutor，这个线程在检测中断时，它会检查线程池是否被关闭。如果是，它执行一些资源池清理工作；否则他可能创建一个新线程，用来保持线程池处在期望的大小。\n\n\n7.1.4 示例：计时运行\n很多问题永远也不可能解决(比如列举所有质数)：对于其他看起来能够解决的问题，有些可能很快就能得到答案，但是也有可能永远得不到答案。在这样的情况下，如果能够设定“花十分钟寻找答案”或者“列举出十分钟内能够找到的答案”，是非常有好处的。\n\n以下代码表现的是一段给定时间内尝试运行一个Runnable。它在调用线程中运行任务，并在调度中安排了一个取消任务，由这个任务在给定时间间隔后中断它。这样解决了任务抛出未检查的异常的问题，因为异常会被timedRun的调用者捕获。\n  //在外部线程中安排中断(不要这么做)\n  public class TimedRun1 &#123;\n      private static final ScheduledExecutorService cancelExec = Executors.newScheduledThreadPool(1);\n\n      public static void timedRun(Runnable r,\n                                  long timeout, TimeUnit unit) &#123;\n          final Thread taskThread = Thread.currentThread();\n          cancelExec.schedule(new Runnable() &#123;\n              public void run() &#123;\n                  taskThread.interrupt();\n              &#125;\n          &#125;, timeout, unit);\n          r.run();\n      &#125;\n  &#125;\n\n\n\n这个方法很简单，但是破坏了下面的规则：在中断线程之前，你应该了解它的中断策略。因为timedRun可以被任意一个线程调用，但是我们不可能了解这个调用线程的中断策略。如果任务在时限之前完成，执行中断一个线程(这个县城调用了timedRun)的取消任务可能会在timedRun返回到它调用者之后，才被启动。我们不知道这发生的时候，将执行什么样的代码，但是结果一定不好。(我们可以通过使用schedule返回的ScheduleFuture来取消这个取消任务，以此来规避风险。这种做法是可能的，而且相当地取巧。)\n\n进一步来看，如果任务不响应中断，timedRun将不会返回，直到任务结束。\n\n以下代码解决了aSecondOfPrimers的异常处理问题，并且也解决了在前面的做法中引发的问题。用来执行任务的线程拥有自己的执行策略，即使任务不响应中断，限时运行的方法仍然能够返回到它的调用者。在开始任务线程之后，timedRun会在新创建的线程中执行一个限时的join方法。在join返回后，它会检查任务中是否有异常抛出，如果是，那么会在调用timedRun的线程中再抛出一次。保存下来的Throwable在两线程间共享，声明为volatile也是同样道理，它被安全地发布，从任务线程再到timedRun线程。\n  //在一个专门的线程中中断任务\n  public class TimedRun2 &#123;\n      private static final ScheduledExecutorService cancelExec = newScheduledThreadPool(1);\n\n      public static void timedRun(final Runnable r,\n                                  long timeout, TimeUnit unit)\n              throws InterruptedException &#123;\n          class RethrowableTask implements Runnable &#123;\n              private volatile Throwable t;\n\n              public void run() &#123;\n                  try &#123;\n                      r.run();\n                  &#125; catch (Throwable t) &#123;\n                      this.t = t;\n                  &#125;\n              &#125;\n\n              void rethrow() &#123;\n                  if (t != null)\n                      throw launderThrowable(t);\n              &#125;\n          &#125;\n\n          RethrowableTask task = new RethrowableTask();\n          final Thread taskThread = new Thread(task);\n          taskThread.start();\n          cancelExec.schedule(new Runnable() &#123;\n              public void run() &#123;\n                  taskThread.interrupt();\n              &#125;\n          &#125;, timeout, unit);\n          taskThread.join(unit.toMillis(timeout));\n          task.rethrow();\n      &#125;\n  &#125; \n\njoin的不足之处是：我们不知道控制权的返回是因为线程自然退出还是join超时。\n\n\n7.1.5 通过Future取消\n我们曾经用过一个抽象体，他可以管理任务的声明周期，处理异常，并有利于取消——Future。我们使用Future和任务执行框架来构建timedRun。\n\nExecutor.submit会返回一个Future来描述任务。Future有一个cancel方法，他需要一个boolean类型的参数，mayInterruptIfRunning，它的返回值表示取消尝试是否成功(这仅仅告诉你他是否能够接收中断，而不是任务是否检测并处理了中断)。当mayInterruptIfRunning为true，并且任务当前正在运行于一些线程中，那么这个线程是应该中断的。把这个参数设置成false意味着“如果还没有启动的话，不要运行这个任务”，这应该用于那些不处理中断的任务。\n\n当尝试取消一个任务时，不应该直接中断线程池，因为你不知道请求到达时，什么任务正在运行——只能通过任务的Future来做这件事。\n\n以下的timedRun，向ExecutorService提交了任务，并通过定时的Future.get获得结果。如果get终止于一个TimeoutException，那么任务是由Future取消的。如果深层计算在取消前就抛出一个异常，这个异常在timedRun中会重新被抛出，这是调用者处理异常最简单的方法。这也是非常好的实践：取消那些不再需要结果的任务。\n  //通过Future来取消任务\n  public class TimedRun &#123;\n      private static final ExecutorService taskExec = Executors.newCachedThreadPool();\n\n      public static void timedRun(Runnable r,\n                                  long timeout, TimeUnit unit)\n              throws InterruptedException &#123;\n          Future&lt;?&gt; task = taskExec.submit(r);\n          try &#123;\n              task.get(timeout, unit);\n          &#125; catch (TimeoutException e) &#123;\n              // task will be cancelled below\n          &#125; catch (ExecutionException e) &#123;\n              // exception thrown in task; rethrow\n              throw launderThrowable(e.getCause());\n          &#125; finally &#123;\n              // Harmless if task already completed\n              task.cancel(true); // interrupt if running\n          &#125;\n      &#125;\n  &#125;\n\n当Future.get抛出InterruptedException或TimeoutException时，如果你直到不再需要结果时，就可以调用Future.cancel来取消任务了。\n\n\n7.1.6 处理不可中断阻塞\n很多可阻塞的库方法通过提前返回和抛出InterruptedException来实现对中断的响应，这使得构建可以响应取消的任务更加容易了。但是，并不是所有的阻塞方法或阻塞机制都响应中断；如果一个线程是由于同步Socket I/O或者等待获得内部锁而阻塞的，那么中断除了能够设置线程的中断状态以外，什么都不能改变。对于那些不可中断的活动所阻塞的线程，我们可以使用与中断类似的手段，来确保可以停止这些线程。但是这需要我们更清楚地知道线程为什么会被阻塞。\n\njava.io的同步Socket I/O。在服务器应用程序中，阻塞I/O最常见的形式是读取和写入Socket。不幸的是，InputStream和OutputStream中的read和write方法都不响应中断，但是通过关闭底层的Socket，可以让read 或 write所阻塞的线程抛出一个SocketException。\njava.nio中的同步I/O。中断一个等待InterruptibleChannel的线程，会导致抛出ClosedByInterruptException，并关闭链路(也会导致其他线程在这条链路的阻塞，抛出ClosedByInterruptException)。关闭一个InterruptibleChannel导致多个阻塞在链路操作上的线程抛出AsynchronousCloseException。大多数标准Channels都实现InterruptibleChannel。\nSelector 的异步 I/O。如果一个线程阻塞于Select.select方法(在java.nio.channels中)，close方法会导致它通过抛出ClosedSelectorException提前返回。\n获得锁。如果一个线程在等待内部锁，那么如果不能确保它最终获得锁，并且作出足够多的努力，让你能够以其他方式获得它的注意，你是不能停止它的。然而，显式Lock类提供了lockInterruptibly方法，允许你等待一个锁，并仍然能够响应中断。\n\n\n以下代码的ReaderThread展现了一项用来封装非标准取消的技术。ReaderThread管理一个单线程Socket连接，同步地从Socket中读取数据，把接收到的数据传递给processBuffer。为了方便终止一个用户的连接，或关闭服务器，ReaderThread重写了interrupt方法，既为了支持标准的中断，也为了关闭潜在Socket，因此中断ReaderThread使得它能够在进行工作时停止，而无论它是被read阻塞的，还是被可中断的阻塞方法所阻塞。\n  //在Thread中，通过重写interrupt来封装非标准取消\n  public class ReaderThread extends Thread &#123;\n      private static final int BUFSZ = 512;\n      private final Socket socket;\n      private final InputStream in;\n\n      public ReaderThread(Socket socket) throws IOException &#123;\n          this.socket = socket;\n          this.in = socket.getInputStream();\n      &#125;\n\n      public void interrupt() &#123;\n          try &#123;\n              socket.close();\n          &#125; catch (IOException ignored) &#123;\n          &#125; finally &#123;\n              super.interrupt();\n          &#125;\n      &#125;\n\n      public void run() &#123;\n          try &#123;\n              byte[] buf = new byte[BUFSZ];\n              while (true) &#123;\n                  int count = in.read(buf);\n                  if (count &lt; 0)\n                      break;\n                  else if (count &gt; 0)\n                      processBuffer(buf, count);\n              &#125;\n          &#125; catch (IOException e) &#123; /* Allow thread to exit */\n          &#125;\n      &#125;\n\n      public void processBuffer(byte[] buf, int count) &#123;\n      &#125;\n  &#125;\n\n\n7.1.7 用newTaskFor封装非标准取消\n在ReaderThread中，可以使用newTaskFor钩子函数来改进用来封装非标准取消的方法。当提交一个Callable给ExecutorService时，submit返回一个Future，可以用Future来取消任务。newTaskFor钩子是一个工厂方法，创建Future来代表任务。它返回一个RunnableFuture，这是一个接口，它扩展了Future和Runnable(并由FutureTask实现)。\n\n自定义的任务Future允许你覆写Future.cancel方法。自定义的取消代码可以实现日志或者收集取消的统计信息，并可以用来取消那些不响应中断的活动。通过覆写interrupt，ReaderThread封装了使用Socket的线程的取消行为：同样的事情也可以通过覆写任务的Future.cancel方法来实现。\n\n以下代码的CancellableTask定义了一个CallableTask接口，这个接口扩展了Callable，并加入了cancel方法和一个新的newTask工厂方法，来构造RunnableFuture。CancellingExecutor扩展了ThreadPoolExecutor，并覆写了newTaskFor，让CancellableTask可以创建自己的Future。\n  //用newTaskFor封装任务中非标准取消\n  public abstract class SocketUsingTask &lt;T&gt; implements CancellableTask&lt;T&gt; &#123;\n      @GuardedBy(&quot;this&quot;) private Socket socket;\n\n      protected synchronized void setSocket(Socket s) &#123;\n          socket = s;\n      &#125;\n\n      public synchronized void cancel() &#123;\n          try &#123;\n              if (socket != null)\n                  socket.close();\n          &#125; catch (IOException ignored) &#123;\n          &#125;\n      &#125;\n\n      public RunnableFuture&lt;T&gt; newTask() &#123;\n          return new FutureTask&lt;T&gt;(this) &#123;\n              public boolean cancel(boolean mayInterruptIfRunning) &#123;\n                  try &#123;\n                      SocketUsingTask.this.cancel();\n                  &#125; finally &#123;\n                      return super.cancel(mayInterruptIfRunning);\n                  &#125;\n              &#125;\n          &#125;;\n      &#125;\n  &#125;\n\n  interface CancellableTask &lt;T&gt; extends Callable&lt;T&gt; &#123;\n      void cancel();\n\n      RunnableFuture&lt;T&gt; newTask();\n  &#125;\n\n  @ThreadSafe\n  class CancellingExecutor extends ThreadPoolExecutor &#123;\n      public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123;\n          super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);\n      &#125;\n\n      public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123;\n          super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory);\n      &#125;\n\n      public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123;\n          super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, handler);\n      &#125;\n\n      public CancellingExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123;\n          super(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler);\n      &#125;\n\n      protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123;\n          if (callable instanceof CancellableTask)\n              return ((CancellableTask&lt;T&gt;) callable).newTask();\n          else\n              return super.newTaskFor(callable);\n      &#125;\n  &#125; \n\n\nSocketUsingTask实现了CancellableTask，并定义了Future.cancel来关闭Socket，super.cancel也是同样的道理。如果SocketUsingTask通过自身的Future被取消，Socket会被关闭并且执行线程会被中断。这提高了任务对取消的响应性。这样做在保证响应取消的同时，不仅可以安全地调用可中断方法，而且可以调用阻塞中的Socket I/O的方法。\n7.2 停止基于线程的服务\n应用程序通常会创建拥有线程的服务，比如线程池，这些服务的存在时间通常比创建它们的方法存在的时间更长。如果应用程序优雅的退出，这些服务的线程也需要结束。因为没有退出线程惯用的优先方法，它们需要自行结束。\n\n线程有一个对应的拥有者，这个拥有者就是创建线程的类。所以线程池拥有它的工作者线程，如果需要中断这些线程，那么应该由线程池来负责。\n\n应用程序不直接拥有工作者线程，所以应用程序不应该试图停止工作者线程。相反，服务应该提供生命周期方法来关闭它自己，并关闭它所拥有的线程；那么当应用程序关闭这个服务时，服务就可以关闭所有的线程了。ExecutorService提供了shutdown和shutdownNow方法，其他线程持有的服务也应该都提供类似的关闭机制。\n  对于线程持有的服务，只要服务的存在时间大于创建线程的方法存在的时间，那么就应该提供生命周期方法。\n\n\n7.2.1 实例：日志服务\n大多数服务器应用程序都使用日志，日志可以简单的向代码中插入一条println语句。PrintWriter这样的字符流类是线程安全的，所以这样简单的方法不需要显式地调用同步。但是，有时候单行的日志在一些大容量的应用中可能存在一些性能开销。另外一种替代方法是使log把日志记录派发给其他线程处理。\n\n以下代码中的LogWriter展现了一个简单的日志服务示例。其中日志活动被分离到一个单独的日志线程中。产生消息的线程不会将消息直接写入输出流，而是由LogWriter通过BlockingQueue把这个任务移交给了日志线程，并由日志线程写入。这是一个多生产者、单消费者的设计：所有活动都调用了log，这些活动就作为生产者，后台的日志线程是消费者。如果消费者落后了，BlockingQueue稍后会阻塞生产者，直到日志线程跟上来。\n  //不支持关闭的生产者-消费者日志服务\n  public class LogWriter &#123;\n      private final BlockingQueue&lt;String&gt; queue;\n      private final LoggerThread logger;\n      private static final int CAPACITY = 1000;\n\n      public LogWriter(Writer writer) &#123;\n          this.queue = new LinkedBlockingQueue&lt;String&gt;(CAPACITY);\n          this.logger = new LoggerThread(writer);\n      &#125;\n\n      public void start() &#123;\n          logger.start();\n      &#125;\n\n      public void log(String msg) throws InterruptedException &#123;\n          queue.put(msg);\n      &#125;\n\n      private class LoggerThread extends Thread &#123;\n          private final PrintWriter writer;\n\n          public LoggerThread(Writer writer) &#123;\n              this.writer = new PrintWriter(writer, true); // autoflush\n          &#125;\n\n          public void run() &#123;\n              try &#123;\n                  while (true)\n                      writer.println(queue.take());\n              &#125; catch (InterruptedException ignored) &#123;\n              &#125; finally &#123;\n                  writer.close();\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n为了让一个类似于LogWriter的服务在生产中真正可用，我们需要一个方法来终止日志线程，这样不会让JVM无法正常关闭。停止日志线程是很容易的，因为它重复调用take，而take响应中断；如果日志线程被修改为捕获到InterruptedException就退出，那么中断日志线程就能够停止服务。\n\n但是简单地使日志线程退出并不是令人十分满意的关闭机制。这样突然的关闭忽略了等待中需要被记录的日志，但更重要的是，线程会因为队列已满，在log处被阻塞，却永远不可能从阻塞解脱出来。取消一个生产者-消费者活动既要取消生产者，又要取消消费者。中断日志线程会着手处理消费者，但是这个例子中，因为生产者非专一线程，取消它们将变得非常困难。\n\n另一个关闭LogWriter的方案可以设置“已请求关闭”标志，避免消息进一步被提交进来，代码如下。在接收到关闭请求后，消费者会离开队列，写出所有等待中的消息，并将log中所有阻塞的生产者解除阻塞。但是这个方案存在竞争条件，这使它并不可靠。log的实现是一个“检查再运行”序列：生产者观察没有被关闭的服务，但即便关闭后，仍然会把消息放入队列，同样地，这里存在这样的风险，生产者在log中被阻塞，却不能解脱出来。\n  //向日志服务添加不可靠的关闭支持\n  public void log(String msg) throws InterruptedException &#123;\n      if(!shutdownRequested)\n          queue.put(msg);\n      else\n          throw new IllegalStateException(&quot;logger is shut down&quot;);\n  &#125;\n\n为LogWriter提供可靠的关闭方法是解决竞争条件，这意味着创建新日志消息的各个子任务必须是原子的。但是我们不希望在消息加入队列时加锁，因为put方法可能发生阻塞。我们能够做的事情是原子化地检查关闭，并有条件地递增记录获得提交消息权利的计数器，正如以下代码所示。\n  //向LogWriter添加可靠的取消\n  public class LogService &#123;\n      private final BlockingQueue&lt;String&gt; queue;\n      private final LoggerThread loggerThread;\n      private final PrintWriter writer;\n      @GuardedBy(&quot;this&quot;) private boolean isShutdown;\n      @GuardedBy(&quot;this&quot;) private int reservations;\n\n      public LogService(Writer writer) &#123;\n          this.queue = new LinkedBlockingQueue&lt;String&gt;();\n          this.loggerThread = new LoggerThread();\n          this.writer = new PrintWriter(writer);\n      &#125;\n\n      public void start() &#123;\n          loggerThread.start();\n      &#125;\n\n      public void stop() &#123;\n          synchronized (this) &#123;\n              isShutdown = true;\n          &#125;\n          loggerThread.interrupt();\n      &#125;\n\n      public void log(String msg) throws InterruptedException &#123;\n          synchronized (this) &#123;\n              if (isShutdown)\n                  throw new IllegalStateException(/*...*/);\n              ++reservations;\n          &#125;\n          queue.put(msg);\n      &#125;\n\n      private class LoggerThread extends Thread &#123;\n          public void run() &#123;\n              try &#123;\n                  while (true) &#123;\n                      try &#123;\n                          synchronized (LogService.this) &#123;\n                              if (isShutdown &amp;&amp; reservations == 0)\n                                  break;\n                          &#125;\n                          String msg = queue.take();\n                          synchronized (LogService.this) &#123;\n                              --reservations;\n                          &#125;\n                          writer.println(msg);\n                      &#125; catch (InterruptedException e) &#123; /* retry */\n                      &#125;\n                  &#125;\n              &#125; finally &#123;\n                  writer.close();\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n\n7.2.2 关闭ExecutorService\nExecutorService提供了关闭的两种方法：\n\nshutdown——优雅的关闭\nshutdownNow——强行的关闭。shutdownNow首先尝试关闭当前正在执行的任务，然后返回待完成任务的清单\n\n\n两种不同的终结选择在安全性和响应性之间进行了权衡：强行终结的速度更快，但是风险大，因为任务很可能在执行到一半的时候被终结，而正常终结虽然速度慢，却安全，因为直到队列中的所有任务完成前，ExecutorService都不会关闭。其他拥有线程的服务应该考虑提供类似的关闭模式以供选择。\n\n简单的程序可以避免在main函数中启动和关闭一个全局ExecutorService。更复杂的程序很可能把ExecutorService封装于一个高层级的服务中，在其中提供自己的生命周期方法，比如以下代码中变量LogService，它由ExecutorService进行代理。ExecutorService不会管理LogService拥有的线程。封装ExecutorService通过增加链接，把所有权从应用程序扩展到了服务，再到线程；每一个链上的成员管理它拥有的服务或线程的生命周期。\n  //使用ExecutorService的日志服务\n  public class LogService&#123;\n      private final ExecutorService exec = new SingleThreadPoolExecutor();\n      ...\n      public void start()&#123;&#125;\n      public void stop() throws InterruptedException &#123;\n          try&#123;\n              exec.shutdown();\n              exec.awaitTermination(TIMEOUT,UNIT);\n          &#125;finally&#123;\n              writer.close();\n          &#125;\n      &#125;\n      public void log(String msg)&#123;\n          try&#123;\n              exec.exchange(new WriteTask(msg));\n          &#125;catch(RejectedExecutionException ignored)&#123;&#125;\n      &#125;\n  &#125;\n\n\n7.2.3 致命药丸\n另一种保证生产者和消费者服务关闭的方式是使用致命药丸(poison pill)：一个可识别的对象，置于队列中，意味着“当你得到它时，停止一切工作”。在先进先出队列中，致命药丸保证了消费者完成队列中关闭之前的所有工作，因为所有早于致命药丸提交的工作都会在处理它之前就完成了，生产者不应该在提交了致命药丸后，再提交任何工作。以下代码使用致命药丸来关闭服务。\n  //使用致命药丸来关闭\n  public class IndexingService &#123;\n      private static final int CAPACITY = 1000;\n      private static final File POISON = new File(&quot;&quot;);\n      private final IndexerThread consumer = new IndexerThread();\n      private final CrawlerThread producer = new CrawlerThread();\n      private final BlockingQueue&lt;File&gt; queue;\n      private final FileFilter fileFilter;\n      private final File root;\n\n      public IndexingService(File root, final FileFilter fileFilter) &#123;\n          this.root = root;\n          this.queue = new LinkedBlockingQueue&lt;File&gt;(CAPACITY);\n          this.fileFilter = new FileFilter() &#123;\n              public boolean accept(File f) &#123;\n                  return f.isDirectory() || fileFilter.accept(f);\n              &#125;\n          &#125;;\n      &#125;\n\n      private boolean alreadyIndexed(File f) &#123;\n          return false;\n      &#125;\n\n      class CrawlerThread extends Thread &#123;\n          public void run() &#123;\n              try &#123;\n                  crawl(root);\n              &#125; catch (InterruptedException e) &#123; /* fall through */\n              &#125; finally &#123;\n                  while (true) &#123;\n                      try &#123;\n                          queue.put(POISON);\n                          break;\n                      &#125; catch (InterruptedException e1) &#123; /* retry */\n                      &#125;\n                  &#125;\n              &#125;\n          &#125;\n\n          private void crawl(File root) throws InterruptedException &#123;\n              File[] entries = root.listFiles(fileFilter);\n              if (entries != null) &#123;\n                  for (File entry : entries) &#123;\n                      if (entry.isDirectory())\n                          crawl(entry);\n                      else if (!alreadyIndexed(entry))\n                          queue.put(entry);\n                  &#125;\n              &#125;\n          &#125;\n      &#125;\n\n      class IndexerThread extends Thread &#123;\n          public void run() &#123;\n              try &#123;\n                  while (true) &#123;\n                      File file = queue.take();\n                      if (file == POISON)\n                          break;\n                      else\n                          indexFile(file);\n                  &#125;\n              &#125; catch (InterruptedException consumed) &#123;\n              &#125;\n          &#125;\n\n          public void indexFile(File file) &#123;\n              /*...*/\n          &#125;;\n      &#125;\n\n      public void start() &#123;\n          producer.start();\n          consumer.start();\n      &#125;\n\n      public void stop() &#123;\n          producer.interrupt();\n      &#125;\n\n      public void awaitTermination() throws InterruptedException &#123;\n          consumer.join();\n      &#125;\n  &#125;\n\n致命药丸只有在生产者和消费者数量已知的情况下使用。\n\n\n7.2.4 示例：只执行一次的服务\n如果一个方法需要处理一批服务，并在所有任务结束前不会返回，那么它可以通过使用私有的Executor来简化服务的生命周期管理，其中Executor的寿命限定在该方法中。\n\n以下代码中的checkMail方法同时在多个服务器上并行地检查新邮件。它创建一个私有的Executor，并向每一个主机提交任务：在这之后，当所有检查邮件的任务完成后，它会关闭Executor，并等待结束。\n  //使用私有Executor，将它的寿命限定于一次方法调用中\n  public class CheckForMail &#123;\n      public boolean checkMail(Set&lt;String&gt; hosts, long timeout, TimeUnit unit)\n              throws InterruptedException &#123;\n          ExecutorService exec = Executors.newCachedThreadPool();\n          final AtomicBoolean hasNewMail = new AtomicBoolean(false);\n          try &#123;\n              for (final String host : hosts)\n                  exec.execute(new Runnable() &#123;\n                      public void run() &#123;\n                          if (checkMail(host))\n                              hasNewMail.set(true);\n                      &#125;\n                  &#125;);\n          &#125; finally &#123;\n              exec.shutdown();\n              exec.awaitTermination(timeout, unit);\n          &#125;\n          return hasNewMail.get();\n      &#125;\n\n      private boolean checkMail(String host) &#123;\n          // Check for mail\n          return false;\n      &#125;\n  &#125;\n\n\n7.2.5 shutdownNow 的局限性\n当通过shutdownNow强行关闭一个ExecutorService时，它试图取消正在进行的任务，并返回那些已经提交。但并没有开始的任务的清单，这样，这些任务可以被日志记录，或者存起来等待进一步处理。\n\n然而，我们并没有任何常规的方法用于找出那些已经开始、却没有结束的任务。这意味着，我们不可能在关闭时知道进行中的任务的状态，除非任务本身设立了某些检查点。为了得知哪些任务没有结束，你不仅需要知道哪些任务还没有开始，而且应该知道Executor关闭时，哪些任务正在进行中。\n\n以下代码展现了如何在关闭线程中判定哪些任务还在进行的技术。通过封装ExecutorService并使用execute(类似的还有submit，不过没有显示)，来记录哪些任务是在关闭后取消的。TrackingExecutor可以识别哪些任务已经开始，却没有正常结束。在executor结束后，getCancelledTasks返回被取消的任务清单。为应用这个技术，任务必须在返回时保存线程的中断状态，这是运行良好的任务无论如何应该完成的。\n  //关闭之后，ExecutorService获取被取消的任务\n  public class TrackingExecutor extends AbstractExecutorService &#123;\n      private final ExecutorService exec;\n      private final Set&lt;Runnable&gt; tasksCancelledAtShutdown =\n              Collections.synchronizedSet(new HashSet&lt;Runnable&gt;());\n\n      public TrackingExecutor(ExecutorService exec) &#123;\n          this.exec = exec;\n      &#125;\n\n      public void shutdown() &#123;\n          exec.shutdown();\n      &#125;\n\n      public List&lt;Runnable&gt; shutdownNow() &#123;\n          return exec.shutdownNow();\n      &#125;\n\n      public boolean isShutdown() &#123;\n          return exec.isShutdown();\n      &#125;\n\n      public boolean isTerminated() &#123;\n          return exec.isTerminated();\n      &#125;\n\n      public boolean awaitTermination(long timeout, TimeUnit unit)\n              throws InterruptedException &#123;\n          return exec.awaitTermination(timeout, unit);\n      &#125;\n\n      public List&lt;Runnable&gt; getCancelledTasks() &#123;\n          if (!exec.isTerminated())\n              throw new IllegalStateException(/*...*/);\n          return new ArrayList&lt;Runnable&gt;(tasksCancelledAtShutdown);\n      &#125;\n\n      public void execute(final Runnable runnable) &#123;\n          exec.execute(new Runnable() &#123;\n              public void run() &#123;\n                  try &#123;\n                      runnable.run();\n                  &#125; finally &#123;\n                      if (isShutdown()\n                              &amp;&amp; Thread.currentThread().isInterrupted())\n                          tasksCancelledAtShutdown.add(runnable);\n                  &#125;\n              &#125;\n          &#125;);\n      &#125;\n  &#125;\n\n在以下代码中，WebCrawler展现了TrackingExecutor的应用。WebCrawler的工作通常都是无穷尽的，所以，如果Crawler必须关闭的时候，我们可能希望保存它的状态，这样它可以稍后被重新启动。CrawlTask方法提供了一个getPage方法，这个方法识别了Crawler正在哪一个页面工作。当Crawler关闭后，无论是还没有开始的任务，还是那些被取消的任务，都会被检查并记录下URL，当Crawler重新启动时，这些URL的page-crawling任务就可以加入到队列中了。\n  //使用TrackingExecutorService为后续执行来保存未完成的任务\n  public abstract class WebCrawler &#123;\n      private volatile TrackingExecutor exec;\n      @GuardedBy(&quot;this&quot;) private final Set&lt;URL&gt; urlsToCrawl = new HashSet&lt;URL&gt;();\n\n      private final ConcurrentMap&lt;URL, Boolean&gt; seen = new ConcurrentHashMap&lt;URL, Boolean&gt;();\n      private static final long TIMEOUT = 500;\n      private static final TimeUnit UNIT = MILLISECONDS;\n\n      public WebCrawler(URL startUrl) &#123;\n          urlsToCrawl.add(startUrl);\n      &#125;\n\n      public synchronized void start() &#123;\n          exec = new TrackingExecutor(Executors.newCachedThreadPool());\n          for (URL url : urlsToCrawl) submitCrawlTask(url);\n          urlsToCrawl.clear();\n      &#125;\n\n      public synchronized void stop() throws InterruptedException &#123;\n          try &#123;\n              saveUncrawled(exec.shutdownNow());\n              if (exec.awaitTermination(TIMEOUT, UNIT))\n                  saveUncrawled(exec.getCancelledTasks());\n          &#125; finally &#123;\n              exec = null;\n          &#125;\n      &#125;\n\n      protected abstract List&lt;URL&gt; processPage(URL url);\n\n      private void saveUncrawled(List&lt;Runnable&gt; uncrawled) &#123;\n          for (Runnable task : uncrawled)\n              urlsToCrawl.add(((CrawlTask) task).getPage());\n      &#125;\n\n      private void submitCrawlTask(URL u) &#123;\n          exec.execute(new CrawlTask(u));\n      &#125;\n\n      private class CrawlTask implements Runnable &#123;\n          private final URL url;\n\n          CrawlTask(URL url) &#123;\n              this.url = url;\n          &#125;\n\n          private int count = 1;\n\n          boolean alreadyCrawled() &#123;\n              return seen.putIfAbsent(url, true) != null;\n          &#125;\n\n          void markUncrawled() &#123;\n              seen.remove(url);\n              System.out.printf(&quot;marking %s uncrawled%n&quot;, url);\n          &#125;\n\n          public void run() &#123;\n              for (URL link : processPage(url)) &#123;\n                  if (Thread.currentThread().isInterrupted())\n                      return;\n                  submitCrawlTask(link);\n              &#125;\n          &#125;\n\n          public URL getPage() &#123;\n              return url;\n          &#125;\n      &#125;\n  &#125;\n\nTrackingExecutor存在不可避免的竞争条件，使它产生假阳性(false positive)现象：\n\n识别出的被取消任务事实上可能已经结束。\n\n\n产生的原因是：\n\n在任务执行的最后一条指令，以及线程池记录任务结束之间，线程池可能发生关闭。如果任务是幂等的(idempotent，如果执行两次得到的结果与执行一次相同)，那么这不会有什么问题，典型的Web Crawler就是这样。另一方面，应用程序得到已被取消的任务必须注意这个风险，应该为这样的假阳性现象作好准备。\n\n\n\n7.3 处理反常的线程终止\n当一个单线程化的控制台程序因为未捕获的异常终止的时候，程序停止运行，并产生了栈追踪，这与典型的程序输出有很大的不同——这是很明显的。并发程序中线程的失败往往就没有这么明显了。栈追踪可能会从控制台输出，但是没有人回去观察控制台，并且，当线程失败的时候，应用程序可能看起来仍在工作，所以它的失败可能就会被忽略。幸运的是，我们有办法可以监测和防止线程从程序中“泄露”。\n\n导致线程死亡的最主要原因是RuntimeException。因为这些异常表明一个程序错误或者其他不可修复的错误，它们通常是不能被捕获的。它们不会顺着栈的调用传递，此时，默认的行为是在控制台打印栈追踪的信息，并终止线程。\n\n线程非正常退出的后果包括良性的与恶性的，取决于线程在应用程序中的角色。\n\n以下代码阐释了如何在线程池内部构建一个工作者线程。如果任务跑出了一个未检查的异常，它将允许线程终结，但是会首先通知框架：线程已经终结。然后，框架可能会用新的线程取代这个工作线程，也可能不这样做，因为线程池也许正在关闭，抑或当前已有足够多的线程，能够满足需要了。ThreadPoolExecutor和Swing使用这项技术来确保那些不能正常运转的任务不会影响到后续任务的执行。如果你正在写一个工作者线程类，它会向线程池提交任务，或者调用不可信的外部代码(比如动态载入的插件)，使用其中一种解决方案可以避免不好的任务或插件牵连到调用它的整个线程。\n  //典型线程池的工作者线程的构建\n  public void run()&#123;\n      Throwable thrown = null;\n      try&#123;\n          while(!isInterrupted())&#123;\n              runTask(getTaskFromWorkQueue());\n          &#125;catch(Throwable e)&#123;\n              thrown = e;\n          &#125;finally&#123;\n              threadExited(this, thrown);\n          &#125;\n      &#125;\n  &#125;\n\n\n7.3.1 未捕获异常的处理\n前面一节是一种主动解决未检查异常问题的方案。线程的API提供了UncaughtExceptionHandler的工具，使你能够监测到线程因未捕获的异常引起的“死亡”。这两个方案互为补充：合在一起，组成了对抗线程泄露的强有力的保障。\n\n当一个线程因为未捕获异常而退出时，JVM会把这个事件报告给应用程序提供的UncaughtExceptionHandler；如果处理器(handler)不存在，默认的行为是System.err打印栈追踪信息。\n  //UncaughtExceptionHandler接口\n  public interface UncaughtExceptionHandler &#123;\n          void uncaughtException(Thread t, Throwable e);\n  &#125;\n\n如果处理未捕获异常取决于对服务质量的需求。最常见的响应是记录一个错误信息，并把栈追踪信息写入应用程序日志中，如下代码。处理器也可以进行更直接的反应，比如尝试重新启动线程，关闭应用程序，对操作进行分页，或者其他纠正行为，或诊断行为。\n  //UncaughtExceptionHandler 将异常写入日志\n  public class UEHLogger implements Thread.UncaughtExceptionHandler &#123;\n      public void uncaughtException(Thread t, Throwable e) &#123;\n          Logger logger = Logger.getAnonymousLogger();\n          logger.log(Level.SEVERE, &quot;Thread terminated with exception: &quot; + t.getName(), e);\n      &#125;\n  &#125;\n\n\n\n在一个长时间运行的应用程序中，所有的线程都要给未捕获异常设置一个处理器，这个处理器至少要将异常信息记入日志中。\n\n7.4 JVM关闭\nJVM既可以通过正常手段关闭，也可以强行关闭。当最后一个“正常(非精灵)”线程终结时，或者当有人调用了System.exit时，以及通过使用其他与平台相关手段时(比如发送了SIGINT，或键入Ctrl-C)，都可以开始一个正常的关闭。尽管JVM可以通过这些标准的首选方法关闭，它仍然能够通过调用Runtime.halt或者杀死JVM的操作系统进程被强行关闭(比如发送SIGKILL)。\n\n在正常的关闭中，JVM首先启动所有已注册的Shutdown hook。关闭钩子是使用Runtime.addShutdownHook注册的尚未开始的线程。JVM并不能保证关闭钩子的开始顺序。如果关闭应用程序线程(精灵或非精灵)时，它仍然在运行，它们接下来将与关闭进程并发执行。当所有关闭钩子结束的时候，如果runFinalizersOnExit为true，JVM可以选择运行finalizer，之后停止。JVM不会尝试停止或中断任何关闭时仍然在运行中的应用程序线程；它们在JVM最终终止时被强制退出。如果关闭钩子或finalizer没有完成，那么正常的关闭进程“挂起”并且JVM必须强行关闭。在强行关闭中，JVM不需要完成除了关闭JVM以外的任何事情；不会运行关闭钩子。\n\n关闭钩子应该是线程安全的：它们在访问共享数据时必须使用同步，并应该小心地避免死锁，这与其他的并发代码是相同的。进一步而言，它们不仅需要假设应用程序的状态(比如其他服务是否已经关闭，或者正常的线程是否已经完成任务)或者关于JVM为何关闭，因此在代码过程中必须格外小心。最后，在用户可能希望JVM快速终止的情况下，它们必须尽快退出，因为它们的存在会延迟JVM的终止。\n\n关闭钩子可以用于服务或应用程序的清理，比如删除临时文件，或者清除OS不能自动清除的资源。以下代码表现了LogService如何从它的start方法中注册一个关闭钩子，来确保它的日志文件在退出时关闭。\n  //注册关闭钩子来停止日志服务\n  public void start()&#123;\n      Runtime.getRuntime().addShutdownHook(new Thread()&#123;\n              public void run()&#123;\n                  try&#123;LogService.this.stop();&#125;\n                  catch(InterruptedException ignored)&#123;&#125;\n              &#125;\n          &#125;);\n      &#125;\n  &#125;\n\n因为关闭钩子全部都是并发执行的，关闭日志文件可能引起其他需要使用日志服务的关闭钩子的麻烦。为了避免这个问题，关闭钩子不应该依赖于可能被应用程序或其他关闭钩子关闭的服务。实现它的一种方式是对所有服务使用唯一关闭钩子，让它调用一系列关闭行为，而不是每个服务使用一个。这确保了关闭的动作在单线程中顺序发生，因此避免了竞争条件的出现，或关闭动作之前的死锁；顺序的而非并发的执行关闭动作，可以消除许多潜在的资源失败。当某个应用程序要维护服务间显示依赖信息时，这个技术可以保证关闭动作按照正确的顺序进行。\n\n\n7.4.2 精灵线程\n有时你想创建一个线程，执行一些辅助工作，但是你不希望这个线程的存在阻碍JVM的关闭。这时你需要用到**精灵线程(deamon thread)**。\n线程分为两种：\n普通线程\n精灵线程(垃圾回收器和其他类似线程)\n\n\n当一个线程退出时，JVM会检查一个运行中线程的详细清单，如果仅剩下精灵线程，它会发起正常的退出。当JVM停止时，所有仍然存在的精灵线程都会被抛弃——不会执行finally块，也不会释放栈——JVM直接退出、\n精灵线程应该小心使用。最好用于“家务管理(housekeeping)”的任务，比如一个背景线程可以从内存的缓存中周期性地移除过期的访问。\n应用程序中，精灵线程不能替代对服务的生命周期恰当、良好的管理。\n\n\n\n7.4.3 Finalizer\n当我们不再需要资源后，垃圾回收器重新获得内存资源是非常有益的，但是一些资源，比如文件或者Socket句柄，当我们不再需要时，必须显示地归还给操作系统。为了在这方面提供帮助，垃圾回收器对那些特殊的finalize方法的对象进行特殊对待：在回收器获得它们后，finalize被调用，这样就能保证持久化的资源可以被释放。\n因为finalizer可以运行在一个JVM管理的线程中，任何finalizer访问的状态都会被多个线程访问，因此必须被同步。finalizer运行时不通过任何保证，并且拥有复杂的finalizer会带来对象巨大的性能开销。正确的书写finalizer也十分困难。在大多数情况下，使用finally块和显示close方法的结合来管理资源，会比使用finalizer起到更好的作用。当你需要管理对象，并且这个对象持有的资源是通过本地方法获得的，这时会产生独特的异常。\n避免使用finalizer。\n\n\n\nsummary\n任务、线程、服务以及应用程序在生命周期结束时的问题，可能会导致向它们引入复杂的设计和实现。\nJava没有提供具有明显优势的机制来取消活动或终止线程。\n它提供了协作的中断机制，能够用来帮助取消，但是这将取决于你如何构建取消的协议，并是否能一致的使用该协议。\n使用FutureTask和Executor框架可以简化构建可取消的任务和服务。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","取消和关闭"]},{"title":"06.任务执行","url":"https://java4u.cn/Java并发编程/Java并发编程/06-任务执行/","content":"\n大多数并发应用程序是围绕执行**任务(task)**进行管理的。所谓任务就是抽象、离散的工作单元(unit of work)。把一个应用程序的工作分离到任务中，可以简化程序的管理；\n这种分离还在不同事务间划分了自然的分界线，可以方便程序在出现错误时进行恢复；\n同时这种分离还可以为并行工作提供一个自然的结构，有利于提高程序的并发性。\n\n6.1 在线程中执行任务\n围绕执行任务来管理应用程序时\n第一步要指明一个清晰的任务边界(task boundaries)\n理想情况下，任务是独立的活动：它的工作并不依赖于其他任务的状态。结果或者边界效应(side effect)。\n独立有利于并发性，如果能得到相应的处理器资源，独立的任务还可以并行执行。\n为了使调度与负载均衡并具有更好的灵活性，每项任务只占用处理器的一小部分资源。\n\n\n在正常的负载下，服务器应用程序应该兼具良好的吞吐量和快速的响应性。\n应用程序应该在负荷过载时平缓地劣化，而不应该负载一高就简单地以失败告终。为了达到这些目的，你要选择一个清晰的任务边界，并配合一个明确的任务执行策略\n大多数服务器应用程序都选择了下面这个自然的任务边界：\n单独的客户请求\n\n\nWeb服务器，邮件服务器，文件服务器，EJB容器和数据库服务器，这些服务器都接受远程客户通过网络连接发送的请求。将独立的请求作为任务边界，可以让任务兼顾独立性和适当的大小。\n例如，向邮件服务器提交一个消息后产生的结果，并不会被其他正在同时处理的消息所影响；而且，通常服务器只需用其总能力额很小一部分就能处理单一的消息。\n\n\n\n6.1.1 顺序地执行任务\n最简单的调度策略：在单一的线程中顺序地执行任务\n  //顺序化的WebServer\n  public class SingleThreadWebServer &#123;\n      public static void main(String[] args) throws IOException &#123;\n          ServerSocket socket = new ServerSocket(80);\n          while (true) &#123;\n              Socket connection = socket.accept();\n              handleRequest(connection);\n          &#125;\n      &#125;\n\n      private static void handleRequest(Socket connection) &#123;\n          // request-handling logic here\n      &#125;\n  &#125;\n\nSingleThreadWebServer简单正确，但一次只能处理一个请求，因此在生产环境中的执行效率很糟糕。\n\n一个Web请求的处理包括执行计算与进行I/O操作。福区前必须处理Socket I/O，以读取请求和写回响应，网络拥堵或连通性问题会导致这个操作阻塞。服务器还要处理文件 I/O、发送数据库请求，这些同样会引起操作的阻塞\n\n阻塞延迟了当前请求的完成\n阻止了需要被处理的等待请求\n线程等待I/O操作时，CPU处于闲置状态，导致资源利用率非常低。\n\n\n顺序化的处理：\n\n吞吐量差\n响应性差\n简单性或安全性上具有优势，比如GUI框架\n\n\n\n6.1.2 显式地为任务创建线程\n为了提供更好的响应性，可以为每个服务请求创建一个新的线程。\n  public class ThreadPerTaskWebServer &#123;\n      public static void main(String[] args) throws IOException &#123;\n          ServerSocket socket = new ServerSocket(80);\n          while (true) &#123;\n              final Socket connection = socket.accept();\n              Runnable task = new Runnable() &#123;\n                  public void run() &#123;\n                      handleRequest(connection);\n                  &#125;\n              &#125;;\n              new Thread(task).start();\n          &#125;\n      &#125;\n\n      private static void handleRequest(Socket connection) &#123;\n          // request-handling logic here\n      &#125;\n  &#125;\n\n结构类似单线程版本——主线程仍然不断地交替运行“接受外部连接”与“转发请求”。不同在于，主循环为每个连接都创建一个新线程以处理请求。由此得出结论如下：\n\n执行任务的负载已经脱离了主线程，这让主循环能够更迅速地重新开始等待下一个连接。\n并行处理任务，这使得多个请求可以同时得到服务\n任务处理代码必须是线程安全的，因为有多个任务会并发地调用它。\n\n\n在中等强度的负载水平下，“每任务每线程(thread-per-task)”方法是顺序化执行的良好改进。只要请求的到达速度尚未超出服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更大的吞吐量。\n\n\n6.1.3 无限制创建线程的缺点\n生产环境中，“每任务每线程”方法存在缺陷，尤其在需要大量的线程时会更加突出：\n线程生命周期的开销。线程的创建与关闭不是“免费”的。会消耗时间，消耗资源。\n资源消耗量。活动线程会消耗系统资源，尤其是内存。\n可运行的线程数多于可用处理器数，线程会空闲。大量空闲线程占用内存，给垃圾回收器带来压力。\n大量线程在竞争CPU资源时，还会产生其它的性能开销。\n\n\n稳定性。应该限制可创建线程的数目。限制的数目：\n依不同平台而定\n收到JVM的启动参数\nThread的构造函数中请求的栈大小的影响\n底层操作系统线程的限制\n\n\n\n\n在一定范围内，增加线程可以提高系统的吞吐量，一旦超过了这个范围，再创建更多的线程只会拖垮你的程序。故因设置一个范围来限制应用程序可以创建的线程数。\n“每任务每线程”方法的问题在于他没有对已创建线程的数量进行任何限制。像其他并发危险一样，无限制创建线程的行为可能在原型和开发阶段还能表现得运行良好，而当应用程序部署后，并运行于高负载下，它的问题才会暴露出来。\n对于一个服务器，我们希望它具有高可用性，而且在高负载下可以平缓地劣化。\n\n6.2 Executor框架\n任务是逻辑上的工作单元线程是使任务异步执行的机制。\n\n使用有界队列可以防止应用程序过载而耗尽内存。**线程池(Thread pool)**为线程管理带来了同样的好处。作为Executor框架的一部分，java.util.concurrent提供了一个灵活的线程池实现。在Java类库中，任务执行的首要抽象不是Thread，而是Executor。\n  //Executor接口\n  public interface Executor &#123;\n      void execute(Runnable command);\n  &#125;\n\nExecutor只是个简单的接口，但它却为一个灵活而且强大的框架创造了基础\n\n这个框架可以用于异步任务执行\n而且支持很多不同类型的任务执行策略\n还为任务提交和任务执行之间的解耦提供了标准的方法\n为使用Runnable描述任务提供了通用的方式\n\n\nExecutor的实现\n\n提供了对生命周期的支持以及钩子函数\n可以添加诸如统计收集、应用程序管理机制和监视器等扩展\n\n\nExecutor基于生产者-消费者模式。\n\n提交任务的执行是生产者(产生待完成的工作单元)\n执行任务的线程是消费者(消耗掉这些工作单元)\n\n\n如果要在你的程序中实现一个生产者-消费者的设计，使用Executor通常是最简单的方式\n\n\n6.2.1 示例：使用Executor实现的 Web Server\n以下示例用到了Executor标准实现之一，一个定长的线程池，可以容纳100个线程\n  //使用线程池的Web Server\n  public class TaskExecutionWebServer &#123;\n      private static final int NTHREADS = 100;\n      private static final Executor exec\n              = Executors.newFixedThreadPool(NTHREADS);\n\n      public static void main(String[] args) throws IOException &#123;\n          ServerSocket socket = new ServerSocket(80);\n          while (true) &#123;\n              final Socket connection = socket.accept();\n              Runnable task = new Runnable() &#123;\n                  public void run() &#123;\n                      handleRequest(connection);\n                  &#125;\n              &#125;;\n              exec.execute(task);\n          &#125;\n      &#125;\n\n      private static void handleRequest(Socket connection) &#123;\n          // request-handling logic here\n      &#125;\n  &#125;\n\nTaskExecutionWebServer中，通过使用Executor，将处理任务的提交与它的执行体进行了解耦\n\n\n6.2.2 执行策略\n将任务的提交与任务的执行体进行解耦，它的价值在于让你可以简单地为一个类给定的任务制定执行策略，并且保证后续的修改不至于太困难。一个执行策略指明了任务执行的“what，where，when，how”，具体包括：\n\n任务在什么线程中执行？\n任务以什么顺序执行(FIFO，LIFO，优先级)\n可以有多少个任务并发执行\n可以有多少个任务进入等待执行队列\n如果系统过载，需要放弃一个任务，应该挑选哪一个任务？另外，如何通知应用程序知道这一切呢？\n在一个任务的执行前与结束后，应该做什么处理？\n\n\n执行策略是资源管理工具。最佳策略取决于可用的计算资源和你对服务质量的需求。通过限制并发任务的数量，你能够确保应用程序不会由于资源耗尽而失败，大量任务也不会在争夺稀缺资源时出现性能问题。\n\n将任务的提交与任务的执行策略规则分离，有助于在部署阶段选择一个与当前硬件最匹配的执行策略。\n  无论何时当你看到这种形式的代码：\n  new Thread(runnable).start()\n  并且你可能最终希望获得一个更加灵活的执行策略时，请认真考虑使用Executor代替Thread\n\n\n6.2.3 线程池\n线程池管理一个工作者线程的同构池(homogeneous pool)。\n线程池是与工作队列(work queue)紧密绑定的。\n所谓工作队列，其作用是持有所有等待执行的任务。\n工作者线程的生活从此轻松起来：它从工作队列中获取下一个任务，执行它，然后回来继续等待另一个线程。\n\n\n\n\n\n在线程池中创建任务线程，这种方法有很多“每任务每线程”无法比拟的优势。\n\n重用存在的线程，而不是创建新的线程，这可以在处理多请求时抵消线程创建、消亡产生的开销\n在请求到达时，工作者线程通常已经存在，用于创建线程的等待时间并不会延迟任务的执行，因此提高了响应性。\n通常适当地调整线程池的大小，你可以得到足够多的线程以保持处理器忙碌，同时可以防止过多的线程相互竞争资源，导致应用程序耗尽内存或者失败。\n\n\n类库提供了一个灵活的线程池实现和一些有用的预设配置。你可以通过调用Executors中的某个静态方法来创建一个线程池：\n\nnewFixedThreadPool创建一个定长的线程池，每当提交一个任务就创建一个线程，直到达到池的最大长度，这时线程池会保持长度不再变化(如果一个线程由于非预期的Exception而结束，线程池会补充一个新的线程)。\nnewCacheThreadPool创建一个可缓存的线程池，如果当前线程池的长度超过了处理的需求时，它可以灵活地回收空闲的线程，当需求增加时，它可以灵活地添加新的线程，而不会对池的长度做任何限制。\nnewScheduleThreadPool创建一个定长的线程池，而且支持定时的以及周期性的任务执行，类似与Timer。\n\n\nnewFixedTreadPool和newCachedThreadPool两个工厂方法返回通用目的的ThreadPoolExecutor实例。直接使用ThreadPoolExecutor，也能创建更满足某些专有领域的executor。\n\n\n6.2.4 Executor的生命周期\nExecutor实现通常只是为执行任务而创建线程。但是JVM会在所有(非后台的，nondaemon)线程全部终止后才退出。因此，如果无法正确关闭Executor，将会阻止JVM的结束。\n\n关闭应用程序时，程序会出现很多种情况：\n\n最平缓的关闭(已经启动的任务全部完成而且没有再接到任何新的工作)\n最唐突的关闭(拔掉机房的电源)\n介于这两种极端情况之间的各种可能。\n\n\n为了解决这个执行服务的生命周期问题，ExecutorService接口扩展了Executor，并且添加了一些用于生命周期管理的方法(同时还有一些用于任务提交的便利方法)。\n      //ExecutorService中的生命周期方法以及用于任务提交的便利方法\n      public interface ExecutorService extends Executor &#123;\n\n          void shutdown();\n\n          List&lt;Runnable&gt; shutdownNow();\n\n          boolean isShutdown();\n\n          boolean isTerminated();\n\n          boolean awaitTermination(long timeout, TimeUnit unit)\n              throws InterruptedException;\n\n          &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);\n\n          &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);\n\n          Future&lt;?&gt; submit(Runnable task);\n\n          &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n              throws InterruptedException;\n\n          &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,long timeout, TimeUnit unit)\n              throws InterruptedException;\n\n          &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)\n              throws InterruptedException, ExecutionException;\n\n          &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,\n                          long timeout, TimeUnit unit)\n              throws InterruptedException, ExecutionException, TimeoutException;\n      &#125;\n\nExecutorService暗示了生命周期有3种状态：运行(running)**，关闭(shutting down)和终止(terminated)。ExecutorService最初创建后的初始状态是运行**状态。shutdown方法会启动一个平缓的关闭过程：停止接受新的任务，同时等待已经提交的任务完成——包括尚未开始执行的任务。shutdowNow方法会启动一个强制的关闭过程：尝试取消所有运行中的任务和排在队列中尚未开始的任务。\n\n在关闭后提交到ExecutorService中的任务，会被**拒绝执行处理器(rejected execution handler)**处理。拒绝执行处理器(ExecutorService的一种实现，ThreadPoolExecutor提供的，ExecutorService接口中的方法并不提供它)可能只是简单地放弃任务，也可能引起execute抛出一个未检查的RejectedExecutionException。一旦所有的任务全部完成后，ExecutorService会转入终止状态。你可以调用awaitTermination等待ExecutorService到达终止状态，也可以轮询检查isTerminated判断ExecutorService是否已经终止。通常shutdown会紧随awaitTerminated之后，这样可以同步地关闭ExecutorService的效果。\n\n以下代码是支持关闭操作的Web Server，它提供了生命周期支持的WebServer。关闭这个WebServer有两种方法：\n\n通过程序中调用stop\n\n经由客户端请求向WebServer发送一个特定格式的HTTP请求\n  public class LifecycleWebServer &#123;\n      private final ExecutorService exec = Executors.newCachedThreadPool();\n\n      public void start() throws IOException &#123;\n          ServerSocket socket = new ServerSocket(80);\n          while (!exec.isShutdown()) &#123;\n              try &#123;\n                  final Socket conn = socket.accept();\n                  exec.execute(new Runnable() &#123;\n                      public void run() &#123;\n                          handleRequest(conn);\n                      &#125;\n                  &#125;);\n              &#125; catch (RejectedExecutionException e) &#123;\n                  if (!exec.isShutdown())\n                      log(&quot;task submission rejected&quot;, e);\n              &#125;\n          &#125;\n      &#125;\n\n      public void stop() &#123;\n          exec.shutdown();\n      &#125;\n\n      private void log(String msg, Exception e) &#123;\n          Logger.getAnonymousLogger().log(Level.WARNING, msg, e);\n      &#125;\n\n      void handleRequest(Socket connection) &#123;\n          Request req = readRequest(connection);\n          if (isShutdownRequest(req))\n              stop();\n          else\n              dispatchRequest(req);\n      &#125;\n\n      interface Request &#123;\n      &#125;\n\n      private Request readRequest(Socket s) &#123;\n          return null;\n      &#125;\n\n      private void dispatchRequest(Request r) &#123;\n      &#125;\n\n      private boolean isShutdownRequest(Request r) &#123;\n          return false;\n      &#125;\n  &#125;\n\n\n\n\n6.2.5 延迟的、并具周期性的任务\nTimer工具管理任务的延迟执行(“100ms后执行任务”)以及周期执行(“每10ms执行一次该任务”)。但是，Timer存在缺陷，应该使用ScheduledThreadPoolExecutor作为代替品。可以通过构造函数或者通过newScheduledThreadPool工厂方法，创建一个ScheduledThreadPoolExecutor。\n\nTimer只创建唯一的线程来执行所有timer任务。如果一个timer任务的执行很耗时，会导致其他TimerTask的时效准确性出问题。\n\n如果TimerTask抛出未检查的异常，Timer将会产生无法预料的行为。会出现线程泄露的问题。\n  //Timer的混乱行为\n  public class OutOfTime &#123;\n      public static void main(String[] args) throws Exception &#123;\n          Timer timer = new Timer();\n          timer.schedule(new ThrowTask(), 1);\n          SECONDS.sleep(1);\n          timer.schedule(new ThrowTask(), 1);\n          SECONDS.sleep(5);\n      &#125;\n\n      static class ThrowTask extends TimerTask &#123;\n          public void run() &#123;\n              throw new RuntimeException();\n          &#125;\n      &#125;\n  &#125;\n\n\n6.3 寻找可强化的并行性\nExecutor框架让制定一个执行策略变得简单。不过想要使用Executor，你还必须能将你的任务描述为Runnable。\n在大多数服务器应用程序中，都存在一个明显的任务边界：单一的客户请求。但是，正如很多桌面应用程序一样，合理的任务边界有时并非如此显而易见。\n本节会为一个组件开发不同的版本，每个版本允许不同程度的并发性。\n\n6.3.1 示例：顺序执行的页面渲染器\n处理HTML文档最简单的方法是顺序处理。当遇到一个文本标签，就将它渲染到图像缓存里；当遇到一个图像的引用时，先通过网络获取它，然后也将它渲染到图像缓存里。不好的一点是，用户需要等待很长时间，直到呈现出所有的文本。\n\n另一种同样是顺序执行的方法会稍微好一点，它先渲染文本元素，并为图像预留出矩形的占位符；在完成了一趟处理文本后，程序返回到开始，并下载图像，将它们绘制到相应的占位符上。以下给出代码。\n\n下载图像总免不了等待I/O操作的完成，在这段时间里，CPU几乎不做任何工作。因为这种顺序执行的方法可能没有充分利用CPU，并且用户如果必须看到完整的文档的话，要等待更长的时间。通过将问题分散到独立的可以并发执行的任务中，我们能获得更好的CPU利用率和响应性。\n  //顺序地渲染页面元素\n  public abstract class SingleThreadRenderer &#123;\n      void renderPage(CharSequence source) &#123;\n          renderText(source);\n          List&lt;ImageData&gt; imageData = new ArrayList&lt;ImageData&gt;();\n          for (ImageInfo imageInfo : scanForImageInfo(source))\n              imageData.add(imageInfo.downloadImage());\n          for (ImageData data : imageData)\n              renderImage(data);\n      &#125;\n\n      interface ImageData &#123;\n      &#125;\n\n      interface ImageInfo &#123;\n          ImageData downloadImage();\n      &#125;\n\n      abstract void renderText(CharSequence s);\n      abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s);\n      abstract void renderImage(ImageData i);\n  &#125;\n\n\n6.3.2 可携带结果的任务：Callable和Future\nExecutor框架使用Runnable作为其任务的基本表达形式。但Runnable是个相当有限的抽象，run不能返回一个值或者抛出受检查的异常。\n\n很多任务都会引起严重的计算延迟——执行数据库查询，从网络上获取资源，进行复杂的计算。对于这些任务，Callable是更佳的抽象：它在主进入点(main entry point)——call——等待返回值，并为可能抛出的异常预先做好了准备。Executors包含了一些工具方法，可以把其他类型的任务封装成一个Callable，比如Runnable和java.security.PrivilegedAction\n\nRunnable和Callable描述的是抽象的计算型任务。通常这些任务有明确的开始点，最终会结束。一个Executor执行的任务的生命周期有4个阶段：\n\n创建\n提交\n开始\n完成\n\n\n由于任务的执行可能会花费很长时间，我们也希望可以取消一个任务。在Executor框架中，总可以取消已经提交但尚未开始的任务，但是对于已经开始的任务，只有它们响应中断，才可以取消。取消一个已经完成的任务没有影响。\n\nFuture描述了任务的生命周期，并提供了相关的方法来获得任务的结果、取消任务以及检验任务是否已经完成还是被取消。Future的规约中暗示了任务的生命周期是单向的，不能后退——就像ExecutorService的生命周期一样。一旦任务完成，它就永远停留在完成状态上。\n\n任务的状态(尚未开始，运行中，完成)决定了get方法的行为。get会阻塞直到它完成。如果任务抛出了一个Exception，get会将该异常封装为ExecutionException，然后重新抛出，如果任务被取消，get会抛出CancellationException。当抛出了ExecutionException时，可以用getCause重新获得被封装的原始异常。\n\n\n    public interface Callable&lt;V&gt; &#123;\n\n        V call() throws Exception;\n    &#125;\n\n\n    public interface Future&lt;V&gt; &#123;\n\n        boolean cancel(boolean mayInterruptIfRunning);\n\n        boolean isCancelled();\n\n        boolean isDone();\n\n        V get() throws InterruptedException, ExecutionException,CancellationException;\n\n        V get(long timeout, TimeUnit unit)\n            throws InterruptedException, ExecutionException,CancellationException, TimeoutException;\n    &#125;\n\n有很多中方法可以创建一个描述任务的Future。ExecutorService中的所有submit方法都返回一个Future，因此你可以将一个Runnable或一个Callable提交给executor，然后得到一个Future，用它来重新获得任务的执行结果，或是取消任务。\n\n你也可以显示地为给定的Runnable或Callable实例化一个FutureTask。(FutureTask实现了Runnable，所以既可以将它提交给Executor来执行，又可以直接调用run方法运行。)\n\n在Java 6 中，ExecutorService的所有实现都可以覆写AbstractExecutorService中的newTaskFor方法，以此控制Future的实例化，以及对应的已提交的Runnable或Callable。默认的实现仅仅创建一个新的FutureTask，正如下边代码所示：\n  //ThreadPoolExecutor中newTaskFor的默认实现  protected  RunnableFuture newTaskFor(Callable callable) {\n  return new FutureTask&lt;T&gt;(callable);\n  }\n\n将Runnable或Callable提交到Executor的行为，可以建立一个安全发布，以保证Runnable或Callable从提交线程暴露到最终执行任务的线程的过程是线程安全的。类似的，设置Future结果值的行为，也可以建立一个安全发布，以保证这个结果从计算它的线程暴露到通过get重获它的任何线程的过程是线程安全的。\n\n\n6.3.3 示例：使用Future实现页面渲染器\n为了使我们的页面渲染器具有更高的并发性\n\n第一步是将渲染过程分为两个任务，一个是渲染所有的文本，一个是下载所有的图像。\n\n\nCallable和Future可以帮助我们表述所有协同工作的任务之间的互交。\n  public abstract class FutureRenderer &#123;\n      private final ExecutorService executor = Executors.newCachedThreadPool();\n\n      void renderPage(CharSequence source) &#123;\n          final List&lt;ImageInfo&gt; imageInfos = scanForImageInfo(source);\n          Callable&lt;List&lt;ImageData&gt;&gt; task =\n                  new Callable&lt;List&lt;ImageData&gt;&gt;() &#123;\n                      public List&lt;ImageData&gt; call() &#123;\n                          List&lt;ImageData&gt; result = new ArrayList&lt;ImageData&gt;();\n                          for (ImageInfo imageInfo : imageInfos)\n                              result.add(imageInfo.downloadImage());\n                          return result;\n                      &#125;\n                  &#125;;\n\n          Future&lt;List&lt;ImageData&gt;&gt; future = executor.submit(task);\n          renderText(source);\n\n          try &#123;\n              List&lt;ImageData&gt; imageData = future.get();\n              for (ImageData data : imageData)\n                  renderImage(data);\n          &#125; catch (InterruptedException e) &#123;\n              // Re-assert the thread&#39;s interrupted status\n              Thread.currentThread().interrupt();\n              // We don&#39;t need the result, so cancel the task too\n              future.cancel(true);\n          &#125; catch (ExecutionException e) &#123;\n              throw launderThrowable(e.getCause());\n          &#125;\n      &#125;\n  &#125;\n\n在上边的FutureRenderer中，我们创建了一个Callable来下载所有的图像，并将这个Callable提交到ExecutorService。之后返回一个描述任务执行的Future；当到达需要所有图像的时间点时，主任务会等待Future.get调用的结果。如果幸运的话，我们请求的当时所有图像已经下载完成；即使没有，至少图像的下载已经预先开始了。\n\n“状态依赖性”是get的内在特性，它意味着调用者不必知晓任务的状态。任务提交和重获的结果的安全发布特性，确保了这个方法是线程安全的。包围Future.get的异常处理代码解决了两个可能出现的问题：\n\n任务遇到一个Exception\n调用get的线程在获得结果前被提前中断\n\n\nFutureRenderer允许渲染文本与下载图像数据并发地执行。当下载完所有的图像后，它们会被呈现到页面上。在让用户快速看到结果的这一方面，该方法是一种提高，同时该方法增强了并行性。然而，我们还可以做得更好。用户不必等到所有的图像都下载完成；它们或许更希望只要下载完一幅图像，就把它绘制到页面上，让人们看到。\n\n\n6.3.4 并行运行异类任务的局限性\n在上一个任务中，我们试图并行执行两个不同类型的任务——下载图像与渲染页面。但是，对于这种试图并行执行连续的异类任务(heterogeneous task)，以获得性能重大提升的方法，还需要谨慎对待。\n\nFutureTenderer中如果渲染文本的速度远远大于下载图像的，那么最终的性能与顺序执行版本的性能不会有很大的不同，反倒是代码复杂度大大提高了。我们使用两个线程可以得到最理想的结果是速度提高一倍。\n  大量相互独立且同类的任务进行并发处理，会将程序的任务量分配到不同的任务中，这样才能真正获得性能的提升。\n\n\n6.3.5 CompletionService：当Executor遇见BlockingQueue\n如果你向Executor提交了一个批处理服务，并且希望在它们完成后返回结果，为此你可以保存与每个任务相关联的Future，然后不断调用timeout为0的get，来检验Future是否完成。这样做固然可以，但却相当乏味。幸运的是，还有一种更好的方法：完成服务(completion service)。\nCompletionService整合了Executor和BlockingQueue的功能。你可以将Callable的任务提交给它去执行，然后使用类似于队列中的take和poll方法，在结果完整可用时获得这个结果，像一个打包的Future。ExecutorCompletionService是实现CompletionService接口的一个类，并将计算任务委托给一个Executor。\nExecutorCompletionService的实现是相当直观的。它在构造器里创建一个BlockingQueue，用它去保存完成的结果。计算完成时调用FutureTask中done方法。当提交了一个任务后，首先把这个任务包装为一个QueueingFuture，它是FutureTask的一个子类，然后覆写done方法，将结果置入BlockingQueue中，代码如下，take和poll委托给了BlockingQueue，它会在结果不可用时阻塞。  //ExecutorCompletionService使用的QueueingFuture类\n  private class QueueingFuture extends FutureTask&lt;Void&gt; &#123;\n      QueueingFuture(RunnableFuture&lt;V&gt; task) &#123;\n          super(task, null);\n          this.task = task;\n      &#125;\n      protected void done() &#123; completionQueue.add(task); &#125;\n      private final Future&lt;V&gt; task;\n  &#125;\n\n\n6.3.6 示例：使用CompletionService的页面渲染器\n使用CompletionService，可以从两方面提高页面渲染器的性能\n\n缩短总的运行时间\n提高响应性\n\n\n我们可以每需要下载一个图像，就创建一个独立的任务，并在线程池中执行它们，将顺序的下载过程转换为并行的：这能减少下载所有图像的总时间。而且从CompletionService中获取结果，只要任何一个图像下载完成，就立刻呈现，由此我们可以给用户提供一个更加动态和有更高响应性的用户界面。以下代码的Renderer演示了这个实现。\n  //使用CompletionService渲染可用的页面元素\n  public abstract class Renderer &#123;\n      private final ExecutorService executor;\n\n      Renderer(ExecutorService executor) &#123;\n          this.executor = executor;\n      &#125;\n\n      void renderPage(CharSequence source) &#123;\n          final List&lt;ImageInfo&gt; info = scanForImageInfo(source);\n          CompletionService&lt;ImageData&gt; completionService =\n                  new ExecutorCompletionService&lt;ImageData&gt;(executor);\n          for (final ImageInfo imageInfo : info)\n              completionService.submit(new Callable&lt;ImageData&gt;() &#123;\n                  public ImageData call() &#123;\n                      return imageInfo.downloadImage();\n                  &#125;\n              &#125;);\n\n          renderText(source);\n\n          try &#123;\n              for (int t = 0, n = info.size(); t &lt; n; t++) &#123;\n                  Future&lt;ImageData&gt; f = completionService.take();\n                  ImageData imageData = f.get();\n                  renderImage(imageData);\n              &#125;\n          &#125; catch (InterruptedException e) &#123;\n              Thread.currentThread().interrupt();\n          &#125; catch (ExecutionException e) &#123;\n              throw launderThrowable(e.getCause());\n          &#125;\n      &#125;\n\n      interface ImageData &#123;\n      &#125;\n\n      interface ImageInfo &#123;\n          ImageData downloadImage();\n      &#125;\n\n      abstract void renderText(CharSequence s);\n\n      abstract List&lt;ImageInfo&gt; scanForImageInfo(CharSequence s);\n\n      abstract void renderImage(ImageData i);\n\n  &#125;\n\n多个ExecutorCompletionService可以共享单一的Executor，因此一个明智的做法是创建一个ExecutorCompletionService，他对于特定的计算服务是私有的，然后共享一个公共的Executor。按照这种做法，CompletionService所扮演的批处理计算的句柄，在很大程度上是一样的。记录下提交给CompletionService的任务的个数，然后计算出获得了多少个已完成的结果，这样即使你使用的是共享的Executor，你也能知晓什么时候批处理任务的所有结果已经全部获得。\n\n\n6.3.7 为任务设置时限\n有时候如果一个活动无法在某个确定的时间内完成，那么它的结果就失效了，此时程序可以放弃该活动。举2个例子：\n\n一个Web Application会从外部的广告服务器上获取广告信息，但是如果应用程序在两秒内得不到响应，就会显示一个默认的信息，这样即使得不到广告信息也不会破坏站点的响应式需求。\n一个门户网站可以从多个数据源并行的获取数据，但是可能会在限定的时间内等待数据，到了时间就会只呈现现有的数据了。\n\n\n在预定时间内执行任务的主要挑战是，你要确保在得到答案，或者发现无法从任务中获得结果的这一过程所花费的时间，不会比预定的时间更长。Future.get的限时版本符合这个条件：它在结果准备好后立即返回，如果在时限内没有准备好，就会抛出TimeoutException。\n\n使用限时任务的第二个问题是，当它们超时后应该能够停止它们，这样才不会为继续计算一个无用的结果而浪费计算资源。为了达到这个目的，可以让任务自己严格管理它的预定时间，超时后就中止执行；或者也可以在超出时限后取消任务。Future再次派上了用场；如果一个限时的get抛出TimeoutException，你可以通过Future取消任务。如果你编写的任务是可取消的，就可以更灵敏地中止它，以避免消耗过多的资源。以下代码用到了这项技术。\n  //在预定时间内获取广告信息\n  public class RenderWithTimeBudget &#123;\n      private static final Ad DEFAULT_AD = new Ad();\n      private static final long TIME_BUDGET = 1000;\n      private static final ExecutorService exec = Executors.newCachedThreadPool();\n\n      Page renderPageWithAd() throws InterruptedException &#123;\n          long endNanos = System.nanoTime() + TIME_BUDGET;\n          Future&lt;Ad&gt; f = exec.submit(new FetchAdTask());\n          // Render the page while waiting for the ad\n          Page page = renderPageBody();\n          Ad ad;\n          try &#123;\n              // Only wait for the remaining time budget\n              long timeLeft = endNanos - System.nanoTime();\n              ad = f.get(timeLeft, NANOSECONDS);\n          &#125; catch (ExecutionException e) &#123;\n              ad = DEFAULT_AD;\n          &#125; catch (TimeoutException e) &#123;\n              ad = DEFAULT_AD;\n              f.cancel(true);\n          &#125;\n          page.setAd(ad);\n          return page;\n      &#125;\n\n      Page renderPageBody() &#123; return new Page(); &#125;\n\n      static class Ad &#123;\n      &#125;\n\n      static class Page &#123;\n          public void setAd(Ad ad) &#123; &#125;\n      &#125;\n\n      static class FetchAdTask implements Callable&lt;Ad&gt; &#123;\n          public Ad call() &#123;\n              return new Ad();\n          &#125;\n      &#125;\n\n  &#125;\n\n以上代码演示了限时的Future.get的一种典型应用。它生成一个混合了不同内容的页面，包括响应用户请求的内容和从广告服务器获得的广告内容。它将获取广告的任务提交给executor，然后计算剩余的文本页面内容，最后等待广告消息，直到预定时间耗尽。如果get超时，它会取消广告获取的任务，并使用默认的信息取代它。\n\n\n6.3.8 示例：旅游预定门户网站\n上一节中谈到的“预定时间”方法可以简单地推广到任意数量的任务上。\n\n考虑这样一个旅游预定门户网站：用户输入旅游的日期和其他条件，门户网站获取并显示多条航线、旅店或者汽车租赁公司的报价。\n\n根据不同的公司，获取报价的过程可能涉及到调用一个Web Service、访问数据库、执行一个EDI事务或者其他的机制。\n\n与其让页面的响应时间受限于最慢的一个响应，不如让页面只显示给定预定时间内获得的信息，这样更好些。\n\n对于没有及时响应的服务提供者，页面要么完全忽略它们，要么显示一个占位符\n  //在预定的时间内请求旅游报价\n  public class TimeBudget &#123;\n      private static ExecutorService exec = Executors.newCachedThreadPool();\n\n      public List&lt;TravelQuote&gt; getRankedTravelQuotes(TravelInfo travelInfo, Set&lt;TravelCompany&gt; companies,\n                                                     Comparator&lt;TravelQuote&gt; ranking, long time, TimeUnit unit)\n              throws InterruptedException &#123;\n          List&lt;QuoteTask&gt; tasks = new ArrayList&lt;QuoteTask&gt;();\n          for (TravelCompany company : companies)\n              tasks.add(new QuoteTask(company, travelInfo));\n\n          List&lt;Future&lt;TravelQuote&gt;&gt; futures = exec.invokeAll(tasks, time, unit);\n\n          List&lt;TravelQuote&gt; quotes =\n                  new ArrayList&lt;TravelQuote&gt;(tasks.size());\n          Iterator&lt;QuoteTask&gt; taskIter = tasks.iterator();\n          for (Future&lt;TravelQuote&gt; f : futures) &#123;\n              QuoteTask task = taskIter.next();\n              try &#123;\n                  quotes.add(f.get());\n              &#125; catch (ExecutionException e) &#123;\n                  quotes.add(task.getFailureQuote(e.getCause()));\n              &#125; catch (CancellationException e) &#123;\n                  quotes.add(task.getTimeoutQuote(e));\n              &#125;\n          &#125;\n\n          Collections.sort(quotes, ranking);\n          return quotes;\n      &#125;\n\n  &#125;\n\n  class QuoteTask implements Callable&lt;TravelQuote&gt; &#123;\n      private final TravelCompany company;\n      private final TravelInfo travelInfo;\n\n      public QuoteTask(TravelCompany company, TravelInfo travelInfo) &#123;\n          this.company = company;\n          this.travelInfo = travelInfo;\n      &#125;\n\n      TravelQuote getFailureQuote(Throwable t) &#123;\n          return null;\n      &#125;\n\n      TravelQuote getTimeoutQuote(CancellationException e) &#123;\n          return null;\n      &#125;\n\n      public TravelQuote call() throws Exception &#123;\n          return company.solicitQuote(travelInfo);\n      &#125;\n  &#125;\n\n  interface TravelCompany &#123;\n      TravelQuote solicitQuote(TravelInfo travelInfo) throws Exception;\n  &#125;\n\n  interface TravelQuote &#123;\n  &#125;\n\n  interface TravelInfo &#123;\n  &#125;\n\n\n\n以上代码使用限时版本的invokeAll，将多个任务提交到ExecutorService，并且获得其结果。invokeAll方法处理一个任务的容器，并返回一个Future的容器。两个容器具有相同的结构；invokeAll将Future添加到返回的容器中，这样可以使用任务容器的迭代器，从而调用者可以将它表现的Callable与Future关联起来。当所有任务都完成时、调用线程被中断时或者超过时限时，限时版本的invokeAll都会返回结果。超过时限后，任何尚未完成的任务都会被取消。作为invokeAll的返回值，每个任务要么正常地完成，要么被取消；客户端代码可以调用get或者isCancelled来查明是属于哪一种情况。\n\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","任务执行"]},{"title":"part_1","url":"https://java4u.cn/Java并发编程/Java并发编程/part-1/","content":"主要概念和规则\n可变状态　　所有并发问题都归结为如何协调和访问并发状态，可变状态越少，保证线程安全月容易\n尽量将域声明为final类型，除非它们的需要是可变的\n不可变对象天生是线程安全的。不可变对象极大地减轻了并发编程的压力。它们简单而且安全，可以在没有锁或者防御性复制的情况下自由地共享。\n封装使管理复杂度变得更可行。你固然可以存储于全局变量的数据来写一个线程安全类。但是你为什么要这样做？\n在对象中封装数据，让他们能够更加容易的保持不变；\n在对象中封装同步，使它能够更容易地遵守同步策略\n\n\n用锁来守护每一个可变变量\n对同一不变约束中的所有变量都使用相同的锁\n在运行复合操作期间持有锁\n在非同步的多线程情况下，访问可变变量的程序是存在隐患的。\n不要依赖于可以需要同步的小聪明\n在设计过程中就考虑线程安全。或者在文档中明确地说明它不是线程安全的。\n文档化你的同步策略\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发"]},{"title":"05.构建块","url":"https://java4u.cn/Java并发编程/Java并发编程/05-构建块/","content":"5.1 同步容器\n同步容器类包括两部分：\nVector和Hashtable，早期JDK的一部分\n以上两个的同系容器，在JDK1.2中才被加入的同步包装(wrapper)类\n这些类由Collections.synchronizedXXX工厂方法创建\n这些类通过封装它们的状态，并对每一个公共方法进行同步而实现了线程安全，这样一次只有一个线程能访问容器的状态\n\n\n\n\n\n5.1.1 同步容器出现的问题\n同步容器都是线程安全的，但对于复合操作，可能需要使用额外的客户端加锁(client-side locking)进行保护。这些复合操作包括：\n\n迭代(反复获取元素，直到获得容器中的最后一个元素)\n导航(navigation，根据一定的顺序寻找下一个元素)\n条件运算，比如”缺少即加入”，检查Map中是否存在关键字K，如果没有，就加入mapping(K,V)。\n\n\n操作Vector的复合操作可能导致混乱的结果\n  public static Object getLast(Vector list) &#123;\n      int lastIndex = list.size() - 1;\n      return list.get(lastIndex);\n  &#125;\n\n  public static void deleteLast(Vector list) &#123;\n      int lastIndex = list.size() - 1;\n      list.remove(lastIndex);\n  &#125;\n　　多线程环境下getLast方法可能会抛出ArrayIndexOutOfBoundsException异常。所以需要客户端加锁，使getLast和deleteLast成为原子操作。\n\n使用客户端加锁，对Vector进行复合操作\n  public static Object getLast(Vector list) &#123;\n      synchronized (list) &#123;\n          int lastIndex = list.size() - 1;\n          return list.get(lastIndex);\n      &#125;\n  &#125;\n\n  public static void deleteLast(Vector list) &#123;\n      synchronized (list) &#123;\n          int lastIndex = list.size() - 1;\n          list.remove(lastIndex);\n      &#125;\n  &#125;\n\n迭代不可靠问题同样可以通过在客户端加锁来解决，这要增加一些针对可伸缩性的开销。通过在迭代期间持有Vector锁，我们防止其他线程在迭代期间修改Vector。缺点是，我们同样完全阻止了其他线程在这一期间访问它，这削弱了并发性\n\n\n5.1.2 迭代器和ConcurrentModificationException\n对Collection进行迭代的标准方式是使用Iterator\n循环遍历过程中，其他线程并发修改容器时，使用迭代器不可避免的需要在迭代期间对容器加锁\n在设计同步容器返回的迭代器时，并没有考虑到并发修改的问题，它们是“及时失败(fail-fast)”的，意思是当它们察觉容器在迭代开始后被修改，会抛出一个未检查的ConcurrentModificationException\nConcurrentModificationException也可能出现在单线程的代码中；当对象并非通过Interator.remove，而是被直接从容器中删除时，就会出现这个情况\n有一些原因造成我们不愿意在迭代期间对容器上锁。其它线程访问容器，必须等待，这个时间有可能很长。\n迭代期间对容器加锁的一个替代方法是复制容器。因为复制是线程限制(thread-confined)的，没有其它的线程能够在迭代期间对其进行修改，这样消除了ConcurrentModificationException发生的可能性。(容器仍然需要在复制期间对自己加锁)。复制容器有性能开销。\n\n5.1.3 隐藏迭代器\n迭代隐藏在字符串的拼接中(不要这么做)\n  public class HiddenIterator &#123;\n      @GuardedBy(&quot;this&quot;) private final Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();\n\n      public synchronized void add(Integer i) &#123;\n          set.add(i);\n      &#125;\n\n      public synchronized void remove(Integer i) &#123;\n          set.remove(i);\n      &#125;\n\n      public void addTenThings() &#123;\n          Random r = new Random();\n          for (int i = 0; i &lt; 10; i++)\n              add(r.nextInt());\n          System.out.println(&quot;DEBUG: added ten elements to &quot; + set);\n      &#125;\n  &#125;\n\n容器的hashCode和equals方法也会间接地调用迭代。比如当容器本身作为一个元素时，或者作为另一个容器的key时。\n\ncontainsAll、removeAll、retainAll方法，以及把容器作为参数的构造函数，都会对容器进行迭代。所有这些对迭代的间接调用，都可能会引起ConcurrentModificationException\n\n\n5.2 并发容器\nJava 5.0通过提供几种并发的容器类来改进同步容器。同步容器通过对容器的所有状态进行串行访问，从而实现了它们的线程安全。代价是削弱了并发性，当多个线程共同竞争容器级的(collection-wide)锁时，吞吐量就会降低\n\n另一方面，并发容器是为多线程并发访问而设计的。\n\nJava 5.0 添加了ConcurrentHashMap来替代同步的哈希Map实现；\n当多数操作作为读取操作时，CopyOnWriteArrayList是List相应的同步实现。\n新的ConcurrentMap接口加入了对常见复合操作的支持，比如，缺少即加入、替换、条件删除\n\n\n用并发容器替换同步容器，这种做法以有很小的风险带来了可扩展性显著的提高。\n\nJava 5.0 同样添加了两个新的容器类型：Queue和BlockingQueue。\n\nQueue用来临时保存正在等待被进一步处理的一系列元素。JDK的几种实现有：\n\n传统的FIFO队列，ConcurrentLinkedQueue\n一个(非并发)具有优先级顺序的队列，PriorityQueue\n\n\nQueue的操作不会阻塞；队列为空，获取元素；队列满，插入操作阻塞，直到队列中存在可用空间。用在生产者消费者模式中\n\n正像ConcurrentHashMap作为同步的哈希Map的一个并发替代品，Java 6 中加入了ConcurrentSkipListMap和ConcurrentSkipListSet，用来作为同步的SortedMap和SortedSet的并发替代品\n\n\n\n\n5.2.1 ConcurrentHashMap\n在ConcurrentHashMap以前，程序使用一个公共锁同步每一个方法，并严格地限制只能有一个线程可以同时访问容器。\n\n而ConcurrentHashMap使用一个更加细化的锁机制，名叫分离锁。\n\n这个机制允许更深层次的共享访问。\n\n任意数量的读线程可以并发访问Map\n读者和写者也可以并发访问Map\n有限数量的写线程还可以并发修改Map\n\n\n结果是，为并发访问带来了更高的吞吐量，同时几乎没有损失单个线程访问的性能\n\nConcurrentHashMap与其他的并发容器一起，进一步改进了同步容器类：提供不会抛出ConcurrentModificationException的迭代器，因此不需要在容器迭代中加锁。\n\nConcurrentHashMap返回的迭代器具有弱一致性，而非“及时失败”的。\n\n弱一致性的迭代器可以容许并发修改，当迭代器被创建时，它会遍历已有的元素，并且可以（但不保证）感应到在迭代器被创建后，对容器的修改\n\n对整个Map进行操作的方法，比如size，isEmpty在容器并发特性上被轻微弱化。size值只是估计值，但这些方法在并发环境下几乎没用处，因为它们的目标是运动的。\n\n相反，应该保证对最重要的操作进行性能优化，get、put、remove等\n\n同步Map提供的一个特性是为独占的访问加锁，ConcurrentHashMap并没有实现。有必要使用同步Map的情景：\n\n原子化的加入一些映射(mapping)\n对元素进行若干次迭代，在这期间需要看到元素以同样的顺序出现\n\n\n如何权衡：\n\n大多数情况ConcurrentHashMap，带来更好的可伸缩性\n程序需要在独占访问中加锁时，使用同步Map\n\n\n\n5.2.2 Map附加的原子操作\nConcurrentHashMap不能在独占访问中被加锁，所有不能使用客户端加锁来创建新的原子操作。但是一些常见的复合操作，比如“缺少即加入”，“相等便移除(remove-if-equal)”，“相等便替换”，都已被实现为原子操作，并且这些操作已在ConcurrentMap接口中声明。\n\n    //ConcurrentMap接口\n    public interface ConcurrentMap&lt;K, V&gt; extends Map&lt;K, V&gt; &#123;\n        //只有当没有匹配到K的值时才插入\n        V putIfAbsent(K key, V value);\n        //只有当K与V匹配时才移除\n        boolean remove(Object key, Object value);\n        //只有当K与oldValue匹配时才移除\n        boolean replace(K key, V oldValue, V newValue);\n        //只有当K匹配某值时才取代\n        V replace(K key, V value);\n    &#125;\n5.2.3 CopyOnWriteArrayList\n同步List的一个并发替代品\n\n更好的并发性\n避免了在迭代期间对容器加锁和复制\n\n\n写入时复制(Copy-on-write)容器的线程安全性来源于这样一个事实，只要在有效的不可变对象被正确发布，那么访问它将不需要更多的同步。在每次修改时，它们会创建并重新发布一个新的容器拷贝，以此来实现可变性。写入时复制(Copy-on-write)容器的迭代器保留一个底层基础数组(the backing array)的引用。这个数组作为迭代器的起点，永远不会被修改，因此对它的同步只不过是为了确保数组内容的可见性。\n\n因此多个线程可以对这个容器进行迭代，并且不会受到另一个或多个想要修改容器的线程带来的干涉。\n\n写入时复制容器返回的迭代器不会抛出ConcurrentModificationException，并且返回的元素严格与迭代器创建时相一致，不会考虑后续的修改\n\n每次容器改变时复制基础数组需要一定的开销，特别是当容器比较大的时候；\n\n当对容器迭代操作的频率远远高于对容器修改的频率时，使用写入时复制容器是个合理的选择。\n\n这个准则准确描述了许多事件通知系统：递交一个通知需要迭代已注册的监听器，并调用其中每一个\n\n在多数情况下，注册和注销一个事件监听器的次数要比收到事件通知的次数少很多。\n\n\n5.3 阻塞队列和生产者-消费者模式\n阻塞队列(Blocking queue)提供了可阻塞的put和take方法，它们与可定时的offer和poll是等价的。\n\n如果Queue满了，put会被阻塞直到空间可用；如果Queue空，take会被阻塞直到有元素可用\n\nQueue的长度可用有限，也可以无限；无限的Queue永远不会充满，所以它的put方法永远不会阻塞。\n\n阻塞队列支持生产者-消费者模式。一个生产者-消费者设计分离了“识别需要完成的工作”和“执行工作”。\n\n该模式不会发现一个工作便立即处理，而是把工作置入一个任务(to do)清单中，以备后期处理\n\n该模式简化了开发，因为它解除了生产者类和消费者类之间相互依赖的代码。生产者和消费者以不同的或者变化的速度生产和消费着数据，生产者-消费着模式将这些活动解耦，因而简化了工作负荷的管理。\n\n最常见的生产者-消费者设计是将线程池与工作队列相结合\n\n阻塞队列简化了消费者的编码，因为take会保持阻塞直到可用数据出现。\n\n如果生产者产生工作的速度总是比消费者处理的速度快，那么应用程序的工作条目会排在一个没有边界的队列中，最终耗尽内存。\n\nput方法的阻塞特性大大简化了生产者的编码；如果使用一个有界队列，那么当队列充满的时候，生产者就会阻塞，暂不能生成更多的工作，从而给消费者时间来追赶进度。\n\n阻塞队列同样提供了一个offer方法，如果条目不能被加入到队列里，它会返回一个失败状态。这使得你能够创建更多灵活的策略来处理超负荷工作，比如：\n\n减轻负载\n序列化剩余工作条目并写入硬盘\n减少生产者线程\n用其他方法遏制生产者线程\n\n\n有界队列是强大的资源管理工具，用来建立可靠的应用程序：\n\n它们遏制那些产生过多工作量、具有威胁的活动，从而让你的程序在面对超负荷工作时更加健壮\n\n\n\n\n\n类库中包含一些BlockingQueue的实现，其中LinkedBlockingQueue和ArrayBlockingQueue是FIFO队列，与LinkedList和ArrayList相似，但是却拥有比同步List更好的并发性能。\nPriorityBlockingQueue是一个按优先级顺序排序的队列。可以比较元素本身的自然顺序(如果实现了Comparable接口)，也可以使用一个Comparator进行排序\nSynchronousQueue，不是一个真正的队列，因为它不会为队列元素维护任何存储空间。不过，它维护一个排队的线程清单，这些线程等待把元素加入(enqueue)队列或者（dequeue）队列。\n直接移交工作，减少了生产者和消费者之间移动数据的延迟时间\n比如把文件直接递给同事，而不是把文件发送到她的邮箱期待她一会可以得到此文件\n没有存储的能力，所以除非另一个线程已经准备好参与移交工作，否则put和take会一直阻止。\nSynchronousQueue这类队列只有在消费者充足的时候比较合适，它们总能为下一个任务做好准备\n\n\n\n5.3.1 实例：桌面搜索\n有一种类型的程序适合分解为生产者和消费者：扫描本地驱动器并归档文件，为之后的搜索建立索引的代理，这类似与Google Desktop或者Windows索引服务。\n\n文件查找和建立索引划分给不同的活动\n\nDiskCrawler表现了一个生产者任务，这个任务是搜索一个文件结构，找到符合给定标准的文件并把它们的名称放入工作队列\n\nIndexer展现消费者从队列中取出文件名称并制定索引的任务\n  import java.io.File;\n  import java.io.FileFilter;\n  import java.util.concurrent.*;\n  //桌面搜索应用程序中的生产者和消费者\n  public class ProducerConsumer &#123;\n      static class FileCrawler implements Runnable &#123;\n          private final BlockingQueue&lt;File&gt; fileQueue;\n          private final FileFilter fileFilter;\n          private final File root;\n\n          public FileCrawler(BlockingQueue&lt;File&gt; fileQueue,\n                             final FileFilter fileFilter,\n                             File root) &#123;\n              this.fileQueue = fileQueue;\n              this.root = root;\n              this.fileFilter = new FileFilter() &#123;\n                  public boolean accept(File f) &#123;\n                      return f.isDirectory() || fileFilter.accept(f);\n                  &#125;\n              &#125;;\n          &#125;\n\n          private boolean alreadyIndexed(File f) &#123;\n              return false;\n          &#125;\n\n          public void run() &#123;\n              try &#123;\n                  crawl(root);\n              &#125; catch (InterruptedException e) &#123;\n                  Thread.currentThread().interrupt();\n              &#125;\n          &#125;\n\n          private void crawl(File root) throws InterruptedException &#123;\n              File[] entries = root.listFiles(fileFilter);\n              if (entries != null) &#123;\n                  for (File entry : entries)\n                      if (entry.isDirectory())\n                          crawl(entry);\n                      else if (!alreadyIndexed(entry))\n                          fileQueue.put(entry);\n              &#125;\n          &#125;\n      &#125;\n\n      static class Indexer implements Runnable &#123;\n          private final BlockingQueue&lt;File&gt; queue;\n\n          public Indexer(BlockingQueue&lt;File&gt; queue) &#123;\n              this.queue = queue;\n          &#125;\n\n          public void run() &#123;\n              try &#123;\n                  while (true)\n                      indexFile(queue.take());\n              &#125; catch (InterruptedException e) &#123;\n                  Thread.currentThread().interrupt();\n              &#125;\n          &#125;\n\n          public void indexFile(File file) &#123;\n              // Index the file...\n          &#125;;\n      &#125;\n\n      private static final int BOUND = 10;\n      private static final int N_CONSUMERS = Runtime.getRuntime().availableProcessors();\n\n      public static void startIndexing(File[] roots) &#123;\n          BlockingQueue&lt;File&gt; queue = new LinkedBlockingQueue&lt;File&gt;(BOUND);\n          FileFilter filter = new FileFilter() &#123;\n              public boolean accept(File file) &#123;\n                  return true;\n              &#125;\n          &#125;;\n\n          for (File root : roots)\n              new Thread(new FileCrawler(queue, filter, root)).start();\n\n          for (int i = 0; i &lt; N_CONSUMERS; i++)\n              new Thread(new Indexer(queue)).start();\n      &#125;\n  &#125;\n\n\n\n生产者-消费者模式带来的性能方面的提高\n\n生产者受限于I/O，消费者受限于CPU\n\n\n5.3.2 连续的线程限制\n在java.util.concurrent中实现的阻塞队列，全部都包含充分的内部同步，从而能安全地将对象从生产者线程发布到消费者线程。\n对于可变对象，生产者-消费者设计和阻塞队列一起，为生产者和消费者之间移交对象所有权提供了**连续的线程限制(serial thread confinement)**。一个线程约束的对象完全由单一线程所有，但是所有权可以通过安全的发布被“转移”，这样其他线程只有唯一一个能够得到访问这个对象的权限，并且保证移交之后源线程不能访问它。\n\n5.3.3 双端队列和窃取工作\nJava 6 同样新增了两个容器类型，Deque和BlockingDeque，它们分别扩展了Queue和BlockingQueue。\nDeque是一个双端队列，允许高效地在头和尾分别进行插入和移除。实现类是ArrayDeque和LinkedBlockingDeque\n双端队列与一种叫做窃取工作(work stealing)的模式相关联。\n窃取工作中，每一个消费者都有一个自己的双端队列。\n如果一个消费者完成了自己双端队列中的全部工作，它可以偷取其他消费者的双端队列中的末尾任务。\n因为工作者线程并不会竞争一个共享的任务队列，所以窃取工作模式比传统的生产者-消费者设计有更佳的可伸缩性\n大多数时候它们访问自己的双端队列，减少竞争\n当一个工作者必须要访问另一个队列时，它会从尾部截取，而不是头部，从而进一步降低了对双端队列的争夺\n\n\n窃取工作适用于解决消费者和生产者同体的问题——当运行到一个任务的某单元时，可能会识别出更多的任务。\n比如，Web Crawler处理一个页面时，通常会发现有更多页面可以搜索。\n当双端队列为空时，会去其他队列的队尾寻找新的任务，这样能确保每一个线程都保持忙碌状态。\n\n\n\n5.4 阻塞和可中断的方法\n线程可能会因为几种原因被阻塞或暂停：\n\n等待I/O操作结束\n等待获得一个锁，\n等待从Thread.sleep中唤醒\n等待另一个线程的计算结果\n\n\n当一个线程阻塞时，它通常被挂起，并被设置成线程阻塞的某个状态(BLOCKED、WAITING、或是TIMED_WAITING)。\n\n当一个方法能够抛出InterruptedException的时候，是在告诉你这个方法是一个可阻塞方法。\n\nThread提供了interrupt方法，用来中断一个线程，或者查询某线程是否已经被中断。每一个线程都有一个布尔类型的属性，这个属性代表了线程的中断状态；中断线程时需要设置这个值。\n\n中断是一种协作机制。\n\n一个线程不能迫使其他线程停止正在做的事情，或者去做其他事情\n当线程A中断B时，A仅仅是要求B在达成某个方便停止的关键点时，停止正在做的事情——如果它这样做是正确的。\n从时间角度来看，响应中断的阻塞方法，可以更容易地取消耗时的活动。\n\n\n当你在代码中调用了一个会抛出InterruptedException的方法时，你自己的方法也就成为了一个阻塞方法，要为响应中断作好准备。类库代码中有两种基本选择：\n\n传递InterruptedException。传递给调用者。\n恢复中断。代码是Runnable的一部分，必须捕获InterruptedException，并且在当前线程中通过调用interrupt从中断中恢复，这样调用栈中更高层的代码可以发现中断已经发生。\n\n\n不应该捕获InterruptedException，但不作任何响应，因为这样会丢失线程中断的证据，从而剥夺了上层栈的代码处理中断的机会。\n\n只有一种情况允许掩盖中断：你扩展了Thread，并因此控制了所有处于调用栈上层的代码。\n  //恢复中断状态，避免掩盖中断\n  public class TaskRunnable implements Runnable &#123;\n      BlockingQueue&lt;Task&gt; queue;\n\n      public void run() &#123;\n          try &#123;\n              processTask(queue.take());\n          &#125; catch (InterruptedException e) &#123;\n              // restore interrupted status\n              Thread.currentThread().interrupt();\n          &#125;\n      &#125;\n\n      void processTask(Task task) &#123;\n          // Handle the task\n      &#125;\n\n      interface Task &#123;\n      &#125;\n  &#125;\n\n\n5.5 Synchronizer\nSynchronizer是一个对象，它根据本身的状态调节线程的控制流。\n阻塞队列可以扮演一个Synchronizer的角色\n信号量(semaphore)\n关卡(barrier)\n闭锁(latch)\n\n\n\n5.5.1 闭锁\n闭锁是一种Synchronizer，它可以延迟线程的进度直到线程到达**终止(terminal)**状态。\n\n一个闭锁工作起来就像一道大门：直到闭锁达到终点状态之前，门一直是关闭的，没有线程能够通过，在终点状态到来的时候，门开了，允许所有线程通过。\n\n一旦闭锁到达了终点终点状态，它就不能够再改变状态了，所以它会永远爆出敞开状态。\n\n闭锁用来确保特定活动直到其他的活动完成后才发生，比如：\n\n确保一个计算不会执行，直到它需要的资源被初始化。一个二元闭锁(两个状态)可以用来表达“资源R已经被初始化”，并且所有需要用到R的活动首先都要在闭锁中等待。\n确保一个服务不会开始，直到它依赖的其他服务都已经开始。每一个服务会包含一个相关的二元闭锁；开启服务S会首先等待闭锁S中所依赖的其他服务，在启动结束后，会释放闭锁S，这样所有依赖S的服务也可以开始处理了。\n等待，直到活动的所有部分都为继续处理作好充分准备，比如在多玩家的游戏中的所有玩家是否都准备就绪。这样的闭锁会在所有玩家准备就绪时，达到终点状态。\n\n\nCountDownLatch是一个灵活的闭锁实现，用于上述各种情况\n\n允许一个时间集的发生\n闭锁的状态包括一个计数器，初始化为一个正数，用来表现需要等待的事件数。\ncountDown方法对计数器做减操作，表示一个事件已经发生了，而await方法等待计数器达到0，此时所有需要等待的事件都已发生。\n如果计数器入口时值为非-，await会一直阻塞直到计数器为0，或者等待线程中断以及超时。\n\n\nTestHarness阐释了闭锁的两种常见用法。\n\nTestHarness创建了一些线程，并发地执行给定的任务\n\n它使用两个闭锁，一个“开始阀门”和一个“结束阀门”。这个开始阀门将计数器初始化为1.结束阀门将计数器初始化为工作线程的数量。\n\n每一个工作线程要做的第一件事情是等待开始阀门打开；这样能确保直到所有线程都做好准备时，才开始工作。每个线程的最后一个工作是为结束阀门减1：这样做使控制线程有效地等待，直到最后一个工作线程完成任务，这样就能计算整个的用时了。        \n  //在时序测试中，使用CountDownLatch来启动和停止线程\n  public class TestHarness &#123;\n      public long timeTasks(int nThreads, final Runnable task)\n              throws InterruptedException &#123;\n          final CountDownLatch startGate = new CountDownLatch(1);\n          final CountDownLatch endGate = new CountDownLatch(nThreads);\n\n          for (int i = 0; i &lt; nThreads; i++) &#123;\n              Thread t = new Thread() &#123;\n                  public void run() &#123;\n                      try &#123;\n                          startGate.await();\n                          try &#123;\n                              task.run();\n                          &#125; finally &#123;\n                              endGate.countDown();\n                          &#125;\n                      &#125; catch (InterruptedException ignored) &#123;\n                      &#125;\n                  &#125;\n              &#125;;\n              t.start();\n          &#125;\n\n          long start = System.nanoTime();\n          startGate.countDown();\n          endGate.await();\n          long end = System.nanoTime();\n          return end - start;\n      &#125;\n  &#125;\n\n\n\n\n5.5.2 FutureTask\nFutureTask同样可以作为闭锁。（FutureTask的实现描述了一个抽象的可携带结果的计算）\n\nFutureTask的计算是通过Callable实现的，它等价于一个可携带结果的Runnable，并且有3个状态：等待，运行和完成。完成包括所有计算以任意的方式结束，包括正常结束、取消和异常。一旦FutureTask进入完成状态，它会永远停止在这个状态上。\n\nFuture.get的行为依赖于任务的状态。如果他已经完成，get可以立即得到返回结果，否则会被阻塞直到任务转入完成状态，然后会返回结果或抛出异常。FutureTask把计算的结果从运行计算的线程传送到需要这个结果的线程；FutureTask的规约保证了这种传递建立在结果的安全发布基础之上。\n\nExecutor框架利用FutureTask来完成异步任务，并可以用来进行任何潜在的耗时计算，而且可以在真正需要计算结果之前就启动它们开始计算。\n\n以下的PreLoader使用了FutureTask来执行一个代价昂贵的计算，结果稍后会被用到；尽早开始计算，你可以减少等待结果所需要花费的时间。\n  //使用FutureTask预载稍后需要的数据\n  public class Preloader &#123;\n      ProductInfo loadProductInfo() throws DataLoadException &#123;\n          return null;\n      &#125;\n\n      private final FutureTask&lt;ProductInfo&gt; future =\n          new FutureTask&lt;ProductInfo&gt;(new Callable&lt;ProductInfo&gt;() &#123;\n              public ProductInfo call() throws DataLoadException &#123;\n                  return loadProductInfo();\n              &#125;\n          &#125;);\n      private final Thread thread = new Thread(future);\n\n      public void start() &#123; thread.start(); &#125;\n\n      public ProductInfo get()\n              throws DataLoadException, InterruptedException &#123;\n          try &#123;\n              return future.get();\n          &#125; catch (ExecutionException e) &#123;\n              Throwable cause = e.getCause();\n              if (cause instanceof DataLoadException)\n                  throw (DataLoadException) cause;\n              else\n                  throw LaunderThrowable.launderThrowable(cause);\n          &#125;\n      &#125;\n\n      interface ProductInfo &#123;\n      &#125;\n  &#125;\n\n  class DataLoadException extends Exception &#123; &#125;\n\n\n5.5.3 信号量\n计数信号量（Counting semaphore）用来控制能够同时访问某特定资源的活动的数量，或者同时执行某一给定操作的数量。\n\n计数信号量可以用来实现资源池或者给一个容器限定边界\n\n一个Semaphore管理一个有效的许可(permit)集；许可的初始量通过构造函数传递给Semaphore。活动能够获得许可（只要还有剩余许可），并在使用之后释放许可。如果已经没有可用的许可，那么acquire会被阻塞，直到有可用的为止(或者直到被中断或者操作超时)。release方法向信号量返回一个许可。计算信号量的一种退化形式是二元信号量：一个计数初始值为1的Semaphore。二元信号量可用作**互斥(mutex)**锁，它有不可重入锁的语意；谁拥有这个唯一的许可，就拥有了互斥锁。\n\n信号量可以用来实现资源池，比如数据库连接池。有一个定长的池，当它为空时，你向它请求资源会失败。构建这种池很容易，然而当池为空时，你真正需要做的是阻塞它，然后在它不空时，再次解除阻塞。如果你以池的大小初始化一个Semaphore，在你从池中获取资源之前，你应该调用acquire方法获取一个许可，调用release把许可放回资源池。acquire会一直阻塞，直到池不再为空。\n\n可以使用Semaphore把任何容器转化为有界的阻塞容器，像如下的BoundedHashSet所示的一样。信号量被初始化为容器所期望容量的最大值。add操作在向底层容器添加条目之前，需要先获取一个许可。事实上，如果add操作没有能加入任何东西，它会立刻释放一个许可。同样，一个成功的remove操作释放一个许可，使更多的元素能够加入其中。底层的Set实现并不知道边界在哪里；这是由BoundedHashSet控制的。\n  //使用信号量来约束容器\n  public class BoundedHashSet &lt;T&gt; &#123;\n      private final Set&lt;T&gt; set;\n      private final Semaphore sem;\n\n      public BoundedHashSet(int bound) &#123;\n          this.set = Collections.synchronizedSet(new HashSet&lt;T&gt;());\n          sem = new Semaphore(bound);\n      &#125;\n\n      public boolean add(T o) throws InterruptedException &#123;\n          sem.acquire();\n          boolean wasAdded = false;\n          try &#123;\n              wasAdded = set.add(o);\n              return wasAdded;\n          &#125; finally &#123;\n              if (!wasAdded)\n                  sem.release();\n          &#125;\n      &#125;\n\n      public boolean remove(Object o) &#123;\n          boolean wasRemoved = set.remove(o);\n          if (wasRemoved)\n              sem.release();\n          return wasRemoved;\n      &#125;\n  &#125;\n\n\n5.5.4 关卡\n闭锁是一次性使用的对象；一旦进入到最终状态，就不能被重置。\n\n关卡(barrier)类似于闭锁，它们都能够阻塞一组线程，直到某些事件发生。与闭锁不同在于，所有线程必须同时到达关卡点，才能继续处理。\n\n闭锁等待的是事件\n关卡等待的是其他线程\n\n\n关卡实现的协议，就像一些家庭成员指定商场中的集合地点：我们每个人6点在麦当劳见，到了以后不见不散，之后我们再决定接下来做什么。\n\nCyclicBarrier允许一个给定数量的成员多次几种在一个关卡点，这在并行迭代算法中非常有用，这个算法会把一个问题拆分成一系列相互独立的子问题。当线程到达关卡点时，调用await，await会被阻塞，直到所有线程都到达关卡点。如果所有线程到达了关卡点，关卡就被成功地突破，这样所有线程都被释放，关卡会重置以备下一次使用。如果对await调用超时，或者阻塞中的线程被中断，那么关卡就被认为是失败的，所有对await未完成的调用都通过BrokenBarrierException终止。如果成功地通过关卡，await为每一个线程返回唯一的到达索引号，可以用它来“选举”产生一个领导，在下一次迭代中承担一些特殊工作。CyclicBarrier也允许你向构造函数传递一个**关卡行为(barrier action)**；这是一个Runnable，当成功通过关卡的时候，会(在一个子任务线程中)执行，但是在阻塞线程被释放之前是不能执行的。\n\n关卡通常被用来模拟这种情况：\n\n一个步骤的计算可以并行完成，但是要求必须完成所有与一个步骤相关的工作后才能进入下一步。\n\n\n以下的CellularAutomata演示了使用关卡来计算一个细胞的自动化模拟，比如Conway’s的生命游戏。\n  //在一个细胞的自动系统中用CyclicBarrier协调计算\n  public class CellularAutomata &#123;\n      private final Board mainBoard;\n      private final CyclicBarrier barrier;\n      private final Worker[] workers;\n\n      public CellularAutomata(Board board) &#123;\n          this.mainBoard = board;\n          int count = Runtime.getRuntime().availableProcessors();\n          this.barrier = new CyclicBarrier(count,\n                  new Runnable() &#123;\n                      public void run() &#123;\n                          mainBoard.commitNewValues();\n                      &#125;&#125;);\n          this.workers = new Worker[count];\n          for (int i = 0; i &lt; count; i++)\n              workers[i] = new Worker(mainBoard.getSubBoard(count, i));\n      &#125;\n\n      private class Worker implements Runnable &#123;\n          private final Board board;\n\n          public Worker(Board board) &#123; this.board = board; &#125;\n          public void run() &#123;\n              while (!board.hasConverged()) &#123;\n                  for (int x = 0; x &lt; board.getMaxX(); x++)\n                      for (int y = 0; y &lt; board.getMaxY(); y++)\n                          board.setNewValue(x, y, computeValue(x, y));\n                  try &#123;\n                      barrier.await();\n                  &#125; catch (InterruptedException ex) &#123;\n                      return;\n                  &#125; catch (BrokenBarrierException ex) &#123;\n                      return;\n                  &#125;\n              &#125;\n          &#125;\n\n          private int computeValue(int x, int y) &#123;\n              // Compute the new value that goes in (x,y)\n              return 0;\n          &#125;\n      &#125;\n\n      public void start() &#123;\n          for (int i = 0; i &lt; workers.length; i++)\n              new Thread(workers[i]).start();\n          mainBoard.waitForConvergence();\n      &#125;\n\n      interface Board &#123;\n          int getMaxX();\n          int getMaxY();\n          int getValue(int x, int y);\n          int setNewValue(int x, int y, int value);\n          void commitNewValues();\n          boolean hasConverged();\n          void waitForConvergence();\n          Board getSubBoard(int numPartitions, int index);\n      &#125;\n  &#125;\n\nExchanger是关卡的另一种形式，它是一种两步关卡，在关卡点会交换数据。当两方进行的活动不对称时，Exchanger是非常有用的，比如当一个线程向缓冲区写入一个数据，这时另一个线程充当消费者使用这个数据：这些线程可以使用Exchanger进行会面，并用完整的缓冲与空缓冲进行交换。当两个线程通过Exchanger交换对象时，交换为双方的对象建立了一个安全的发布。\n\n交换的时机取决于应用程序的响应需求。\n\n最简单的方案是当写入任务的缓冲写满时就发生交换，并且当清除任务的缓冲清空后也发生交换；这样做使交换的次数最少，但是如果新数据的到达率不可预测的话，处理一些数据会发生延迟。\n另一个方案是，缓冲满了就发生交换，但是当缓冲部分充满却已经存在了特定长的时间时，也会发生交换。\n\n\n\n5.6 为计算结果建立高效、可伸缩的高速缓存\n几乎每一个服务器都使用某种形式的高速缓存。复用已有的计算结果可以缩短等待时间，提高吞吐量，代价是占用更多的内存。\n\n我们将开发一个高效的、可伸缩的高速缓存，为一个昂贵的函数保存计算结果。\n\n让我们从最明显的方案开始——一个简单的HashMap——之后着眼于它在并发方面的劣势，并且讨论如何解决。\n\n以下的Computable&lt;A,V&gt;接口描述了一个功能，输入类型是A，输出结果的类型是V。ExpensiveFunction实现了Computable，需要花很长时间来计算结果，我们喜欢创建一个Computable包装器，使它记住之前的计算结果，并封装缓存步骤(这项技术被称为备忘录memoization)\n  //尝试使用HashMap和同步来初始化缓存\n  public class Memoizer1 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;\n      @GuardedBy(&quot;this&quot;) private final Map&lt;A, V&gt; cache = new HashMap&lt;A, V&gt;();\n      private final Computable&lt;A, V&gt; c;\n\n      public Memoizer1(Computable&lt;A, V&gt; c) &#123;\n          this.c = c;\n      &#125;\n\n      public synchronized V compute(A arg) throws InterruptedException &#123;\n          V result = cache.get(arg);\n          if (result == null) &#123;\n              result = c.compute(arg);\n              cache.put(arg, result);\n          &#125;\n          return result;\n      &#125;\n  &#125;\n\n\n    interface Computable &lt;A, V&gt; &#123;\n        V compute(A arg) throws InterruptedException;\n    &#125;\n\n    class ExpensiveFunction\n            implements Computable&lt;String, BigInteger&gt; &#123;\n        public BigInteger compute(String arg) &#123;\n            // after deep thought...\n            return new BigInteger(arg);\n        &#125;\n    &#125;\n\nMemoizer1做了第一种尝试：使用HashMap存储前面的计算结果。compute方法首先检查期待的结果是否已经在缓存中，如果有则返回之前计算的数值。否则，会进行计算并返回之前结果存储在HashMap中。\n\nHashMap不是线程安全，所以同步了整个compute方法。这保证了线程安全，但是却带来一个明显的可伸缩性问题：一次只有一个线程能够执行compute。如果另外一个线程正在忙于计算结果，其他调用compute的线程可能被阻塞很长时间。如果有多个线程都在排队等待尚未计算出来的结果，那么事实上，compute可能会比不使用备忘录形式花费更长的时间。这不是我们希望通过缓存得到的性能优化结果。\n\n以下代码用ConcurrentHashMap取代HashMap，改进了这种糟糕的并发行为。\n  //用ConcurrentHashMap取代HashMap\n  public class Memoizer2 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;\n      private final Map&lt;A, V&gt; cache = new ConcurrentHashMap&lt;A, V&gt;();\n      private final Computable&lt;A, V&gt; c;\n\n      public Memoizer2(Computable&lt;A, V&gt; c) &#123;\n          this.c = c;\n      &#125;\n\n      public V compute(A arg) throws InterruptedException &#123;\n          V result = cache.get(arg);\n          if (result == null) &#123;\n              result = c.compute(arg);\n              cache.put(arg, result);\n          &#125;\n          return result;\n      &#125;\n  &#125;\n\nMemoizer2 比 Memoizer1具有更好的并发性：多线程可以真正并发地使用它了。但是作为高速缓存仍然存在缺陷：\n\n当两个线程同时调用compute时，存在一个漏洞，会造成它们计算相同的值\n\n\n我们希望无论用什么方法，能够表现出“线程X正在计算f(27)”，这样如果另一个线程到达并查找f(27)时，它能够判断出最有效的方法是等待线程X，直到线程结束，然后动动嘴“嘿，f(27)的结果是多少？”。\n\n有一个类可以做这些事：FutureTask。FutureTask代表了一个计算的过程，可能已经结束，也可能正在运行中。FutureTask.get只要结果可用，就会立刻将结果返回；否则它会一直阻塞，直到结果被计算出来，并返回\n\n以下的Memoizer3为缓存的值重新定义可存储Map，用ConcurrentHashMap&lt;A,Future&gt;取代了ConcurrentHashMap&lt;A, V&gt;。Memoizer3首先检查一个相应的计算是否已经开始，(Memoizer2与它相反，它判断计算是否完成)。如果不是，就创建一个FutureTask，把它注册到Map中，并开始计算；如果是，那么它会等待正在进行的计算。结果可能很快就得到，或者正在运算的过程中——但是这对于调用者Future.get来说是透明的。\n  //用FutureTask记录包装器\n  public class Memoizer3 &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;\n      private final Map&lt;A, Future&lt;V&gt;&gt; cache\n              = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();\n      private final Computable&lt;A, V&gt; c;\n\n      public Memoizer3(Computable&lt;A, V&gt; c) &#123;\n          this.c = c;\n      &#125;\n\n      public V compute(final A arg) throws InterruptedException &#123;\n          Future&lt;V&gt; f = cache.get(arg);\n          if (f == null) &#123;\n              Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123;\n                  public V call() throws InterruptedException &#123;\n                      return c.compute(arg);\n                  &#125;\n              &#125;;\n              FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);\n              f = ft;\n              cache.put(arg, ft);\n              ft.run(); // call to c.compute happens here\n          &#125;\n          try &#123;\n              return f.get();\n          &#125; catch (ExecutionException e) &#123;\n              throw LaunderThrowable.launderThrowable(e.getCause());\n          &#125;\n      &#125;\n  &#125;\n\nMemoizer3近乎完美，但有个缺陷：\n\n两个线程可能同时计算相同的值。这个漏洞因为compute中的if代码块是非原子(nonatomic)的检查再运行序列，仍然存在这个可能：\n\n两个线程几乎同一时间调用compute计算相同的值，双方都没有在缓存中找到期望的值，并都开始计算。\n\n\n这个问题是因为复合操作(缺少即加入)运行在底层的map中，不能加锁来使它原子化。利用putIfAbsent方法，可消除这个缺陷\n  //Memoizer最终实现\n  public class Memoizer &lt;A, V&gt; implements Computable&lt;A, V&gt; &#123;\n      private final ConcurrentMap&lt;A, Future&lt;V&gt;&gt; cache\n              = new ConcurrentHashMap&lt;A, Future&lt;V&gt;&gt;();\n      private final Computable&lt;A, V&gt; c;\n\n      public Memoizer(Computable&lt;A, V&gt; c) &#123;\n          this.c = c;\n      &#125;\n\n      public V compute(final A arg) throws InterruptedException &#123;\n          while (true) &#123;\n              Future&lt;V&gt; f = cache.get(arg);\n              if (f == null) &#123;\n                  Callable&lt;V&gt; eval = new Callable&lt;V&gt;() &#123;\n                      public V call() throws InterruptedException &#123;\n                          return c.compute(arg);\n                      &#125;\n                  &#125;;\n                  FutureTask&lt;V&gt; ft = new FutureTask&lt;V&gt;(eval);\n                  f = cache.putIfAbsent(arg, ft);\n                  if (f == null) &#123;\n                      f = ft;\n                      ft.run();\n                  &#125;\n              &#125;\n              try &#123;\n                  return f.get();\n              &#125; catch (CancellationException e) &#123;\n                  cache.remove(arg, f);\n              &#125; catch (ExecutionException e) &#123;\n                  throw LaunderThrowable.launderThrowable(e.getCause());\n              &#125;\n          &#125;\n      &#125;\n  &#125;\n\n\n\n缓存一个Future而不是一个值，带来了**缓存污染(cache pollution)**的可能性：如果计算被取消或者失败，未来尝试过对这个值进行计算都会表现为取消或者失败。为了避免这个结果Memoizer如果发现计算被取消，就会把Future从缓存中移除；如果发现有RuntimeException，也会移除Future，这样新请求中的计算才有可能成功。Memoizer同样有缓存过期的问题，但是这些可以通过FutureTask的一个子类来完成，它会为每一个结果关联一个过期时间，并周期性地扫描缓存中过期的访问。\n\n使用Memoizer为因式分解的servlet缓存结果\n  public class Factorizer extends GenericServlet implements Servlet &#123;\n      private final Computable&lt;BigInteger, BigInteger[]&gt; c =\n              new Computable&lt;BigInteger, BigInteger[]&gt;() &#123;\n                  public BigInteger[] compute(BigInteger arg) &#123;\n                      return factor(arg);\n                  &#125;\n              &#125;;\n      private final Computable&lt;BigInteger, BigInteger[]&gt; cache\n              = new Memoizer&lt;BigInteger, BigInteger[]&gt;(c);\n\n      public void service(ServletRequest req,\n                          ServletResponse resp) &#123;\n          try &#123;\n              BigInteger i = extractFromRequest(req);\n              encodeIntoResponse(resp, cache.compute(i));\n          &#125; catch (InterruptedException e) &#123;\n              encodeError(resp, &quot;factorization interrupted&quot;);\n          &#125;\n      &#125;\n\n      void encodeIntoResponse(ServletResponse resp, BigInteger[] factors) &#123;\n      &#125;\n\n      void encodeError(ServletResponse resp, String errorString) &#123;\n      &#125;\n\n      BigInteger extractFromRequest(ServletRequest req) &#123;\n          return new BigInteger(&quot;7&quot;);\n      &#125;\n\n      BigInteger[] factor(BigInteger i) &#123;\n          // Doesn&#39;t really factor\n          return new BigInteger[]&#123;i&#125;;\n      &#125;\n  &#125;\n\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","构建块"]},{"title":"04.组合对象","url":"https://java4u.cn/Java并发编程/Java并发编程/04-组合对象/","content":"4.1 设计线程安全的类\n设计线程类的过程应该包括下面3个基本要素：\n确定对象状态是由哪些变量构成的；\n确定限制状态变量的不变约束；\n制定一个管理并发访问对象状态的策略\n\n\n对象的状态首先要从它的域说起。\n如果对象的域都是基本类型的，那么这些域就组成了对象的完整状态\n一个对象有n个基本域，它的状态就是域值组成的n元组(n-tuple)\n如果一个对象的域引用了其他对象，那么它的状态也同时包含了被引用对象的域。比如，LinkedList的状态包括了所有存储在链表中的节点对象的状态\n\n\n同步策略(synchronization policy)定义了对象如何协调对其状态的访问，并且不会违反它的不变约束或后验条件\n它规定了如何把不可变性、线程限制和锁结合起来，从而维护线程的安全性，还指明了哪些锁保护哪些变量。\n为了保证开发者与维护者可以分析并维护类，应该将类的同步策略写入文档\n\n\n\n4.1.1 收集同步需求\n不变约束——状态空间(state space)\n\n对象与变量可能处于的状态的范围\n状态空间越小，越容易判断它们\n尽量使用final类型的域，可以简化我们对对象的可能状态进行分析\n不可变对象是一种极限情况，它只可能处于唯一的状态\n\n\n后验条件——状态转换(state transition)\n\n状态转换时，新数据可以受先前状态的影响，比如计数器\n也可以不受先前状态的影响，比如温度\n\n\n不理解对象的不变约束和后验条件，就不能保证线程安全性。要约束状态变量的有效值或者状态转换，就需要原子性与封装性\n\n\n4.1.2 状态依赖的操作\n类的不变约束和方法的后验条件约束了对象合法的状态和合法状态转换\n某些对象的方法也有基于状态的先验条件(preconditions)。例如，无法从空队列中移除一个条目；删除元素前，队列必须处于“非空状态”\n若一个操作存在基于状态的先验条件，则把它称为是状态依赖的(state-dependent)\n\n4.1.3 状态所有权\n在定义对象状态是由哪些变量构成时，我们只考虑那些对象所拥有的数据\n\n4.2 实例限制\n将数据封装在对象内部，把对数据的访问限制在对象的方法上，更易确保线程在访问数据时总能获得正确的锁\n\n4.2.1 Java监视器模式\n线程限制原则的直接推论之一是Java监视器模式(Java monitor patter)。遵循Java监视器模式的对象封装了所有的可变状态，并由对象自己的内部锁保护。\n  //私有锁保护对象\n  public class PrivateLock &#123;\n      private final Object myLock = new Object();\n      @GuardedBy(&quot;myLock&quot;) Widget widget;\n\n      void someMethod() &#123;\n          synchronized (myLock) &#123;\n              // Access or modify the state of widget\n          &#125;\n      &#125;\n  &#125;\n\n像Vector和Hashtable这样的核心类库都使用了Java监视器模式\n\n使用私有锁对象，而不是对象的内部锁(或其他可公共访问的锁)的好处：\n\n私有的锁对象可以封装锁，这样客户代码无法得到它\n然而可公共访问的锁允许客户代码涉足它的同步策略；验证程序是正确地使用着一个可公共访问的锁，需要检查完整的程序，而不是一个单独的类\n\n\n\n4.2.2 范例：机动车追踪器(tracking fleet vehicles)//基于监视器的机动车追踪器实现\npublic class MonitorVehicleTracker &#123;\n    @GuardedBy(&quot;this&quot;) private final Map&lt;String, MutablePoint&gt; locations;\n\n    public MonitorVehicleTracker(Map&lt;String, MutablePoint&gt; locations) &#123;\n        this.locations = deepCopy(locations);\n    &#125;\n\n    public synchronized Map&lt;String, MutablePoint&gt; getLocations() &#123;\n        return deepCopy(locations);\n    &#125;\n\n    public synchronized MutablePoint getLocation(String id) &#123;\n        MutablePoint loc = locations.get(id);\n        return loc == null ? null : new MutablePoint(loc);\n    &#125;\n\n    public synchronized void setLocation(String id, int x, int y) &#123;\n        MutablePoint loc = locations.get(id);\n        if (loc == null)\n            throw new IllegalArgumentException(&quot;No such ID: &quot; + id);\n        loc.x = x;\n        loc.y = y;\n    &#125;\n\n    private static Map&lt;String, MutablePoint&gt; deepCopy(Map&lt;String, MutablePoint&gt; m) &#123;\n        Map&lt;String, MutablePoint&gt; result = new HashMap&lt;String, MutablePoint&gt;();\n\n        for (String id : m.keySet())\n            result.put(id, new MutablePoint(m.get(id)));\n\n        return Collections.unmodifiableMap(result);\n    &#125;\n&#125;\n\n//Mutable Point class similar to java.awt.Point\n@NotThreadSafe\npublic class MutablePoint &#123;\n    public int x, y;\n\n    public MutablePoint() &#123;\n        x = 0;\n        y = 0;\n    &#125;\n\n    public MutablePoint(MutablePoint p) &#123;\n        this.x = p.x;\n        this.y = p.y;\n    &#125;\n&#125;\n4.3 委托线程安全//Servlet that counts requests using AtomicLong\n@ThreadSafe\npublic class CountingFactorizer extends GenericServlet implements Servlet &#123;\n    private final AtomicLong count = new AtomicLong(0);\n\n    public long getCount() &#123; return count.get(); &#125;\n\n    public void service(ServletRequest req, ServletResponse resp) &#123;\n        BigInteger i = extractFromRequest(req);\n        BigInteger[] factors = factor(i);\n        count.incrementAndGet();\n        encodeIntoResponse(resp, factors);\n    &#125;\n\n    void encodeIntoResponse(ServletResponse res, BigInteger[] factors) &#123;&#125;\n    BigInteger extractFromRequest(ServletRequest req) &#123;return null; &#125;\n    BigInteger[] factor(BigInteger i) &#123; return null; &#125;\n&#125;\n　　在CountingFactorizer中，我们向一个无状态的类中加入了一个AtomicLong类型的属性，所得组合对象仍然是线程安全的。因为CountingFactorizer的状态就是线程安全类AtomicLong的状态，而且CountingFactorizer并未对counter的状态施加额外的有效性约束，所以，很显然CountingFactorizer是线程安全的。我们可以说CountingFactorizer将它的线程安全性委托给了AtomicLong：因为AtomicLong是线程安全的，所以CountingFactorizer也是\n4.3.1 范例：使用委托的机动车追踪器// Immutable Point class used by DelegatingVehicleTracker\n@Immutable\npublic class Point &#123;\n    public final int x, y;\n\n    public Point(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n&#125;\n  Point类是不可变的，因而是线程安全的。程序可以自由地共享与发布不可变值，所以我们返回location时不必再复制它们\n//Delegating thread safety to a ConcurrentHashMap\n@ThreadSafe\npublic class DelegatingVehicleTracker &#123;\n    private final ConcurrentMap&lt;String, Point&gt; locations;\n    private final Map&lt;String, Point&gt; unmodifiableMap;\n\n    public DelegatingVehicleTracker(Map&lt;String, Point&gt; points) &#123;\n        locations = new ConcurrentHashMap&lt;String, Point&gt;(points);\n        unmodifiableMap = Collections.unmodifiableMap(locations);\n    &#125;\n\n    public Map&lt;String, Point&gt; getLocations() &#123;\n        return unmodifiableMap;\n    &#125;\n\n    public Point getLocation(String id) &#123;\n        return locations.get(id);\n    &#125;\n\n    public void setLocation(String id, int x, int y) &#123;\n        if (locations.replace(id, new Point(x, y)) == null)\n            throw new IllegalArgumentException(&quot;invalid vehicle name: &quot; + id);\n    &#125;\n\n    // Alternate version of getLocations (Listing 4.8)\n    public Map&lt;String, Point&gt; getLocationsAsStatic() &#123;\n        return Collections.unmodifiableMap(\n                new HashMap&lt;String, Point&gt;(locations));\n    &#125;\n&#125;\n　　DelegatingVehicleTracker没有使用任何显式的同步；ConcurrentMap管理了所有对状态的访问，而且Map的键与值都是不可变的\n\n我们已经略微改变了VehicleTracker类的行为：基于“监视器”的代码返回location的快照，基于“委托”的代码返回一个不可变的，但却是“现场(live)”的location视图。这意味着如果线程A调用getLocations时，线程B修改了一些Point的location，这些变化会反映到返回给线程A的Map值中。\n\n4.3.2 非状态依赖变量\n可以将线程安全委托到多个隐含的状态变量上，只要这些变量是彼此独立的，这意味着组合对象并未增加任何涉及多个状态变量的不变约束\n\n当委托无法胜任时\n复杂情况：组合对象的不变约束与组件的状态变量相联系\n  //NumberRange类没有完整地保护它的不变约束\n  public class NumberRange &#123;\n      // INVARIANT: lower &lt;= upper\n      private final AtomicInteger lower = new AtomicInteger(0);\n      private final AtomicInteger upper = new AtomicInteger(0);\n\n      public void setLower(int i) &#123;\n          // Warning -- unsafe check-then-act\n          if (i &gt; upper.get())\n              throw new IllegalArgumentException(&quot;can&#39;t set lower to &quot; + i + &quot; &gt; upper&quot;);\n          lower.set(i);\n      &#125;\n\n      public void setUpper(int i) &#123;\n          // Warning -- unsafe check-then-act\n          if (i &lt; lower.get())\n              throw new IllegalArgumentException(&quot;can&#39;t set upper to &quot; + i + &quot; &lt; lower&quot;);\n          upper.set(i);\n      &#125;\n\n      public boolean isInRange(int i) &#123;\n          return (i &gt;= lower.get() &amp;&amp; i &lt;= upper.get());\n      &#125;\n  &#125;\n　　　假设值域是（0,10），一个线程调用setLower(5)时，另一个线程正在调用setUpper(4)，在一些偶发的时段里，它们都能满足set方法中的检查，使修改全部生效。结果现在的值域变成（5,4）——一个无效的状态。\n\n虽然底层的AtomicInteger是线程安全的，但是组合的类却不是。因为状态变量lower和upper不是彼此独立的，NumberRange不能简单地将线程安全性委托给线程安全的状态变量上\n\n通过加锁维护不变约束，可以使NumberRange成为线程安全的，比如用一个公共锁保护lower和upper。NumberRange也要避免发布lower和upper，以防止用户潜在的破坏不变约束\n\n原则：如果一个类由多个彼此独立的线程安全的状态变量组成，并且类的操作不包含任何无效状态转换时，可以将线程安全委托给这些状态变量\n\n\n4.3.4 发布底层的状态变量\n如果一个状态变量是线程安全的，没有任何不变约束限制它的值，并且没有任何状态转换限制它的操作，那么它就可以被安全的发布\n\n4.3.5 示例：发布了状态的机动车追踪器//可变的线程安全Point类\n@ThreadSafe\npublic class SafePoint &#123;\n    @GuardedBy(&quot;this&quot;) private int x, y;\n\n    private SafePoint(int[] a) &#123;\n        this(a[0], a[1]);\n    &#125;\n\n    public SafePoint(SafePoint p) &#123;\n        this(p.get());\n    &#125;\n\n    public SafePoint(int x, int y) &#123;\n        this.set(x, y);\n    &#125;\n\n    public synchronized int[] get() &#123;\n        return new int[]&#123;x, y&#125;;\n    &#125;\n\n    public synchronized void set(int x, int y) &#123;\n        this.x = x;\n        this.y = y;\n    &#125;\n&#125;\n//安全发布底层状态的机动车追踪器\n@ThreadSafe\npublic class PublishingVehicleTracker &#123;\n    private final Map&lt;String, SafePoint&gt; locations;\n    private final Map&lt;String, SafePoint&gt; unmodifiableMap;\n\n    public PublishingVehicleTracker(Map&lt;String, SafePoint&gt; locations) &#123;\n        this.locations = new ConcurrentHashMap&lt;String, SafePoint&gt;(locations);\n        this.unmodifiableMap = Collections.unmodifiableMap(this.locations);\n    &#125;\n\n    public Map&lt;String, SafePoint&gt; getLocations() &#123;\n        return unmodifiableMap;\n    &#125;\n\n    public SafePoint getLocation(String id) &#123;\n        return locations.get(id);\n    &#125;\n\n    public void setLocation(String id, int x, int y) &#123;\n        if (!locations.containsKey(id))\n            throw new IllegalArgumentException(&quot;invalid vehicle name: &quot; + id);\n        locations.get(id).set(x, y);\n    &#125;\n&#125;\n　　PublishingVehicleTracker的线程安全性源自于它所委托的底层ConcurrentHashMap，不过这次Map的内容是可变的Point，而非不可变的。getLocation方法返回底层Map的不可变拷贝，调用者在其上无法添加或移除车辆，却可以通过修改返回的Map中SafePoint的值，改变一个机动车的位置。Map这一“现场”特性是否有价值，这是一个缺陷，仍然取决于需求。只有PublishingVehicleTracker对机动车追踪器的合法值没有施加任何额外的约束时，它才是线程安全的。如果需要对机动车的location的改变进行判断或执行一些其他的操作，那么PublishingVehicleTracker的做法可能就不正确了。\n4.4 向已有的线程安全类添加功能　　如果一个类只支持我们需要的大部分操作，这时我们需要在不破坏线程安全性的前提下，向它添加一个新的操作。　　例如，假设我们需要一个线程安全的List，他需要提供给我们一个原子的“缺少即加入（put-if-absent）”操作。一个同步List实现几乎可以胜任，以为我们可以利用它提供的contains方法和add方法，构建一个“缺少即加入”操作。　　添加一个新原子操作的最安全的方式是，修改原始的类，以支持期望的操作。这通常不可能，因为你可能没有修改的自由。　　另一种方法是扩展这个类。好处是直观，缺点是并非所有的类都给子类暴露了足够多的状态，以支持这种方案\n　　\n4.4.1 客户端加锁\n对于一个由Collections.synchronizedList封装的ArrayList，两种方法——向原始类中加入方法或者扩展类都不正确，因为客户代码甚至不知道同步封装工厂方法返回的List对象的类型\n\n第三个策略是扩展功能，而不是扩展类本身，并将扩展代码置于一个“助手(helper)”类。\n\n为了让新添加的方法正确，必须保证方法所使用的锁，与List用户客户端加锁与外部加锁时所用的锁是同一个锁。客户端加锁必须保证客户端代码与对象X保护自己状态时使用的是相同的锁。为了正确执行客户端加锁，你必须知道X使用了哪些锁。\n  //非线程安全的“缺少即加入”实现\n  @NotThreadSafe\n  class BadListHelper &lt;E&gt; &#123;\n      public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;());\n\n      public synchronized boolean putIfAbsent(E x) &#123;\n          boolean absent = !list.contains(x);\n          if (absent)\n              list.add(x);\n          return absent;\n      &#125;\n  &#125;\n\n  //使用客户端加锁实现的“缺少即加入”\n  @ThreadSafe\n  class GoodListHelper &lt;E&gt; &#123;\n      public List&lt;E&gt; list = Collections.synchronizedList(new ArrayList&lt;E&gt;());\n\n      public boolean putIfAbsent(E x) &#123;\n          synchronized (list) &#123;\n              boolean absent = !list.contains(x);\n              if (absent)\n                  list.add(x);\n              return absent;\n          &#125;\n      &#125;\n  &#125;\n\n\n4.4.2 组合(composition)\n向已有的类中添加一个原子操作，还有更健壮的选择：组合\n\n以下代码，通过将操作委托给底层的List实例，实现了List的操作，同时还添加了一个原子的putIfAbsent方法\n  //使用组合实现“缺少即加入”\n  @ThreadSafe\n  public class ImprovedList&lt;T&gt; implements List&lt;T&gt; &#123;\n      private final List&lt;T&gt; list;\n\n      /**\n       * PRE: list argument is thread-safe.\n       */\n      public ImprovedList(List&lt;T&gt; list) &#123; this.list = list; &#125;\n\n      public synchronized boolean putIfAbsent(T x) &#123;\n          boolean contains = list.contains(x);\n          if (contains)\n              list.add(x);\n          return !contains;\n      &#125;\n\n      // Plain vanilla delegation for List methods.\n      // Mutative methods must be synchronized to ensure atomicity of putIfAbsent.\n\n      public int size() &#123;\n          return list.size();\n      &#125;\n\n      public boolean isEmpty() &#123;\n          return list.isEmpty();\n      &#125;\n\n      public boolean contains(Object o) &#123;\n          return list.contains(o);\n      &#125;\n\n      public Iterator&lt;T&gt; iterator() &#123;\n          return list.iterator();\n      &#125;\n\n      public Object[] toArray() &#123;\n          return list.toArray();\n      &#125;\n\n      public &lt;T&gt; T[] toArray(T[] a) &#123;\n          return list.toArray(a);\n      &#125;\n\n      public synchronized boolean add(T e) &#123;\n          return list.add(e);\n      &#125;\n\n      public synchronized boolean remove(Object o) &#123;\n          return list.remove(o);\n      &#125;\n\n      public boolean containsAll(Collection&lt;?&gt; c) &#123;\n          return list.containsAll(c);\n      &#125;\n\n      public synchronized boolean addAll(Collection&lt;? extends T&gt; c) &#123;\n          return list.addAll(c);\n      &#125;\n\n      public synchronized boolean addAll(int index, Collection&lt;? extends T&gt; c) &#123;\n          return list.addAll(index, c);\n      &#125;\n\n      public synchronized boolean removeAll(Collection&lt;?&gt; c) &#123;\n          return list.removeAll(c);\n      &#125;\n\n      public synchronized boolean retainAll(Collection&lt;?&gt; c) &#123;\n          return list.retainAll(c);\n      &#125;\n\n      public boolean equals(Object o) &#123;\n          return list.equals(o);\n      &#125;\n\n      public int hashCode() &#123;\n          return list.hashCode();\n      &#125;\n\n      public T get(int index) &#123;\n          return list.get(index);\n      &#125;\n\n      public T set(int index, T element) &#123;\n          return list.set(index, element);\n      &#125;\n\n      public void add(int index, T element) &#123;\n          list.add(index, element);\n      &#125;\n\n      public T remove(int index) &#123;\n          return list.remove(index);\n      &#125;\n\n      public int indexOf(Object o) &#123;\n          return list.indexOf(o);\n      &#125;\n\n      public int lastIndexOf(Object o) &#123;\n          return list.lastIndexOf(o);\n      &#125;\n\n      public ListIterator&lt;T&gt; listIterator() &#123;\n          return list.listIterator();\n      &#125;\n\n      public ListIterator&lt;T&gt; listIterator(int index) &#123;\n          return list.listIterator(index);\n      &#125;\n\n      public List&lt;T&gt; subList(int fromIndex, int toIndex) &#123;\n          return list.subList(fromIndex, toIndex);\n      &#125;\n\n      public synchronized void clear() &#123; list.clear(); &#125;\n  &#125;\n\n\n　　通过使用内部锁，ImprovedList引入了一个新的锁层。它并不关心底层的List是否线程安全，即使List不是线程安全的，或者会改变ImprovedList的锁实现，ImprovedList都有自己兼容的锁可以提供线程安全性。\n4.5 同步策略的文档化\n在维护线程安全性的过程中，文档是最强大的工具之一。\n用户为了确定一个类是否是线程安全的，会查阅文档；\n维护者为了理解实现策略以避免在维护中无意威胁到安全性，会查阅文档。\n为类的用户编写类线程安全性担保的文档；为类的维护者编写类的同步策略文档\n起草一个同步策略需要作出一系列的决策：\n将哪些变量声明为volatile类型\n哪些变量被锁保护\n哪个（哪些）锁保护哪些变量\n哪些变量是不可变的或者被限制在线程中的\n哪些操作必须是原子的\n\n\n\n4.5.1 含糊不清的文档(interpreting vague documentation)\n很多Java技术规范对于接口的线程安全线的担保和条件都只字未提，或者只有只言片语，比如ServletContext、HttpSession或DataSource。这些接口是由你的容器或数据库供应商实现的，而你通常无法查看它的源代码去了解它的实现细节。\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","组合对象"]},{"title":"03.共享对象","url":"https://java4u.cn/Java并发编程/Java并发编程/03-共享对象/","content":"同步有两个重要方面：原子操作或者划定临界区；内存可见性。我们不仅希望能够避免一个线程修改其他线程正在使用的对象的状态，而且希望确保当一个线程修改了对象的状态后，其他线程能够真正的看到改变。但是没用同步，这些可能都不会发生。你可以使用显式的同步，或者利用内置于类库中的同步机制，来保证对象的安全发布。\n3.1 可见性　　在没有同步的情况下，编译器，处理器，运行时安排操作的执行顺序可能完全出人意料。在没有进行适当同步的多线程程序中，尝试推断那些“必然”发生在内存中的动作时，你总是判断错误。有一个简单的方法来避免这些复杂的问题：只要数据需要被跨线程共享，就进行恰当的同步\n3.1.1 过期数据\n没有恰当同步的程序，它能够引起意外的后果：过期数据\n当读线程检查ready变量时，它可能看到一个过期的值\n除非每一次访问变量都是同步的，否则很可能得到变量的过期值\n更坏的情况是，过期既不会发生在全部变量上，也不会完全不出现：一个线程可能会得到一个变量最新的值，但是也可能得到另一个变量先前写入的过期值\n过期数据的危害\n引起安全错误，导致打印错误数据，或者程序无法终止\n使对象引用中的数据更加复杂，比如链指针在链表中的实现\n引发严重且混乱的错误，比如意外的异常，脏的数据结构，错误的计算和无限的循环\n\n\n\n3.1.2 非原子的64位操作\n最低限的安全性(out-of-thin-air safety)\n一个线程在没有同步的情况下读取变量，可能得到过期值\n但至少可以看到某个线程在那里设定的一个真实数值，而不是一个凭空而来的值。\n这样的安全保证为最低限的安全性\n\n\n最低限的安全性应用于所有的变量\n例外：没有声明为volatile的64位数值变量。\nJava存储模型要求获取和存储操作都为原子的，但是对于非volatile的long和double变量，JVM允许将64位的读或写划分为两个32位的操作。\n如果读和写发生在不同的线程，这种情况读取一个非volatile类型long就可能会出现得到一个值的高32位和另一个值的低32位\n所以不安全，除非声明为volatile类型或加锁保护\n\n\n\n3.1.3 锁和可见性\n当访问一个共享的可变变量时，为什么要求所有线程由同一个锁进行同步，我们现在可以给出另一个理由：\n为了保证一个线程对数值进行的写入，其他线程也都可见\n另一方面，如果一个线程在没有恰当地使用锁的情况下读取了变量，那么这个变量很可能是一个过期的数据\n\n\n锁不仅仅是关于同步与互斥的，也是关于内存可见的。为了保证所有线程都能看到共享的、可变变量的最新值，读取和写入线程必须使用公共的锁进行同步\n\n3.1.4 Volatile变量\nJava中同步的弱形式：volatile变量\n它确保对一个变量的更新以可预见的方式告知其他线程\n当一个域声明为volatile类型后，编译器与运行时都会监视这个变量：它是共享的，而且对它的操作不会与其他的内存操作一起被重排序\nvolatile变量不会缓存在寄存器或者缓存在对其他处理器隐藏的地方\n所以，读一个volatile类型的变量时，总会返回由某一线程所写入的最新值\nvolatile变量相对于sychronized而言，只是轻量级的同步机制\nvolatile变量对可见性的影响所产生的价值远远高于变量本身\n正确使用volatile变量的方式包括：\n用于确保它们所引用的对象状态的可见性\n用于标识重要的生命周期事件(比如初始化或关闭)的发生\n\n\n加锁可以保证可见性与原子性；volatile变量只能保证可见性\n只有满足了下面所有的标准后，你才能使用volatile变量：\n写入变量时并不依赖变量的当前值；或者能够确保只有单一的线程修改变量的值；\n变量不需要与其他的状态变量共同参与不变约束\n而且访问变量时，没有其他的原因需要加锁\n\n\n\n3.2 发布和逸出　　发布一个对象：使它能够被当前范围之外的代码所使用　　逸出：一个对象在尚未准备好时就将它发布\n\n最常见的发布对象的方式是将对象的引用存储到公共静态域中。任何类和线程都能看见这个域\n\n3.2.1 安全构建的实践\n重要的逸出特例——this引用在构造时逸出\n一个导致this引用在构造期间逸出的常见错误，是在构造函数中启动一个线程。当对象在构造函数中创建了一个线程时，无论是显式地（通过将它传给构造函数）还是隐式地（因为Thread或Runnable是所属对象的内部类），this引用几乎总是被新线程共享\n如果想在构造函数中注册监听器或启动线程，可以使用一个私有的构造函数和一个公共的工厂方法，这样避免了不正确的创建\n\n3.3 线程封闭　　访问共享的、可变的数据要求使用同步。一个可以避免同步的方式就是不共享数据。如果数据仅在单线程中被访问，就不需要任何同步。线程封闭(Thread confinement)技术是实现线程安全的最简单的方式之一\n\nSwing发展了线程封闭技术\n另一种常见的使用线程限制的应用程序是应用池化的JDBC的Connection对象\nJDBC的规范并没有要求Connection对象是线程安全的\n然而典型的服务器应用中，线程总是从池中获得一个Connection对象，并且用它处理一个单一的请求，最后把它归还\n每个线程都会同步地处理大多数请求（比如Servlet请求或EJB调用），而且在Connection对象在被归还前，池不会将它再分配给其他线程\n因此，这种连接管理模式隐式的将Connection对象限制在处于请求处理期间的线程中\n\n\n\n3.3.1 Ad-hoc线程限制\n是指维护线程限制性的任务全部落在实现上的这种情况\n未经过设计而得到的线程封闭行为\n\n3.3.2 栈限制\n栈限制是线程封闭的一种特例\n栈限制中，只能通过本地变量才可以触及对象\n正如封装使不变约束更容易被保持，本地变量使对象更容易被限制在线程本地中\n本地变量本身就被限制在执行线程中：它们存在于执行线程栈。其他线程无法访问这个栈。\n栈限制比起Ad-hoc线程限制更易维护，更健壮\n\n3.3.3 ThreadLocal\n维护线程限制的更加规范的方式是使用ThreadLocal，它允许你将每个线程与持有数值的对象关联在一起。\nThreadLocal提供了get与set访问器，为每个使用它的线程维护一份单独的拷贝\n所以get总是返回由当前执行线程通过set设置的最新值\n线程本地（ThreadLocal）变量通常用于防止在基于可变的单体（Singleton）或全局变量的设计中，出现（不正确的）共享。比如说：一个单线程化的应用程序可能会维护一个全局的数据库连接，这个Connection在启动时就已经被初始化了。这样就可以避免为每个方法都传递一个Connection。\n这项技术还用于下面的情况：\n一个频繁执行的操作既需要像buffer这样的临时对象，同时还需要避免每次都重分配（reallocate）该临时对象\n\n\n\n3.4 不可变性　　满足同步的需要，另一种方法就是使用不可变对象。\n\n创建后状态不能被修改的对象叫做不可变对象\n不可变对象永远是线程安全的\n不可变对象不会被恶意的或者漏洞百出的代码所破坏，所以它们是安全的，可以放心的共享和发布，不需要创建防御性拷贝\n所有域都是final类型对象仍然可以是可变的，因为final域可以获得一个可变对象的引用\n只有满足如下状态，一个对象才是不可变的：\n它的状态不能在创建后再被修改\n所有域都是final类型\n它被正确创建（创建期间没有发生this引用的逸出）\n\n\n对象是不可变的 与 对象的引用是不可变的 之间并不等同\n程序存储在不可变对象中的状态仍然可以通过替换一个带有新状态的不可变对象的实例得到更新\n\n\n\n3.4.1 Final域\n它对不可变性对象的创建提供了支持\nfinal域是不能修改的\n\n3.4.2使用volatile发布不可变对象　　不可变的容器持有与不变约束相关的多个状态变量，并利用volatile引用确保及时的可见性\n3.5 安全发布　　目前为止，我们都关注确保对象不会被发布。比如，让对象限制在线程中或者另一个对象的内部。当然，有时我们又的确希望跨线程共享对象，这时我们必须安全地共享它。\n3.5.1 不正确发布：当好对象变坏时\n没有正确发布的对象会导致两种错误：\n首先，发布线程以外的任何线程都可以看到Holder域的过期值，因而看到的是一个null引用或者旧值，即使Holder已经被赋予新值\n其次，更坏的情况是，线程看到的Holder引用是最新的，然而Holder状态却是过期的\n\n\n\n3.5.2 不可变对象与初始化安全性\n由于不可变对象的安全性，Java存储模型为共享不可变对象提供了特殊的初始化安全性的保证。\n不可变对象可以在没有额外同步的情况下，安全地用于任意线程；甚至发布它们时亦不需要同步\n\n3.5.3 安全发布的模式\n如果一个对象不是不可变的，它就必须被安全地发布，通常发布线程与消费线程都必须同步化\n为了安全的发布对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确创建的对象可以通过下列条件安全地发布：\n通过静态初始化器初始化对象的引用\n将它的引用存储到volatile域或AtomicReference\n将它的引用存储到正确创建的对象的final域中\n或者将它的引用存储到由锁正确保护的域中\n\n\n\n3.5.4 高效不可变对象（Effectively immutable objects）\n一个对象在技术上不是不可变的，但是它的状态不会在发布后被修改，这样的对象称作有效不可变对象\n这种对象不必满足不可变性的约束条件；这些对象发布后程序只需简单地把他们当做不可变对象。\n用高效不可变对象可以简化开发，并且由于减少了同步的使用，还会提高性能\n任何线程都可以在没有额外的同步下安全地使用一个安全发布的高效不可变对象\n比如，Date自身是可变的，但是如果你把它当做不可变对象来使用就可以忽略锁。否则，每当Date被跨线程共享时，都要用锁确保安全。假设你正在维护一个Map，它存储了每位用户的最近登录时间。public Map&lt;String,Date&gt; lastLogin =Collections.synchronizedMap(new HashMap&lt;String,Date&gt;());如果Date值在置入Map中后就不会改变，那么synchronizedMap中同步的实现,对于安全地发布Date值，是至关重要的。而访问这些Date值时就不需要额外的同步\n\n3.5.5 可变对象\n为了保证安全地共享可变对象，可变对象必须被安全发布，同时必须是线程安全的或者是被锁保护的\n发布对象的必要条件依赖于对象的可变性\n不可变对象可以通过任意机制发布\n高效不可变对象必须要安全发布\n可变对象必须要安全发布，同时必须要线程安全或者被锁保护\n\n\n\n3.5.6 安全的共享对象\n在并发程序中，使用和共享对象的一些最有效的策略如下：\n线程限制：一个线程限制的对象，通过限制在线程中，而被线程独占，且只能被占有它的线程修改\n共享只读(shared read-only)：一个共享的只读对象，在没有额外同步的情况下，可以被多个线程并发地访问，但是任何线程都不能修改它，共享只读对象不包括可变对象与高效不可变对象\n共享线程安全(shared thread-safe):一个线程安全的对象在内部进行同步，所以其他线程无须额外同步，就可以通过公共接口随意访问它\n被守护的(Guarder):一个被守护的对象只能通过特定的锁来访问。被守护的对象包括那些被线程安全对象封装的对象，和已被特定的锁保护起来的已发布对象\n\n\n\n\n---\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","共享对象"]},{"title":"02.线程安全","url":"https://java4u.cn/Java并发编程/Java并发编程/02-线程安全/","content":"一些概念\n定义:\n要求无论是多线程中的时序或交替操作，都要保证不破坏哪些不变约束\n\n\n编写线程安全的代码，本质上就是\n管理对状态的访问，而且通常都是共享的、可变的状态\n\n\n一个对象的状态：\n就是它的数据，存储在状态变量中，比如实例域或静态域\n\n\n共享\n一个变量可以被多个线程访问\n\n\n可变\n变量的值在其生命周期内可以改变\n\n\n无论何时，只要有多于一个线程访问给定的状态变量，而且其中的某个线程会写入该变量，此时必须使用同步来协调线程对该变量的访问\n在没有正确同步的情况下，如果多个线程访问了同一个变量，你的程序就存在隐患。有三种方法修复它：\n不要跨线程共享变量\n使状态变量变为不可变的\n在任何访问状态变量的时候使用同步\n\n\n\n2.1 什么是线程安全性\n一个类是线程安全的，是指在被多个线程访问时，类可以持续进行正确的行为\n线程安全的类封装了任何必要的同步，因此客户不需要自己提供\n无状态对象永远是线程安全的\n多数Servlet都可以实现为无状态的，这一事实极大地降低了确保Servlet线程安全的负担，只有当Servlet要为不同的请求记录一些信息时，才会将线程安全的需求提到日程上来\n\n\n\n2.2 原子性\n向无状态对象中加入一个状态元素会怎样？\n假设我们想要添加命中数，来计算处理请求的个数。\n常见方法是在Servlet中添加一个long类型的域，并在请求中递增它\n\n\n然而这并非线程安全的\n它很容易遗失更新(lost updates)\n自增操作++count由于其紧凑的语法格式，看上去更像一个单独的操作，然而它不是原子操作，这意味着它不能作为一个单独的、不可分割的操作去执行。\n自增操作是3个离散操作的简写形式：\n获得当前值，\n+1，\n写回新值\n\n\n这是一个**读-改-写(read-modify-write)**操作的实例，其中，结果的状态衍生自它先前的状态\n\n2.2.1 竞争条件\n当计算的正确性依赖于运行时中相关的时序或者多线程的交替时，会产生竞争条件\n想得到正确的答案，要依赖于“幸运的时序”\n最常见的一种竞争条件是“检查再运行(check-then-act)”\n\n2.2.2 示例：惰性初始化中的竞争条件\n检查再运行的常见用法是惰性初始化\n惰性初始化的目的是延迟对象的初始化\n直到程序真正使用它，同时确保它只初始化一次\n像大多数并发错误一样，竞争条件并不总是导致失败：还需要某些特殊的分时\n\n2.2.3 复合操作\n为避免竞争条件，必须阻止其他线程访问我们正在修改的变量，让我们可以确保：当其他线程想要查看或修改一个状态时，必须在我们的线程开始之前或者完成之后，而不能在操作过程中\n我们将“检查再运行”和“读-改-写”操作的全部执行过程看做是复合操作：为了保证线程安全，操作必须原子地进行。\n\n2.2.4 计数器在Servlet中线程不安全问题的解决\njava.util.concurrent.atomic包中包括了**原子变量(atomic variable)**类，这些类用来实现数字和对象引用的原子状态转换\n把long类型的计数器替换为AtomicLong类型的，可以确保所有访问计数器状态的操作都是原子的\n计数器是线程安全的了，而计数器的状态就是Servlet的状态，所以Servlet再次成为线程安全的了\n\n2.3 锁\n为保证状态的一致性，要在单一的原子操作中更新相互关联的状态变量\n\n2.3.1 内部锁\nJava提供了强制原子性的内置锁机制：synchronized块\n一个synchronized块有两部分：\n锁对象的引用\n这个锁保护的代码块\n\n\n每个Java对象都可以隐式地扮演一个用于同步的角色：这些内置的锁被称作内部锁(intrinsic locks)**或监视器锁(monitor locks)**\n内部锁在Java中扮演了**互斥锁(mutual exclusion lock / mutex)**的角色，意味着至多只有一个线程可以拥有锁，当线程A尝试请求一个被线程B占有的锁时，线程A必须等待或阻塞，直到B释放它。如果B永远不释放锁，A将永远等下去\n\n2.3.2 重进入(Reentrancy)\n当一个线程请求其他线程已经占有的锁时，请求线程将被阻塞\n然而内部锁是可重进入的，因此线程在试图获得它自己占有的锁时，请求会成功\n重进入意味着所有请求是基于“”每线程(per-thread)，而不是基于“没调用(per-invocation)”的\n重进入的实现是通过为每个锁关联一个请求计数(acquisition)和一个占有它的线程：\n当计数为0时，认为锁是未被占用的\n线程请求一个未被占用的锁时，JVM将记录锁的占有者，并且将请求计数置为1\n如果同一线程再次请求这个锁，计数将递增\n每次占用线程退出同步块，计数器将递减。直到计数器达到0，锁被释放\n\n\n如果内部锁不是可重入的，代码可能会死锁：\n子类重写父类synchronized类型的方法，并调用父类中的方法\n\n\n\n2.4 用锁来保护状态\n因为锁能使得线程能够串行地访问它所保护的代码路径，所以我们可以用锁来创建相关的协议，以保证线程对共享状态的独占访问\n只要始终如一地遵循这些协议，就能确保状态的一致性\n每个共享的可变变量都需要由唯一一个确定的锁保护，而维护者应该清楚这个锁\n常见的锁规则：\n在对象内部封装所有的可变状态，通过对象的内部锁来同步任何访问可变状态的代码路径，保护它在并发访问中的安全\nVector和其他同步的容器类都是这个模式\n\n\n并不是所有数据都需要锁的保护——只有那些被多个线程访问的可变数据\n对于每一个涉及多个变量的约束，需要同一个锁保护其所有的变量\n既然同步可以避免竞争条件，为什么不将每个方法都声明为synchronized类型？\n如此武断的使用同步，可能导致程序中使用的同步过多或过少\n如同Vector这样，仅仅同步它的每个方法，并不足以确保在Vector上执行的复合操作是原子的：if (!vector.contains(element))　　vector.add(element);\n虽然contains和add是原子的，但在尝试“缺少即加入(put-if-absent)”操作的过程中仍然存在竞争条件。\n虽然同步方法确保了不可分割操作的原子性，但是把多个操作整合到一个复合操作时，还是需要额外的锁。\n同步每个方法还会导致活跃度或性能问题\n\n\n\n2.5 活跃度与性能\n通常简单性和性能之间是相互牵制。实现一个同步策略时，不要过早地为了性能而牺牲简单性（这是对安全性潜在的威胁）\n当使用锁的时候，你应该清楚块中的代码的功能，以及它的执行过程是否会很耗时。无论是作运算密集型的操作，还是在执行一个可能存在潜在阻塞的操作，如果线程长时间地占有锁，就会引起活跃度与性能风险的问题\n有些耗时的计算或操作，比如网络或控制台I/O，难以快速完成，执行这些操作期间不要占有锁\n\n\n---\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","线程安全"]},{"title":"01.介绍","url":"https://java4u.cn/Java并发编程/Java并发编程/01-介绍/","content":"并发的历史\n顺序编程模型\n线程允许程序控制流的多重分支同时存在于一个进程中，共享进程内资源\n线程有时候被成为轻量级进程，大多数现代操作系统时序调度的基本单元\n\n线程的优点\n降低开发和维护的开销，提高复杂应用的性能\n把异步工作流转化为顺序流，使程序模拟人类工作和交互变得更加容易\n把复杂、难以理解的代码转化为直接、简洁的代码，易读写及维护\n在GUI应用中改进用户接口的响应性\n在服务器应用中提高资源的利用率和吞吐量\n简化JVM的实现，垃圾收集器通常运行于一个或多个持续工作的线程之间\n大部分至关重要的Java应用都依赖于线程，某种程度上是因为它们的组织结构需要这样\n\n线程的风险安全危险\n常见的并发危险\n竞争条件(race condition)\n\n\n\n活跃度的危险\n线程的使用引入了又一形式的活跃度失败(liveness failure)\n活跃度意味着好的事情终究会发生\n当一个活动进入某种它永远无法再继续执行的状态时，活跃度失败发生\n活跃度失败包括：\n死锁(deadlock)\n饥饿(starvation)\n活锁(livelock)\n\n\n\n性能危险\n性能：希望好的事情尽快发生\n性能问题包括：\n服务时间\n响应性\n吞吐量\n资源消费\n可伸缩性\n\n\n上下文切换(Context switches)\n当调度程序临时挂起当前运行的线程时，另一个线程开始运行\n这在多线程应用中频繁，带来巨大的系统开销：\n保存和恢复线程执行的上下文\n离开执行现场\nCPU时间花费在对线程的调度而不是运行上\n当线程共享数据时，必须同步，这会限制编译器的优化\n能够清空或锁定内存和高速缓存\n并在共享内存的总线上创建同步通信，这些因素引入性能开销\n\n\n\n\n\n线程无处不在定时器\nTimer用来调度一些稍后运行的任务，也可以是只运行一次或者周期性运行的任务\nTimerTasks运行在由Timer管理的线程中，并不是由应用程序来管理\n如果一个TimeTask访问了其他应用程序线程正在访问的数据，那么不仅TimerTask需要线程安全的手段，并且其他那些同时访问这个数据的类也需要相应措施\n通常实现方法是确保TimerTask访问的对象本身是线程安全的\n因此应该将线程安全性封装到共享对象的内部\n\nServlets and JavaServer Pages(JSPs)\nServlets框架设计目的是处理Web应用的部署，分发来自远程HTTP客户的请求这些基础层业务\n一个请求到达Server并被分发后，可能通过一个过滤器链到达相应的Servlet或者JSP\n每一个Servlet代表应用逻辑的一个组件\n在访问量较大的网站中，许多客户可能同时对相同Servlet的服务提出请求\nServlets的规范规定了一个Servlet必须为多个用户同时调用它作好准备\n换句话说，Servlets应该是线程安全的\n当一个Servlet访问的对象是在Servlets间共享或者请求间共享时，必须对这些对象的访问控制进行适当协调，因为来自不同线程的多个请求可能同时访问它们\nServlet、JSP和Servlet Filter以及哪些存储在ServletContext和HttpSession容器中的对象，明显必须是线程安全的\n\n远程方法调用(Remote Method Invocation)\nRMI使你能够调用在另外一个JVM上运行的对象的方法\n使用RMI调用一个远程方法时，这个方法的参数被打包成一个比特流，并且穿越网络到达远程JVM，在那里会解包并传递给远程方法\n一个远程对象必须去守卫两种线程安全风险：\n对那些可能会与其他对象共享的状态进行适当调节，应正确地对远程对象本身进行调控\nRMI对象应该对同时发生的多个调用有所准备，并且必须提供它们自己的线程安全\n\n\n\nSwing 和 AWT\nGUI应用程序具有固有的异步特性\n当用户进行了一个UI活动，事件线程会调用事件处理器来执行用户请求的操作。\n如果处理器需要访问应用程序状态，这里很可能有其他程序正在访问，那么事件的处理器，与其他访问状态的代码必须以线程安全的方式工作\n\n\n\n","categories":["Java并发编程"],"tags":["Java","Java并发","线程安全"]},{"title":"剑指Offer之三十--最小的K个数","url":"https://java4u.cn/算法/算法/剑指Offer之三十-最小的K个数/","content":"题目描述\n输入n个整数，找出其中最小的K个数。\n例如输入4,5,1,6,2,7,3,8这8个数字，则最小的4个数字是1,2,3,4。\n\n解法1\n对数组排序，取前边k个数存到list集合中\n该解法时间复杂度依赖于排序\n\n代码实现public ArrayList&lt;Integer&gt; getLeastNumbers(int [] input, int k) &#123;\n\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if(input == null || input.length == 0 || input.length &lt; k || k &lt;= 0)&#123;\n        return list;\n    &#125;\n    Arrays.sort(input);\n    for(int i = 0; i &lt; k; i++)&#123;\n        list.add(input[i]);\n    &#125;\n    return list;\n&#125;\n解法2\n基于partition函数\n只有当我们可以修改输入的数组时可用\n\n代码实现public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution2(int [] input, int k) &#123;\n\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if(input == null || input.length == 0 || input.length &lt; k || k &lt;= 0)&#123;\n        return list;\n    &#125;\n    int start = 0;\n    int end = input.length - 1;\n    int index = partition(input, start, end);\n    while(index != k - 1)&#123;\n        if(index &gt; k - 1)&#123;\n            end = index - 1;\n            index = partition(input, start, end);\n        &#125;else&#123;\n            start = index + 1;\n            index = partition(input, start, end);\n        &#125;\n    &#125;\n    for(int i = 0; i &lt; k; i++)&#123;\n        list.add(input[i]);\n    &#125;\n    return list;\n&#125;\nprivate int partition(int[] input, int low, int high) &#123;\n    int pivotKey = input[low];\n    while(low &lt; high)&#123;\n        while(low &lt; high &amp;&amp; input[high] &gt;= pivotKey)&#123;\n            high--;\n        &#125;\n        input[low] = input[high];\n        while(low &lt; high &amp;&amp; input[low] &lt;= pivotKey)&#123;\n            low++;\n        &#125;\n        input[high] = input[low];\n    &#125;\n    input[low] = pivotKey;\n    return low;\n&#125;\n解法3\n适合海量数据的处理\n创建一个用于保存最小k个数的容器\n第一步是放入k个元素，\n第二步是比较容器中最大的数与当前数组遍历的那个数的大小\n如果容器中最大的数比当前遍历的数大，就移除该数，并放入当前遍历的那个数\n最大堆或红黑树都能实现这样的容器\n\n代码实现public ArrayList&lt;Integer&gt; GetLeastNumbers_Solution3(int[] input, int k) &#123;\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if(input == null || input.length == 0 || input.length &lt; k || k &lt;= 0)&#123;\n        return list;\n    &#125;\n    TreeSet&lt;Integer&gt; s = new TreeSet&lt;Integer&gt;();\n    for(int i = 0; i &lt; input.length; i++)&#123;\n        if(s.size() &lt; k)&#123;\n            s.add(input[i]);\n        &#125;else&#123;\n            if(input[i] &lt; s.last())&#123;\n                s.remove(s.last());\n                s.add(input[i]);\n            &#125;\n        &#125;\n    &#125;\n    Iterator&lt;Integer&gt; it = s.iterator();\n    while(it.hasNext())&#123;\n        list.add(it.next());\n    &#125;\n    return list;\n&#125;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","数组","查找","top k"]},{"title":"剑指Offer之二十九--数组中出现次数超过一半的数字","url":"https://java4u.cn/算法/算法/剑指Offer之二十九-数组中出现次数超过一半的数字/","content":"题目描述\n数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。\n例如输入一个长度为9的数组{1,2,3,2,2,2,5,4,2}。\n由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。\n如果不存在则输出0。\n\n解法1\n使用map，键存元素，值存出现的次数\n发现有某个元素的次数超过数组长度的一半，则返回该元素\n\n代码实现public int moreThanHalfNum(int [] array) &#123;\n\n    if(array == null || array.length == 0)&#123;\n        return 0;\n    &#125;\n    int flag = 0;\n    Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();\n    int len = array.length;\n    for(int i = 0; i &lt; len; i++)&#123;\n        if(map.containsKey(array[i]))&#123;\n            map.put(array[i], map.get(array[i]) + 1);\n        &#125;else&#123;\n            map.put(array[i], 1);\n        &#125;\n        if(map.get(array[i]) &gt; len / 2)&#123;\n            flag = array[i];\n            break;\n        &#125;\n    &#125;\n    return flag;\n&#125;\n解法2\n设置标识变量，遇到相同的数字，就把次数加1，如果没有遇到就把次数减1\n由于要找的数字出现的次数一定大于其他数字出现次数之和\n所以那个数字肯定是最后一次吧times变量设为1对应的数字\n\n代码实现public int moreThanHalfNum(int[] array) &#123;\n    if(array == null || array.length == 0)&#123;\n        return 0;\n    &#125;\n    int times = 1;\n    int result = array[0];\n    for(int i = 1; i &lt; array.length; i++)&#123;\n        if(times == 0)&#123;\n            result = array[i];\n            times = 1;\n        &#125;else if(array[i] == result)&#123;\n            //遇到相同的数字次数就加1\n            times++;\n        &#125;else&#123;\n            //没有遇到相同的就把次数减1\n            times--;\n        &#125;\n    &#125;\n    if(!checkMoreThanHalfNum(array, result))&#123;\n        return 0;\n    &#125;\n    return result;\n&#125;\n\n//检查该数字是否出现的次数超过一半\nprivate boolean checkMoreThanHalfNum(int[] array, int result)&#123;\n    int times = 0;\n    for(int i = 0; i &lt; array.length; i++)&#123;\n        if(array[i] == result)&#123;\n            times++;\n        &#125;\n    &#125;\n    boolean isMoreThanHalf = true;\n    if(times * 2 &lt;= array.length)&#123;\n        isMoreThanHalf = false;\n    &#125;\n    return isMoreThanHalf;\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","数组","查找"]},{"title":"剑指Offer之二十八--字符串的排列","url":"https://java4u.cn/算法/算法/剑指Offer之二十八-字符串的排列/","content":"题目描述\n输入一个字符串,按字典序打印出该字符串中字符的所有排列。\n例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。\n结果请按字母顺序输出。 \n\n输入描述:\n输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。\n\n思路：\n先不考虑是否出现重读字符，要对一个字符进行全排列，可以把第一个字符和后面的字符看成两部分\n而第一个字符后面的字符又可以看成第一个字符和后面两部分，是一个递归过程\n只要第一个字符的位置没有到达字符串的末尾就分别将第一个字符与后面的字符进行交换\n\n注意：\n第一个字符与后面的某个位置的字符发生交换后，需要再次发生交换，不然顺序就会被打乱\n举个例子，在字符串abc中，在把第一个字符看成是a，后面的字符b，c，看成是一个整体的时候，abc这个相对的顺序不能改变\n所以当a与b发生交换变成bac之后，需要再次交换两个字符，重新回到abc\n\n代码实现public ArrayList&lt;String&gt; permutation(String str) &#123;\n\n    ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();        \n\n    if(str == null || str.length() == 0)&#123;\n        return list;\n    &#125;\n\n    list =  permutation(list, str.toCharArray(), 0, str.length());\n    Collections.sort(list);\n    return list;\n&#125;\n\n//递归的将满足题意的字符串添加到list中\nprivate ArrayList&lt;String&gt; permutation(ArrayList&lt;String&gt; list, char[] str, int begin, int length) &#123;\n\n    if(begin == length - 1)&#123;\n        if(!list.contains(String.valueOf(str)))&#123;\n            list.add(String.valueOf(str));\n        &#125;\n    &#125;else&#123;\n        for(int i = begin; i &lt; length; i++)&#123;\n            if(i == begin || str[i] != str[begin])&#123;\n                swap(str, begin, i);\n                permutation(list, str,begin + 1, length);\n                swap(str, begin, i);\n            &#125;\n        &#125;\n    &#125;\n    return list;\n&#125;\n\nprivate void swap(char[] str, int begin, int i) &#123;\n    char temp = str[begin];\n    str[begin] = str[i];\n    str[i] = temp;\n\n&#125;\n\n//非递归解法\npublic ArrayList&lt;String&gt; permutation1(String str) &#123;\n    //使用TreeSet，有序\n    TreeSet&lt;String&gt; tree = new TreeSet&lt;String&gt;();\n    //创建一个栈保存每次排列的字符组合\n    Stack&lt;String[]&gt; stack = new Stack&lt;String[]&gt;();\n    //存放最终的排列结果\n    ArrayList&lt;String&gt; results = new ArrayList&lt;String&gt;();\n\n    stack.push(new String[] &#123;str,&quot;&quot;&#125;);\n    do&#123;\n        //这里popStrs就是str输入的字符串\n        String[] popStrs = stack.pop();\n        //空串\n        String oldStr = popStrs[1];\n        //Str\n        String stackStr = popStrs[0];\n        for(int i = stackStr.length() - 1; i &gt;= 0; i--)&#123;\n            String[] strs = new String[]&#123;\n                    stackStr.substring(0, i) + stackStr.substring(i + 1),\n                    oldStr + stackStr.substring(i, i + 1)\n                    &#125;;\n            if(strs[0].length() == 0)&#123;\n                tree.add(strs[1]);\n            &#125;else&#123;\n                stack.push(strs);\n            &#125;\n\n        &#125;\n    &#125;while(!stack.isEmpty());\n    for(String s : tree)&#123;\n        results.add(s);\n    &#125;\n\n    return results;\n\n\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","字符串","排列"]},{"title":"剑指Offer之二十七--二叉搜索树与双向链表","url":"https://java4u.cn/算法/算法/剑指Offer之二十七-二叉搜索树与双向链表/","content":"二叉树结构class TreeNode &#123;\n    int val = 0;\n    TreeNode left = null;\n    TreeNode right = null;\n\n    public TreeNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n题目描述\n输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。\n要求不能创建任何新的结点，只能调整树中结点指针的指向。\n\n思路：\n由于二叉搜索树的中序遍历就是排序的，如果是构造单链表，只需要一次中序遍历就可以了\n但现在需要构造双链表，也就是在中序遍历的过程中需要设置每个结点的left与right指针，现在问题是如何设置这两个指针\n二叉搜索树有一个特点，就是根结点的左子树上所有结点都比根结点的值小，而右子树上的所有结点的值都比根结点的值大\n利用这个性质，当遍历根结点的左孩子的时候，可以继续把其当做左子树的根结点，右孩子可以当做右子树的根结点，从而使用递归完成\n\n步骤\n以左子树为例，依次访问结点的左孩子，当遍历到叶子节点的时候，递归结束，并把该叶子结点设为左子树转换的双链表的第一个结点\n然后把其父结点链在其右边，设置left和right指针；如果父结点有右孩子，则继续对其右孩子继续转换，链在父结点的右边(父结点的右孩子肯定比父结点大)\n这样当左右子树都转换完成后，返回双链表的第一个结点就可以了\n\n代码实现public TreeNode convert(TreeNode pRootOfTree) &#123;\n    if(pRootOfTree == null)&#123;\n        return null;\n    &#125;\n    if(pRootOfTree.left == null &amp;&amp; pRootOfTree.right == null)&#123;\n        return pRootOfTree;\n    &#125;\n\n    TreeNode pLastNodeOfLeftList = convert(pRootOfTree.left);\n    TreeNode p = pLastNodeOfLeftList;\n\n    //定位到左子树双链表的最后一个结点\n    while(p != null &amp;&amp; p.right != null)&#123;\n        p = p.right;\n    &#125;\n\n    //将root结点追加到左子树双链表的最后一个结点\n    if(pLastNodeOfLeftList != null)&#123;\n        p.right = pRootOfTree;\n        pRootOfTree.left = p;\n    &#125;\n\n    //转换右子树为双链表\n    TreeNode pLastNodeOfRightList = convert(pRootOfTree.right);\n    //将root追加至右子树双链表的最后一个结点\n    if(pLastNodeOfRightList != null)&#123;\n        pLastNodeOfRightList.left = pRootOfTree;\n        pRootOfTree.right = pLastNodeOfRightList;\n    &#125;\n    //返回左子树的第一个结点\n    if(pLastNodeOfLeftList != null)&#123;\n        return pLastNodeOfLeftList;\n    &#125;\n\n    return pRootOfTree;\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","树","二叉树","双向链表"]},{"title":"有理数四则运算","url":"https://java4u.cn/算法/算法/有理数四则运算/","content":"题目描述\n本题要求编写程序，计算2个有理数的和、差、积、商。\n\n输入描述:\n输入在一行中按照“a1/b1 a2/b2”的格式给出两个分数形式的有理数，\n其中分子和分母全是整型范围内的整数，负号只可能出现在分子前，分母不为0。\n\n输出描述:\n分别在4行中按照“有理数1 运算符 有理数2 = 结果”的格式顺序输出2个有理数的和、差、积、商。\n注意输出的每个有理数必须是该有理数的最简形式“k a/b”，其中k是整数部分，a/b是最简分数部分；\n若为负数，则须加括号；\n若除法分母为0，则输出“Inf”。\n题目保证正确的输出中没有超过整型范围的整数。\n\n输入例子:\n5/3 0/6\n2/3 -4/2\n\n输出例子:\n1 2/3 + 0 = 1 2/31 2/3 - 0 = 1 2/31 2/3 * 0 = 01 2/3 / 0 = Inf\n2/3 + (-2) = (-1 1/3)2/3 - (-2) = 2 2/32/3 * (-2) = (-1 1/3)2/3 / (-2) = (-1/3)\n\n思路\n分解分数\n将分数形式的字符串，分解成整数+最简真分数形式的字符串\n整数部分为分子除以分母的值\n真分数部分的分子需要求余运算，若整体不是最简，需要同时除以最大公约数化为最简\n输出注意是否有0\n输出注意负数加括号\n\n\n四则运算\n四则运算的参数使用最初的分数形式\n左操作数的分子分母和右操作数的分子分母\n按分数的四则规则运算，并返回整数+最简真分数形式的字符串\n除法若除数的分子为0，返回Inf\n\n\n\n代码实现package com.liuyong666.pat;\nimport java.util.Scanner;\n\npublic class Main &#123;\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n        String left = sc.next();\n        String right = sc.next();\n\n        int  zi1 = Integer.parseInt(left.split(&quot;/&quot;)[0]);\n        int  mu1 = Integer.parseInt(left.split(&quot;/&quot;)[1]);\n        int  zi2 = Integer.parseInt(right.split(&quot;/&quot;)[0]);\n        int  mu2 = Integer.parseInt(right.split(&quot;/&quot;)[1]);\n\n        System.out.println(fenjieNum(left) + &quot; + &quot; + fenjieNum(right) + &quot; = &quot; +add(zi1,mu1,zi2,mu2));\n        System.out.println(fenjieNum(left) + &quot; - &quot; + fenjieNum(right) + &quot; = &quot; +sub(zi1,mu1,zi2,mu2));\n        System.out.println(fenjieNum(left) + &quot; * &quot; + fenjieNum(right) + &quot; = &quot; +mul(zi1,mu1,zi2,mu2));\n        System.out.println(fenjieNum(left) + &quot; / &quot; + fenjieNum(right) + &quot; = &quot; +div(zi1,mu1,zi2,mu2));\n    &#125;\n\n    //分解一个分数形式的有理数，返回表示有理数的字符串\n    public static String fenjieNum(String left)&#123;\n\n        StringBuilder newLeft = new StringBuilder();\n        int left_zi =  Integer.parseInt(left.split(&quot;/&quot;)[0]);\n        int left_mu = Integer.parseInt(left.split(&quot;/&quot;)[1]);\n\n        int left_zhengshu = left_zi / left_mu;\n        int left_fenshu_zi = left_zi % left_mu;\n        int left_fenshu_gcd = gcd(left_fenshu_zi,left_mu);\n        int left_new_zi = left_fenshu_zi / left_fenshu_gcd;\n        int left_new_mu = left_mu / left_fenshu_gcd;\n\n        if(left_zhengshu != 0 &amp;&amp; left_fenshu_zi != 0)&#123;\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;(-&quot;);\n            &#125;\n\n            newLeft.append(Math.abs(left_zhengshu));\n            newLeft.append(&quot; &quot;);\n            newLeft.append(Math.abs(left_new_zi) + &quot;/&quot; + Math.abs(left_new_mu));\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;)&quot;);\n            &#125;\n        &#125;else if(left_zhengshu != 0)&#123;\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;(&quot;);\n            &#125;\n\n            newLeft.append(left_zhengshu);\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;)&quot;);\n            &#125;\n        &#125;else if(left_fenshu_zi != 0)&#123;\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;(-&quot;);\n            &#125;\n\n            newLeft.append(Math.abs(left_new_zi) + &quot;/&quot; + Math.abs(left_new_mu));\n\n            if(left_zi * left_mu &lt; 0)&#123;\n                newLeft.append(&quot;)&quot;);\n            &#125;\n        &#125;else&#123;\n            newLeft.append(&quot;0&quot;);\n        &#125;\n\n        return newLeft.toString();\n    &#125;\n\n    //加法  5/3 0/6这种形式的俩字符串为参数\n    public static String add(int zi1, int mu1, int zi2, int mu2)&#123;\n\n        int new_zi = zi1 * mu2 + zi2 * mu1;\n        int new_mu = mu1 * mu2;\n        return fenjieNum(new_zi + &quot;/&quot; + new_mu);\n    &#125;\n    //减法\n    public static String sub(int zi1, int mu1, int zi2, int mu2)&#123;\n        int new_zi = zi1 * mu2 - zi2 * mu1;\n        int new_mu = mu1 * mu2;\n        return fenjieNum(new_zi + &quot;/&quot; + new_mu);\n    &#125;\n    //乘法\n    public static String mul(int zi1, int mu1, int zi2, int mu2)&#123;\n        return fenjieNum(zi1 * zi2 + &quot;/&quot; + mu1 * mu2);\n    &#125;\n    //除法\n    public static String div(int zi1, int mu1, int zi2, int mu2)&#123;\n        if(zi2 == 0)&#123;\n            return &quot;Inf&quot;;\n        &#125;\n        return mul(zi1, mu1, mu2, zi2);\n    &#125;\n    //最大公约数\n    public static int gcd(int x, int y)&#123;\n        return y == 0 ? x : gcd(y, x % y);\n    &#125;\n\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","算法","有理数","四则运算"]},{"title":"剑指Offer之二十六--复杂链表的复制","url":"https://java4u.cn/算法/算法/剑指Offer之二十六-复杂链表的复制/","content":"题目描述\n输入一个复杂链表（每个节点中有节点值，以及两个指针，一个指向下一个节点，另一个特殊指针指向任意一个节点）。\n复制一个复杂链表\n\n结点定义class RandomListNode &#123;\n    int label;\n    RandomListNode next = null;\n    RandomListNode random = null;\n\n    public RandomListNode(int label)&#123;\n        this.label = label;\n    &#125;\n&#125;\n解析\n遍历链表，每个结点后边复制相同的结点，设置next指针\n复制结点的特殊指针。如果原始链表上的结点N的random指向S，则它对应的复制结点N`的random指向S的下一个结点S`\n抽取复制结点，连起来得到复制链表\n\n代码实现public RandomListNode clone(RandomListNode pHead)&#123;\n    cloneNodes(pHead);\n    connectRandomNodes(pHead);\n    return reconnectNodes(pHead);\n&#125;\n\n//复制原始链表的任意结点N并创建新结点N`，再把N`链接到N的后面\nprivate void cloneNodes(RandomListNode pHead) &#123;\n    RandomListNode curNode = pHead;\n    while(curNode != null)&#123;\n        RandomListNode nextNode = curNode.next;\n        RandomListNode copyNode = new RandomListNode(curNode.label);\n        copyNode.next = nextNode;\n        copyNode.random = null;\n\n        curNode.next = copyNode;\n        curNode = copyNode.next;\n    &#125;\n\n&#125;\n\n//如果原始链表上的结点N的random指向S，则它对应的复制结点N`的random指向S的下一个结点S`\nprivate void connectRandomNodes(RandomListNode pHead) &#123;\n    RandomListNode curNode = pHead;\n    while(curNode != null)&#123;\n        RandomListNode copyNode = curNode.next;\n        if(curNode.random != null)&#123;\n            copyNode.random = curNode.random.next;\n        &#125;\n        curNode = copyNode.next;\n    &#125;\n\n&#125;\n\n//组合复制的结点\nprivate RandomListNode reconnectNodes(RandomListNode pHead) &#123;\n\n    RandomListNode curNode = pHead;\n    RandomListNode copyHead = null;\n    RandomListNode copyNode = null;\n\n    //设置头结点\n    if(curNode != null)&#123;\n        copyHead = curNode.next;\n        copyNode = curNode.next;\n        curNode.next = copyNode.next;\n        curNode = curNode.next;\n\n    &#125;\n\n    while(curNode != null)&#123;\n         copyNode.next = curNode.next;\n         copyNode = copyNode.next;\n         curNode.next = copyNode.next;\n         curNode = curNode.next;\n\n    &#125;\n    return copyHead;\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","链表","复制"]},{"title":"剑指Offer之二十五--二叉树中和为某一值的所有路径","url":"https://java4u.cn/算法/算法/剑指Offer之二十五-二叉树中和为某一值的所有路径/","content":"题目描述\n输入一颗二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。\n路径定义为从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。\n\n解析\n先序遍历，将遍历过的结点放到A集合中\n当遍历到叶子结点并且和恰好是目标值时，将遍历经过的所有结点放到B集合中，B则是满足题意的一条路径\n如果遍历到叶子结点和仍然不等于目标值，那么就移除A集合中添加的结点，修改和，切换到右孩子结点重新计算\n如果没有遍历到叶子结点就从孩子结点中继续寻找这样的路径\n\n二叉树定义class TreeNode &#123;\n    int val = 0;\n    TreeNode left = null;\n    TreeNode right = null;\n\n    public TreeNode(int val) &#123;\n        this.val = val;\n\n    &#125;\n\n&#125;\n代码实现public ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(TreeNode root,int target) &#123;\n    /*\n     * currentSum    记录当前和\n     * pathNodes    保存当前路径扫描过的结点\n     * pathList        保存满足条件的各个路径\n     */\n    int currentSum = 0;\n    ArrayList&lt;Integer&gt; pathNodes = new ArrayList&lt;Integer&gt;();\n    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;();\n\n    if(root == null)&#123;\n        return pathList;\n    &#125;\n\n    return findPath(pathList,pathNodes,root,target,currentSum);\n&#125;\n\n\nprivate ArrayList&lt;ArrayList&lt;Integer&gt;&gt; findPath(\n        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; pathList,\n        ArrayList&lt;Integer&gt; pathNodes,\n        TreeNode root, \n        int target, \n        int currentSum) &#123;\n\n    currentSum += root.val;\n    pathNodes.add(root.val);\n    boolean isLeafNode = root.left == null &amp;&amp; root.right == null;\n    //如果是叶子结点并且等于目标值，则把当前的路径添加到pathList中\n    if(currentSum == target &amp;&amp; isLeafNode)&#123;\n        ArrayList&lt;Integer&gt; nodes = new ArrayList&lt;Integer&gt;();\n        for(Integer node : pathNodes)&#123;\n            nodes.add(node);\n        &#125;\n        pathList.add(nodes);\n    &#125;\n    //如果不是叶子结点则遍历它的子结点\n    if(root.left != null)&#123;\n        findPath(pathList, pathNodes, root.left, target, currentSum);\n    &#125;\n    if(root.right != null)&#123;\n        findPath(pathList, pathNodes, root.right, target, currentSum);\n    &#125;\n\n    //在返回父节点之前，在路径上删除当前结点\n    Integer node = pathNodes.remove(pathNodes.size() - 1);\n    currentSum -= node;\n\n\n    return pathList;\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","树","先序遍历","路径"]},{"title":"struts2中动态方法调用和使用通配符定义action","url":"https://java4u.cn/struts2/struts2/struts2中动态方法调用和使用通配符定义action/","content":"动态方法调用\n如果Action中存在多个方法时，我们可以使用!+方法名调用指定方法。\n  public class HelloWorldAction&#123;  \n      private String message;  \n      ....  \n      public String execute() throws Exception&#123;  \n          this.message = &quot;我的第一个struts2应用&quot;;  \n          return &quot;success&quot;;  \n      &#125;  \n\n      public String other() throws Exception&#123;  \n          this.message = &quot;第二个方法&quot;;  \n          return &quot;success&quot;;  \n      &#125;  \n  &#125;  \n\n假设访问上面action的URL路径为： /struts/test/helloworld.action要访问action的other() 方法，我们可以这样调用：\n  /struts/test/helloworld!other.action\n\n通常不建议使用动态方法调用，我们可以通过常量关闭动态方法调用。\n  &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot;/&gt;\n\n\n使用通配符定义action\naction代码同上，配置文件如下：\n  &lt;package name=&quot;liuyong666&quot; namespace=&quot;/test&quot; extends=&quot;struts-default&quot;&gt;  \n      &lt;action name=&quot;helloworld_*&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot; method=&quot;&#123;1&#125;&quot;&gt;  \n          &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;  \n      &lt;/action&gt;  \n  &lt;/package&gt;  \n\n其中的helloworld_*中的下划线（_）并不是必须的\n\n因为helloworld_*中只有一个通配符*,所以method=”{1}”\n\n也可以是helloworld_*_*,则method=”{1}_{2}”\n\nclass和result中也可以使用通配符的值，如：\n  class=&quot;com.liuyong666.action.&#123;1&#125;HelloWorldAction&quot;\n  －－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－\n  &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/&#123;1&#125;hello.jsp&lt;/result&gt;.\n\n此时要访问action中的other()方法，可以通过这样的URL访问：\n  /test/helloworld_other.action\n\n\n\n\n","categories":["struts2"],"tags":["struts2","动态方法","通配符"]},{"title":"struts2中为应用指定多个struts配置文件","url":"https://java4u.cn/struts2/struts2/struts2中为应用指定多个struts配置文件/","content":"概述\n随着应用规模的增加，系统中Action的数量也会大量增加，导致struts.xml配置文件变得非常臃肿\n为了避免struts.xml文件过于庞大、臃肿，提高Struts.xml文件的可读性，我们可以将一个struts.xml配置文件分解成多个配置文件\n然后再struts.xml文件中包含其他配置文件\n\n操作\n通过&lt;include&gt;元素指定多个配置文件 \n  &lt;struts&gt;\n      &lt;include file=&quot;department.xml&quot;/&gt; 一个模块使用一个配置文件\n      &lt;include file=&quot;employee.xml&quot;/&gt;\n  &lt;/struts&gt;\n\n通过这种方式，可以将struts2的Action按模块添加到多个配置文件中\n\n\n\n\n","categories":["struts2"],"tags":["struts2","配置分解"]},{"title":"每K个结点反转单链表","url":"https://java4u.cn/算法/算法/每K个结点反转单链表/","content":"题目描述\n给定一个常数K以及一个单链表L，请编写程序将L中每K个结点反转。\n例如：给定L为1→2→3→4→5→6，K为3，则输出应该为3→2→1→6→5→4；\n如果K为4，则输出应该为4→3→2→1→5→6，即最后不到K个元素不反转。\n\n思路\n通过链表长度和K值确定需要反转的结点数\n每K个反转成新链表，把头保存到List中\n需要反转的结点数已到并且剩下的结点数不足K个，不反转，即把当前结点存到List中\n把List中各个链表连接\n\n代码package com.liuyong666.pat;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main &#123;\n    static class ListNode&#123;\n        int val;\n        ListNode next = null;\n        public ListNode(int val)&#123;\n            this.val = val;\n        &#125;\n    &#125;\n    public static ListNode reversePartNode(ListNode head, int k)&#123;\n\n        if(head == null || k &lt; 1)&#123;\n            return null;\n        &#125;\n\n        ListNode p = head;\n        //获取链表长度\n        int len = 0;\n        while(p != null)&#123;\n            len++;\n            p = p.next;\n        &#125;\n\n        ListNode reverseListHead = null;\n        ListNode curNode = head;\n        ListNode preNode = null;\n        ListNode nextNode = null;\n        //List存放各链表头结点\n        List&lt;ListNode&gt; list = new ArrayList&lt;ListNode&gt;();\n\n        //count 计数器 记录k个元素，每k个重新置1\n        int count = 1;\n        //需要发生反转的结点个数\n        int reverseNum = (len / k) * k;\n        while(curNode != null)&#123;\n\n            nextNode = curNode.next;\n\n            if( count &lt;= k)&#123;\n\n                if(count == k)&#123;\n\n                    reverseListHead = curNode;\n                    list.add(reverseListHead);\n                    count = 1;\n\n                    curNode.next = preNode;\n                    preNode = null;\n                    curNode = nextNode;\n                &#125;else&#123;\n                    count++;\n\n                    curNode.next = preNode;\n                    preNode = curNode;\n                    curNode = nextNode;\n                &#125;\n            &#125;\n\n            if(reverseNum == 1 &amp;&amp; count != k)&#123;\n                list.add(curNode);\n                break;\n            &#125;\n\n            reverseNum--;\n\n        &#125;\n        ListNode newHead = list.get(0);\n\n        for(int i = 0; i &lt; list.size() - 1; i++)&#123;\n            p = list.get(i);\n            while(p.next != null)&#123;\n                p = p.next;\n            &#125;\n            p.next = list.get(i + 1);\n\n        &#125;\n\n        return newHead;\n    &#125;\n&#125;\n    public static void main(String[] args) &#123;\n        ListNode node1 = new ListNode(1);\n        ListNode node2 = new ListNode(2);\n        ListNode node3 = new ListNode(3);\n        ListNode node4 = new ListNode(4);\n        ListNode node5 = new ListNode(5);\n        ListNode node6 = new ListNode(6);\n        node1.next = node2;\n        node2.next = node3;\n        node3.next = node4;\n        node4.next = node5;\n        node5.next = node6;\n        ListNode p = node1;\n        while(p != null)&#123;\n            System.out.print(p.val+&quot; &quot;);\n            p = p.next;\n        &#125;\n        System.out.println();\n\n        ListNode revNode = reversePartNode(node1, 4);\n        while(revNode != null)&#123;\n            System.out.print(revNode.val+&quot; &quot;);\n            revNode = revNode.next;\n        &#125;\n\n    &#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","链表","链表反转"]},{"title":"科学计数法","url":"https://java4u.cn/算法/算法/科学计数法/","content":"题目描述\n科学计数法是科学家用来表示很大或很小的数字的一种方便的方法\n其满足正则表达式[+-][1-9]”.”[0-9]+E[+-][0-9]+\n即数字的整数部分只有1位，小数部分至少有1位，该数字及其指数部分的正负号即使对正数也必定明确给出\n现以科学计数法的格式给出实数A，请编写程序按普通数字表示法输出A，并保证所有有效位都被保留\n\n输入描述:\n每个输入包含1个测试用例，即一个以科学计数法表示的实数A。\n该数字的存储长度不超过9999字节，且其指数的绝对值不超过9999。\n\n输出描述:\n对每个测试用例，在一行中按普通数字表示法输出A，并保证所有有效位都被保留，包括末尾的0。\n\n样例\n输入样例1：\n\n\n+1.23400E-03\n\n\n输出样例1：\n\n\n0.00123400\n\n\n输入样例2：\n\n\n1.2E+10\n\n\n输出样例2：\n\n\n12000000000\n\n思路\n使用字符串来表示数值；\n负指数往前移动小数点，补0；\n正指数往后移动小数点，需要时补0或去掉小数点；\n表示数值时正号不显示，负号显示；\n\n代码package com.liuyong666.pat;\n\nimport java.util.Scanner;\n\npublic class Main &#123;\n\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n        String a = sc.nextLine();\n        /**\n         * isFuZhiShu    指数是否为负\n         * zhishu        指数的值\n         * e_index        E的索引值\n         * dian_index    .的索引值\n         * quE            E之前数值的绝对值\n         */\n        boolean isFuZhiShu = false;\n        int zhishu = Integer.parseInt(a.substring(a.lastIndexOf(&#39;E&#39;) + 1));\n        int e_index = a.indexOf(&#39;E&#39;);\n        int dian_index = a.indexOf(&#39;.&#39;);\n        StringBuffer quE = new StringBuffer(a.substring(1,e_index));\n\n        //判断输入字符串是否是负指数\n        if(a.charAt(a.lastIndexOf(&#39;E&#39;) + 1) == &#39;-&#39;)&#123;\n            isFuZhiShu = true;\n        &#125;\n\n        //负指数的情况下，在前边加若干个0，再加个.再加个0\n        if(isFuZhiShu)&#123;\n            if(-zhishu &gt; 0)&#123;\n                quE.deleteCharAt(1);\n                for(int i = 0; i &lt; -zhishu - 1; i++)&#123;\n                    quE.insert(0, &#39;0&#39;);\n                &#125;\n                quE.insert(0, &#39;.&#39;);\n                quE.insert(0, &#39;0&#39;);\n            &#125;\n            //输出需要把正负表示出来，正号不显示，负号显示\n            System.out.println((a.charAt(0) == &#39;+&#39; ? &quot;&quot;:&quot;-&quot;) + quE.toString());\n\n        //正指数的情况下，往后移动.的位置，按照需求补充0\n        &#125;else&#123;\n            if(zhishu &gt; 0)&#123;\n                quE.deleteCharAt(1);\n                int dian_e_len = e_index - dian_index - 1;\n                if(dian_e_len - zhishu &gt; 0)&#123;\n                    quE.insert(zhishu + 1, &#39;.&#39;);\n\n                &#125;else&#123;\n                    for(int i = 0; i &lt; zhishu - dian_e_len; i++)&#123;\n                        quE.insert(quE.length(), &#39;0&#39;);\n                    &#125;\n                &#125;\n\n            &#125;\n            System.out.println((a.charAt(0) == &#39;+&#39; ? &quot;&quot;:&quot;-&quot;) + quE.toString());\n        &#125;\n    &#125;\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","科学计数法"]},{"title":"struts2中struts2的处理流程和对Action的管理方式","url":"https://java4u.cn/struts2/struts2/struts2中struts2的处理流程和对Action的管理方式/","content":"处理流程图\nweb.xml配置文件的常用代码&lt;filter&gt;\n    &lt;filter-name&gt;struts2&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;struts2&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\nStrutsPrepareAndExecuteFilter\nStruts2核心控制器，它只负责拦截由/*指定的所有用户的请求\n当用户请求到达时，系统会根据web.xml中配置Filter过滤用户的请求\n默认情况下，如果用户的访问路径不带有后缀或者是以.action的后缀作为结尾，这时候请求会转发给Struts2框架处理，否则Struts2会滤过这个请求处理\n当请求转入Struts2框架时会先经过一系列的拦截器，然后再到Action\n\nAction在struts1和struts2中的区别\nStruts2会对每个请求都会产生一个Action，所以Struts2是线程安全的，属于原型设计模式。\nStruts1中的Action创建出来之后会放在缓冲中，属于单例设计模式，在应用生命周期之内只会存在一个Action。\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","Action"]},{"title":"struts2中指定struts2处理的请求后缀","url":"https://java4u.cn/struts2/struts2/struts2中指定struts2处理的请求后缀/","content":"概述\n默认情况下我们都是使用.action后缀访问Action。\n\n其实默认后缀是可以通过常量”struts.action.extension“进行修改的。\n\n我们可以配置Struts 2只处理以.do为后缀的请求路径\n  &lt;struts&gt;  \n      &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;/&gt;  \n  &lt;/struts&gt;  \n\n如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。如：\n  &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do,go&quot;/&gt;\n\n一些常用的常量\n  &lt;!-- 指定默认编码集,作用于HttpServletRequest的setCharacterEncoding方法 和freemarker 、velocity的输出 --&gt;  \n  &lt;constant name=&quot;struts.i18n.encoding&quot; value=&quot;UTF-8&quot;/&gt;  \n\n  &lt;!-- 该属性指定需要Struts 2处理的请求后缀，该属性的默认值是action，即所有匹配*.action的请求都由Struts2处理。\n       如果用户需要指定多个请求后缀，则多个后缀之间以英文逗号（,）隔开。 --&gt;  \n  &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;/&gt;  \n\n  &lt;!-- 设置浏览器是否缓存静态内容,默认值为true(生产环境下使用),开发阶段最好关闭 --&gt;  \n  &lt;constant name=&quot;struts.serve.static.browserCache&quot; value=&quot;false&quot;/&gt;  \n\n  &lt;!-- 当struts的配置文件修改后,系统是否自动重新加载该文件,默认值为false(生产环境下使用),开发阶段最好打开 --&gt;  \n  &lt;constant name=&quot;struts.configuration.xml.reload&quot; value=&quot;true&quot;/&gt;  \n\n  &lt;!-- 开发模式下使用,这样可以打印出更详细的错误信息 --&gt;  \n  &lt;constant name=&quot;struts.devMode&quot; value=&quot;true&quot; /&gt;  \n\n  &lt;!-- 默认的视图主题 --&gt;  \n  &lt;constant name=&quot;struts.ui.theme&quot; value=&quot;simple&quot; /&gt;  \n\n  &lt;!– 与spring集成时，指定由spring负责action对象的创建 --&gt;  \n  &lt;constant name=&quot;struts.objectFactory&quot; value=&quot;spring&quot; /&gt;  \n\n  &lt;!–该属性设置Struts 2是否支持动态方法调用，该属性的默认值是true。如果需要关闭动态方法调用，则可设置该属性为false。 --&gt;  \n  &lt;constant name=&quot;struts.enable.DynamicMethodInvocation&quot; value=&quot;false&quot;/&gt;  \n\n  &lt;!--上传文件的大小限制--&gt;  \n  &lt;constant name=&quot;struts.multipart.maxSize&quot; value=“10701096&quot;/&gt;  \n常量定义位置\n常量可以在struts.xml或struts.properties中配置，建议在struts.xml中配置\n\n两种配置方式如下：\n\n\n\n在struts.xml文件中配置常量\n     &lt;struts&gt;  \n         &lt;constant name=&quot;struts.action.extension&quot; value=&quot;do&quot;/&gt;  \n     &lt;/struts&gt;  \n\n在struts.properties中配置常量\n     struts.action.extension=do\n\n\n\n也可在多个配置文件中进行定义\n\nstruts2加载常量的搜索顺序\nstruts-default.xml\nstruts-plugin.xml\nstruts.xml\nstruts.properties\nweb.xml\n如果在多个文件中配置了同一个常量，则后一个文件中配置的常量值会覆盖前面文件中配置的常量值.\n\n\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","请求后缀"]},{"title":"struts2中为Action属性注入值","url":"https://java4u.cn/struts2/struts2/struts2中为Action属性注入值/","content":"概述\nstruts2为Action中的属性提供了依赖注入功能\n在struts2的配置文件中，我们可以很方便地为Action中的属性注入值。注意：属性必须提供get,set方法。\n\n配置&lt;action name=&quot;helloworld&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot;&gt;\n    &lt;param name=&quot;savePath&quot;&gt;/resource&lt;/param&gt;\n    &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;\n&lt;/action&gt;\n对应类中的变化public class HelloWorldAction&#123;\n      private String savePath;\n\n      public String getSavePath() &#123;\n          return savePath;\n      &#125;\n      public void setSavePath(String savePath) &#123;\n          this.savePath = savePath;\n      &#125;\n       ......\n&#125;\n好处\n上面通过节点为action的savePath属性注入“/resource”，可以再hello.jsp页面获取/resource\n为action注入属性值应用于经常换的变量，这样不用更换源代码。\n比如该变量为使用该软件公司的名称\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","属性注入"]},{"title":"剑指Offer之二十四--二叉搜索树的后序遍历序列","url":"https://java4u.cn/算法/算法/剑指Offer之二十四-二叉搜索树的后序遍历序列/","content":"题目描述\n输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。\n如果是则返回ture,否则返回false。\n假设输入的数组的任意两个数字都互不相同。\n\n解析\n找到根结点\n从头遍历序列，第一个比根结点大的元素为右子树的起点\n判断右子树是否都比根结点大，若不是返回false，若是，进行下一步\n分别把左子树和右子树都以上面规则进行判断，若左右子树都能返回true，则整个序列为二叉搜索树的后序遍历序列，返回true\n\n代码实现public boolean verifySquenceOfBST(int [] sequence) &#123;\n\n    if(sequence == null || sequence.length == 0)&#123;\n        return false;\n    &#125;\n\n    int len = sequence.length;\n    int root = sequence[len - 1];\n\n    int i = 0;\n    for(; i &lt; len - 1; i++)&#123;\n        if(sequence[i] &gt; root)&#123;\n            break;\n        &#125;\n    &#125;\n\n    int j = i;\n    for(;j &lt; len - 1; j++)&#123;\n        if(sequence[j] &lt; root)&#123;\n            return false;\n        &#125;\n    &#125;\n\n    boolean left = true;\n    boolean right = true;\n    if(i &gt; 0)&#123;\n        left = verifySquenceOfBST(Arrays.copyOfRange(sequence, 0, i));\n    &#125;\n    if(i &lt; len - 1)&#123;\n        right = verifySquenceOfBST(Arrays.copyOfRange(sequence,i,len - 1));\n    &#125;\n\n    return left &amp;&amp; right;\n&#125;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","树","后序遍历","二叉搜索树"]},{"title":"剑指Offer之二十三--从上往下打印二叉树","url":"https://java4u.cn/算法/算法/剑指Offer之二十三-从上往下打印二叉树/","content":"二叉树结构class TreeNode &#123;\n    int val = 0;\n    TreeNode left = null;\n    TreeNode right = null;\n\n    public TreeNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n题目描述\n从上往下打印出二叉树的每个节点，同层节点从左至右打印。\n\n解析\n考察层序遍历\n每一次打印一个结点的时候，如果该结点有子节点，则把该结点的子节点放到一个队列的末尾。\n接下来到队列的头部取出最早进入队列的结点，重复前面的打印操作，直至队列中所有的结点都被打印出来为止。\n\n代码实现public ArrayList&lt;Integer&gt; printFromTopToBottom(TreeNode root) &#123;\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if(root==null)&#123;\n        return list;\n    &#125;\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n    queue.offer(root);\n    while (!queue.isEmpty()) &#123;\n        TreeNode treeNode = queue.poll();\n        if (treeNode.left != null) &#123;\n            queue.offer(treeNode.left);\n        &#125;\n        if (treeNode.right != null) &#123;\n            queue.offer(treeNode.right);\n        &#125;\n        list.add(treeNode.val);\n    &#125;\n    return list;\n&#125;\n辅助包import java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","树","二叉树","层序遍历"]},{"title":"剑指Offer之二十二--栈的压入、弹出序列","url":"https://java4u.cn/算法/算法/剑指Offer之二十二-栈的压入、弹出序列/","content":"题目描述\n输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。\n假设压入栈的所有数字均不相等。\n例如序列12345是某栈的压栈序列，序列45321是该压栈序列对应的一个弹出序列，但43512就不可能是该压栈序列的弹出序列。\n\n解析\n栈的特点是FIFO\n压入序列是确定的，则压入序列之间的元素可能会经历压入后马上被弹出的情况\n具体思路为：\n\n\n根据弹出序列的第一个值，判断在该元素之前被压入栈的所有元素.\n栈顶元素与弹出序列第一个值进行比较，等则判断弹出序列的下一个元素，判断依据同步骤1。\n如果所有的元素都被压入栈中，但是两者仍然不相等，说明弹出序列不可能是原序列的弹出序列。\n这样一直判断直到弹出序列的最后一个元素。\n\n代码实现public boolean IsPopOrder(int [] pushA,int [] popA) &#123;\n    boolean possible = false;\n    //存放压入栈中的元素\n    ArrayList&lt;Integer&gt; data = new ArrayList&lt;Integer&gt;();\n    if(pushA.length &gt; 0 &amp;&amp; popA.length &gt; 0 &amp;&amp; pushA.length == popA.length)&#123;\n        int len = pushA.length;\n        //第一个弹出元素位置\n        int pop = 0;\n        //下一个要弹出元素的位置\n        int nextPop = 0;\n\n        //第一个压入栈中的元素位置\n        int push = 0;\n        //下一个要压入栈中的元素位置\n        int nextPush = 0;\n\n        int index = -1;\n        while(nextPop - pop &lt; len)&#123;\n            //如果要弹出的元素与栈顶元素不相等，就一直压栈直到相等\n            while(data.size() == 0 || data.get(index) != popA[nextPop])&#123;\n\n                //当全部元素添加完毕之后，结束循环\n                if(nextPush - push == len)&#123;\n                    break;\n                &#125;\n\n                data.add(pushA[nextPush]);\n                nextPush++;\n                index++;\n\n            &#125;\n            if(data.get(index) != popA[nextPop])&#123;\n                break;\n            &#125;\n\n            //移除第一个比较的元素\n            data.remove(index--);\n            //判断下一个待弹出元素\n            nextPop++;\n\n        &#125;\n        //在集合全部元素比较完毕并且弹出序列也比较完毕\n        if(data.size() == 0 &amp;&amp;  nextPop - pop == len)&#123;\n            possible = true;\n        &#125;\n    &#125;\n    return possible;\n\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","栈"]},{"title":"struts2中Result配置的各种视图转发类型","url":"https://java4u.cn/struts2/struts2/struts2中Result配置的各种视图转发类型/","content":"概述&lt;action name=&quot;helloworld&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot;&gt;\n    &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;\n&lt;/action&gt;\n\nresult配置类似于struts1中的forward，但struts2中提供了多种结果类型，常用的类型有：\n\n\n dispatcher(默认值)、\n redirect(重定向) 、\n redirectAction 、 \n plainText\n\n\n通过type属性值指定。 \n\n结果类型\nredirect\n\n\n在result中还可以使用${属性名}表达式访问action中的属性，表达式里的属性名对应action中的属性。如下：\n     &lt;result type=&quot;redirect&quot;&gt;/view.jsp?id=$&#123;id&#125;&lt;/result&gt;\n\n\n\nredirectAction\n\n\n如果重定向的action在同一个包下：\n     &lt;result type=&quot;redirectAction&quot;&gt;helloworld&lt;/result&gt;\n\n如果重定向的action在别的命名空间下：\n     &lt;result type=&quot;redirectAction&quot;&gt;\n         &lt;param name=&quot;actionName&quot;&gt;helloworld&lt;/param&gt;\n         &lt;param name=&quot;namespace&quot;&gt;/test&lt;/param&gt;\n     &lt;/result&gt;\n\n\n\nplainText\n\n\n显示原始文件内容，例如：当我们需要原样显示jsp文件源代码的时候，我们可以使用此类型。\n     &lt;result name=&quot;source&quot; type=&quot;plainText&quot;&gt;\n         &lt;param name=&quot;location&quot;&gt;/xxx.jsp&lt;/param&gt;\n         &lt;param name=&quot;charSet&quot;&gt;UTF-8&lt;/param&gt;&lt;!-- 指定读取文件的编码 --&gt;\n     &lt;/result&gt;\n\n\n全局结果集(Globle Result)\n当有多个Action使用同一个结果集时，则可以使用全局结果集(Globle Result),如下：\n  &lt;global-results&gt; &lt;!-- 定义在包里 --&gt;\n      &lt;result name=&quot;mainpage&quot;&gt;/main.jsp&lt;/result&gt;\n  &lt;/global-results&gt;\n\n多个包想使用同一个结果集，可以利用包的继承，实现代码重用。\n\n\n\n创建一个名叫”base”的package，让它继承”struts-default”\n该package里放入共用的global-results\n想要使用该结果集的包继承”base”\n\n \n\n","categories":["struts2"],"tags":["ssh","struts2","Result配置","视图转发类型"]},{"title":"struts2中Action配置的各项默认值","url":"https://java4u.cn/struts2/struts2/struts2中Action配置的各项默认值/","content":"Action中的各项默认值\nAction各项配置\n    &lt;action name=&quot;helloworld&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot; method=&quot;execute&quot; &gt;\n       &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;\n   &lt;/action&gt;\n\nAction默认配置\n  &lt;action name=&quot;helloworld&quot;&gt;\n      &lt;result&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;\n  &lt;/action&gt;\n\n默认值\n\n\n\n如果没有为action指定class，默认是ActionSupport。\n如果没有为action指定method，默认执行action中的execute() 方法。\n如果没有指定result的name属性，默认值为success。\n\n \n\n","categories":["struts2"],"tags":["ssh","struts2","Action配置"]},{"title":"struts2中Action名称的搜索顺序","url":"https://java4u.cn/struts2/struts2/struts2中Action名称的搜索顺序/","content":"搜索顺序\n1.获得请求路径的URI，例如URL为：http://localhost:8080/struts2/path1/path2/path3/student.action\n\n2.首先寻找namespace为/path1/path2/path3的package，\n\n如果不存在这个包，则执行步骤3；\n     如果存在这个package，则在这个package中寻找名字为student的action，\n     当在该package下寻找不到action时就会直接跑到默认namespace的package中寻找action\n     (默认的命名空间为空字符串&quot;&quot;)，\n     如果在默认namespace的package中还找不到该action，页面会提示找不action。\n\n3.寻找namespace为/path1/path2的package，\n\n如果不存在这个package，则执行步骤4；\n\n如果存在执行步骤2中的代码块中内容。\n\n4.寻找namespace为/path1的package，\n\n如果不存在这个package，则执行步骤5；\n\n如果存在执行步骤2中的代码块中内容。\n\n5.寻找namespace为/的package，\n\n如果存在这个package，则在这个package中寻找名字为student的action，\n\n当在package中找不到action或者不存在这个package时，都会去默认namespace的package里面寻找actin，\n\n如果还是找不到，页面会提示找不到action。\n\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2","Action"]},{"title":"数字黑洞","url":"https://java4u.cn/算法/算法/数字黑洞/","content":"题目描述\n给定任一个各位数字不完全相同的4位正整数，如果我们先把4个数字按非递增排序，再按非递减排序\n然后用第1个数字减第2个数字，将得到一个新的数字。\n一直重复这样做，我们很快会停在有“数字黑洞”之称的6174，这个神奇的数字也叫Kaprekar常数。\n\n输入描述\n输入给出一个(0, 10000)区间内的正整数N。\n\n输出描述:\n如果N的4位数字全相等，则在一行内输出“N - N = 0000”\n否则将计算的每一步在一行内输出，直到6174作为差出现\n注意每个数字按4位数格式输出。\n\n代码实现package com.liuyong666.pat;\nimport java.util.Arrays;\nimport java.util.Scanner;\npublic class Main &#123;\n\n    public static void main(String[] args) &#123;\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        while(true)&#123;\n\n            int[] arr = new int[4];\n            arr[0] = n / 1000;\n            arr[1] = (n - arr[0] * 1000) / 100;\n            arr[2] = (n - arr[0] * 1000 -arr[1] * 100) / 10;\n            arr[3] = n % 10;\n\n            String temp = &quot;&quot;+arr[0]+arr[1]+arr[2]+arr[3];\n            if(arr[0] == arr[1] &amp;&amp; arr[0] == arr[1] &amp;&amp; arr[0] == arr[2] &amp;&amp; arr[0] == arr[3])&#123;\n                System.out.println(temp+&quot; - &quot;+temp+&quot; = 0000&quot;);\n                break;\n            &#125;\n\n            Arrays.sort(arr);\n\n            StringBuilder str =new StringBuilder();\n            for(int i = 0; i &lt; 4; i++)&#123;\n                str.append(Integer.toString(arr[i]));\n            &#125;\n\n            StringBuilder xiao_str = new StringBuilder(str);\n            StringBuilder da_str = str.reverse();\n\n            n = Integer.valueOf(da_str.toString()) - Integer.valueOf(xiao_str.toString());\n            System.out.println(da_str.toString()+&quot; - &quot;+xiao_str.toString()+&quot; = &quot; + n);\n\n            if(n == 6174)&#123;\n                break;\n            &#125;\n        &#125;\n\n\n    &#125;\n\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","算法","数字","黑洞"]},{"title":"struts2介绍","url":"https://java4u.cn/struts2/struts2/struts2介绍/","content":"struts2优点\n与Servlet API 耦合性低。无侵入式设计\n提供了拦截器，利用拦截器可以进行AOP编程，实现如权限拦截等功能\n支持多种表现层技术，如：JSP、freeMarker、velocity等\n输入校验可以对指定方法进行校验，解决了struts1长久之痛\n提供了全局范围、包范围和Action范围的国际化资源文件管理实现\n\n搭建struts2开发环境1. 导包\nstruts2-core-2.x.x.jar：核心类库\nxwork-2.x.x.jar：XWork类库，struts2在其上构建\nognl-2.6.x.jar：对象图导航语言，struts2通过其读写对象属性\nfreemarker-2.3.x.jar：struts2的UI标签的模板使用FreeMarker编写\ncommons-logging-1.1.x.jar：ASF出品的日志包，struts2使用这个日志包来支持log4j和jdk1.4+的日志目录\ncommons-fileupload-1.2.1.jar：文件上传组件，2.1.6后必须加入此文件\n\n2. 配置web.xml文件&lt;filter&gt;\n    &lt;filter-name&gt;struts2&lt;/filter-name&gt;\n    &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;\n&lt;/filter&gt;\n\n&lt;filter-mapping&gt;\n    &lt;filter-name&gt;struts2&lt;/filter-name&gt;\n    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;\n&lt;/filter-mapping&gt;\n\nstruts2框架通过Filter启动\nStrutsPrepareAndExecuteFilter的init()方法中将会读取类路径下默认的配置文件struts.xml完成初始化操作\nstruts2读取到struts.xml的内容后，以JavaBean形式存放在内存中，以后struts2对用户的每次请求处理将使用内存中的数据，而不是每次都读取struts.xml文件\n\n3. 编写Action类，这是我们的逻辑控制器package com.liuyong666.action;\n\npublic class HelloWorldAction &#123;\n    private String msg;\n\n    public String getMessage() &#123;\n        return msg;\n    &#125;\n\n    public String execute()&#123;\n        msg = &quot;我的第一个struts2应用&quot;;\n        return &quot;success&quot;;\n    &#125;\n&#125;\n4. 配置src/struts.xml，核心配置文件中配置action&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;\n&lt;!DOCTYPE struts PUBLIC\n    &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot;\n    &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;\n\n&lt;struts&gt;\n   &lt;package name=&quot;liuyong666&quot; namespace=&quot;/test&quot; extends=&quot;struts-default&quot;&gt;\n        &lt;action name=&quot;helloworld&quot; class=&quot;com.liuyong666.action.HelloWorldAction&quot; method=&quot;execute&quot; &gt;\n            &lt;result name=&quot;success&quot;&gt;/WEB-INF/page/hello.jsp&lt;/result&gt;\n        &lt;/action&gt;\n    &lt;/package&gt; \n&lt;/struts&gt;\n\n在struts2中使用包管理Action\n配置包时必须指定name属性，可以任意名，但必须唯一\nnamespace定义该包的命名空间，为访问该包下Action的路径的一部分，如上边例子的访问路径为：/test/helloworld.action。也可以不配置\n继承struts-default包，该包拥有struts2提供的核心功能，拥有各种拦截器。\n包可通过abstract=”true”定义为抽象包，抽象包中不能包含action\n\n\n\n","categories":["struts2"],"tags":["ssh","struts2"]},{"title":"Java线程池的分析与使用","url":"https://java4u.cn/Java/Java/Java线程池的分析与使用/","content":"为什么需要使用线程池\n降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗\n提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行\n提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程次可以进行统一的分配，调优和监控。\n\n线程池的创建\n我们可以通过ThreadPoolExecutor来创建一个线程池。\nnew  ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, milliseconds,runnableTaskQueue, handler);\n需要的几个参数：\n\n\ncorePoolSize（线程池的基本大小）：\n\n当提交一个任务到线程池时，线程池会创建一个线程来执行任务，\n即使其他空闲的基本线程能够执行新任务也会创建线程，\n等到需要执行的任务数大于线程池基本大小时就不再创建。\n如果调用了线程池的prestartAllCoreThreads方法，线程池会提前创建并启动所有基本线程。\n\n\nrunnableTaskQueue（任务队列：用于保存等待执行的任务的阻塞队列。\n\nArrayBlockingQueue：基于数组，有界，FIFO\nLinkedBlockingQueue：基于链表，FIFO，吞吐量高于ArrayBlockingQueue，静态工厂方法Executors.newFixedThreadPool()使用了这个队列\nSynchronousQueue：不存储元素，插入操作须等到另一个线程调用移除操作，吞吐量高于LinkedBlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列\nPriorityBlockingQueue：一个具有优先级的无限阻塞队列\n\n\nmaximumPoolSize（线程池最大大小）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。无界任务队列无效。\n\nThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。\n\nRejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。\n\n以下是JDK1.5提供的四种策略。\nAbortPolicy：直接抛出异常。\nCallerRunsPolicy：只用调用者所在线程来运行任务。\nDiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。\nDiscardPolicy：不处理，丢弃掉。\n\n\n当然也可以根据应用场景需要来实现RejectedExecutionHandler接口自定义策略。如记录日志或持久化不能处理的任务。\n\n\nkeepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。\n\nTimeUnit（线程活动保持时间的单位）：\n\n可选的单位有天（DAYS），小时（HOURS），\n分钟（MINUTES），毫秒(MILLISECONDS)，\n微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。\n\n\n\n向线程池提交任务\nexecute\n\n\n无返回值，无法判断任务是否被线程执行成功\n\n\nthreadsPool.execute(new Runnable() &#123;\n        @Override\n        public void run() &#123;\n\n        &#125;\n&#125;);\n\nsubmit\n\n\n返回future，以此判断任务是否执行成功\n通过future的get方法来获取返回值，get方法会阻塞直到任务完成\nget(long timeout, TimeUnit unit)方法则会阻塞一段时间后立即返回，这时有可能任务没有执行完\n\n\nFuture&lt;Object&gt; future = executor.submit(harReturnValuetask);\ntry &#123;\n     Object s = future.get();\n&#125; catch (InterruptedException e) &#123;\n    // 处理中断异常\n&#125; catch (ExecutionException e) &#123;\n    // 处理无法执行任务异常\n&#125; finally &#123;\n    // 关闭线程池\n    executor.shutdown();\n&#125;\n线程池的关闭\nshutdown\n\n\n设置线程池状态为SHUTDOWN，中断暂停任务的线程\n\n\nshutdownNow\n\n\n设置线程池状态为STOP，中断正在执行或暂停任务的线程\n返回等待执行任务的列表\n\n\n都是遍历线程池中的工作线程，逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止\n通常调用shutdown来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow\n\n线程池的分析\n工作流程如图:\n提交一个新任务到线程池时，线程池处理流程如下：\n\n\n首先线程池判断基本线程池是否已满？没满，创建一个工作线程来执行任务。满了，则进入下个流程。\n其次线程池判断工作队列是否已满？没满，则将新提交的任务存储在工作队列里。满了，则进入下个流程。\n最后线程池判断整个线程池是否已满？没满，则创建一个新的工作线程来执行任务，满了，则交给饱和策略来处理这个任务。\n\n\n源码实现\n\n\npublic void execute(Runnable command) &#123;\n    if (command == null)&#123;\n       throw new NullPointerException();\n    &#125;\n    //如果线程数小于基本线程数，则创建线程并执行当前任务 \n    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;\n    //如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。\n        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;\n            if (runState != RUNNING || poolSize == 0)\n                      ensureQueuedTaskHandled(command);\n        &#125;\n    //如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，则创建一个线程执行任务。\n        else if (!addIfUnderMaximumPoolSize(command))\n            //抛出RejectedExecutionException异常\n            reject(command);     // is shutdown or saturated\n    &#125;\n&#125;\n\n工作线程：\n\n\n线程池创建线程时，会将线程封装成工作线程Worker，Worker在执行完任务后，还会无限循环获取工作队列里的任务来执行。\n我们可以从Worker类的run方法里看到这点\n\n\npublic void run() &#123;\n     try &#123;\n           Runnable task = firstTask;\n           firstTask = null;\n            while (task != null || (task = getTask()) != null) &#123;\n                    runTask(task);\n                    task = null;\n            &#125;\n      &#125; finally &#123;\n             workerDone(this);\n      &#125;\n&#125; \n合理的配置线程池\n任务特性\n\n\n任务的性质：\nCPU密集型任务\nIO密集型任务\n混合型任务\n\n\n任务的优先级：高，中，低\n任务的执行时间：长，中，短\n任务的依赖性：是否依赖其他系统资源，如数据库连接\n\n\n如何为不同特性的任务配置线程池\n\n\n性质不同，用不同规模的线程池分开处理\nCPU密集型任务配置尽可能小的线程，如配置Ncpu+1个线程的线程池。\nIO密集型任务则由于线程并不是一直在执行任务，则配置尽可能多的线程，如2*Ncpu\n混合型的任务，如果可以拆分，则将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐率要高于串行执行的吞吐率，如果这两个任务执行时间相差太大，则没必要进行分解。我们可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。\n\n\n优先级不同，用优先级队列PriorityBlockingQueue来处理\n让优先级高的任务先得到执行\n需要注意的是如果一直有优先级高的任务提交到队列里\n那么优先级低的任务可能永远不能执行\n\n\n执行时间不同，可以交给不同规模的线程池来处理，或者也可以使用优先级队列，让执行时间短的任务先执行。\n依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，如果等待的时间越长CPU空闲时间就越长，那么线程数应该设置越大，这样才能更好的利用CPU。\n建议使用有界队列。\n有界队列能增加系统的稳定性和预警能力，可以根据需要设大一点，比如几千\n\n\n\n线程池的监控\n通过线程池提供的参数进行监控。线程池里有一些属性在监控线程池的时候可以使用\n\ntaskCount：线程池需要执行的任务数量\ncompletedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount\nlargestPoolSize：线程池曾经创建过的最大线程数量。通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了\ngetPoolSize：线程池的线程数量。如果线程池不销毁的话，池里的线程不会自动销毁，所以这个大小只增不减\ngetActiveCount：获取活动的线程数\n\n\n通过扩展线程池进行监控\n\n\n\n通过继承线程池并重写线程池的beforeExecute，afterExecute和terminated方法。\n我们可以在任务执行前，执行后和线程池关闭前干一些事情。比如：\n监控任务的平均执行时间\n最大执行时间\n最小执行时间\n\n\n这几个方法在线程池里是空方法。如：\nprotected void beforeExecute(Thread t, Runnable r) &#123; &#125;\n\n\n\n\n\n","categories":["Java"],"tags":["Java","线程","线程池","并发"]},{"title":"剑指Offer之二十--顺时针打印矩阵","url":"https://java4u.cn/算法/算法/剑指Offer之二十--顺时针打印矩阵/","content":"题目描述\n输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字\n例如，如果输入如下矩阵：\n 1　　2　　3　　4\n 5　　6　　7　　8 \n 9　　10　11　 12 \n 13　 14 　15 　16\n\n\n则依次打印出数字\n\n\n1,2,3,4,\n8,12,16,\n15,14,13,\n9,5,\n6,7,\n11,\n10\n\n解析\n因为每打印一圈都会改变起始坐标，所以需要先确定矩阵大小与起始坐标的关系\n\n\n比如4阶矩阵，第一圈起始坐标为(0,0)，第二圈起始坐标为(1,1)，打印两圈之后就结束了\n比如一个5阶矩阵，前两圈同4阶，第三圈为(2,2)，而且只打印了一个数。\n会发现，只要起始坐标的两倍小于阶数，就会一直转圈打印\n所以停止转圈打印的条件就是起始坐标的2倍大于或者等于阶数\n\n\n然后考虑每一圈的打印方法\n\n\n第一步:从左到右打印一行\n第二步：从上到下打印一列（需满足终止行号大于起始行号）\n第三步：从右到左打印一列（需满足终止行号大于起始行号的同时，终止列号大于起始列号）\n第四步：从下到上打印一列（需满足终止行号比起始行号大2，终止列号大于起始列号）\n注意：打印矩阵最里面一圈可能只需要三步、两步、甚至一步\n\n代码实现public ArrayList&lt;Integer&gt; printMatrix(int [][] matrix) &#123;\n\n    if(matrix == null || matrix.length &lt;= 0 || matrix[0].length &lt;= 0)&#123;\n        return null;\n    &#125;\n\n    ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    int rows = matrix.length;\n    int cols = matrix[0].length;\n    //起点坐标\n    int start = 0;\n\n    while(rows &gt; 2 * start &amp;&amp; cols &gt; 2 * start)&#123;\n        printMatrixInCircle(list,matrix,rows,cols,start);\n        start++;\n    &#125;\n\n    return list;\n&#125;\n\n/**\n * 打印每一圈\n * @param list        返回的集合\n * @param matrix    矩阵\n * @param rows        行数\n * @param cols        列数\n * @param start        起点坐标\n */\nprivate void printMatrixInCircle(ArrayList&lt;Integer&gt; list, int[][] matrix, int rows, int cols, int start) &#123;\n\n    //endX为终止行号，endY为终止列号\n    int endX = rows - start - 1;\n    int endY = cols - start - 1;\n\n    //从左到右的一行\n    for(int i = start; i &lt;= endY; i++)&#123;\n        list.add(matrix[start][i]);\n    &#125;\n\n    //从上到下的一行\n    if(endX &gt; start)&#123;\n        for(int i = start + 1; i &lt;= endX; i++)&#123;\n            list.add(matrix[i][endY]);\n        &#125;\n    &#125;\n\n    //从右到左的一行\n    if(endX &gt; start &amp;&amp; endY &gt; start)&#123;\n        for(int i = endY - 1; i &gt;= start; i--)&#123;\n            list.add(matrix[endX][i]);\n        &#125;\n    &#125;\n\n    //从下到上的一行\n    if(endX - 1 &gt; start &amp;&amp; endY &gt; start)&#123;\n        for(int i = endX - 1; i &gt;= start + 1; i--)&#123;\n            list.add(matrix[i][start]);\n        &#125;\n    &#125;\n\n\n&#125;    \n\n---\n\n\n","categories":["算法"],"tags":["Java","矩阵","顺时针"]},{"title":"剑指Offer之二十一--包含min函数的栈","url":"https://java4u.cn/算法/算法/剑指Offer之二十一--包含min函数的栈/","content":"题目描述\n定义栈的数据结构，请在该类型中实现一个能够得到栈最小元素的min函数。\n\n解析\n在数据栈的基础上维护一个用来存放最小值的辅助栈\n每次入栈，新入栈的元素都要和辅助栈栈顶元素比较，如果新入栈的元素更小，就让它也加入最小栈中，否则最小栈再次压入其栈顶元素\n每次出栈，数据栈和辅助栈同时弹出元素\n这样就可以保证在任何情况下，辅助栈栈顶元素始终是数据栈中的最小元素\n\n代码实现public class MinFunctionStack&#123;\n\n    Stack&lt;Integer&gt; data = new Stack&lt;Integer&gt;();\n    Stack&lt;Integer&gt; assist = new Stack&lt;Integer&gt;();\n\n    public void push(int node) &#123;\n        data.push(node);\n        if(assist.size() == 0 || node &lt; assist.peek())&#123;\n            assist.push(node);\n        &#125;else&#123;\n            assist.push(assist.peek());\n        &#125;\n    &#125;\n\n    public void pop() &#123;\n        if(data.size() &gt; 0 &amp;&amp; assist.size() &gt; 0)&#123;\n            data.pop();\n            assist.pop();\n        &#125;\n    &#125;\n\n    public int top() &#123;\n        if(data.size() &gt; 0)&#123;\n            return data.peek();\n        &#125;\n        return Integer.MIN_VALUE;\n\n    &#125;\n\n    public int min() &#123;\n        if(data.size() &gt; 0 &amp;&amp; assist.size() &gt; 0)&#123;\n            return assist.peek();\n        &#125;\n        return Integer.MIN_VALUE;\n    &#125;\n\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","栈","最小值"]},{"title":"剑指Offer之十九--二叉树的镜像","url":"https://java4u.cn/算法/算法/剑指Offer之十九-二叉树的镜像/","content":"二叉树结构class TreeNode &#123;\n    int val = 0;\n    TreeNode left = null;\n    TreeNode right = null;\n\n    public TreeNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n题目描述\n请完成一个函数，输入一个二叉树，输出它的镜像\n二叉树镜像定义\n\n\n源二叉树\n镜像二叉树\n\n解析\n先序遍历给定树的每个结点\n若遍历到的结点有子节点，就交换它的两个子结点\n当交换完所有非叶子结点的左右子节点之后，就得到了树的镜像\n\n递归实现public void mirror(TreeNode root) &#123;\n    if(root == null || (root.left == null &amp;&amp; root.right == null))&#123;\n        return ;\n    &#125;\n\n\n    TreeNode temp = root.left;\n    root.left = root.right;\n    root.right = temp;\n\n    if(root.left != null)&#123;\n        mirror(root.left);\n    &#125;\n\n    if(root.right != null)&#123;\n        mirror(root.right);\n    &#125;\n&#125;\n非递归实现public void mirror2(TreeNode root) &#123;\n    if(root == null || (root.left == null &amp;&amp; root.right == null))&#123;\n        return ;\n    &#125;\n\n    Stack&lt;TreeNode&gt; s = new Stack&lt;TreeNode&gt;();\n    s.push(root);\n    while(!s.isEmpty())&#123;\n        TreeNode node = s.pop();\n\n        //交换左右孩子结点\n        TreeNode nodeTemp = node.left;\n        node.left = node.right;\n        node.right = nodeTemp;\n\n        //遍历左子树\n        if(node.left != null)&#123;\n            s.push(node.left);\n        &#125;\n\n        //遍历右子树\n        if(node.right != null)&#123;\n            s.push(node.right);\n        &#125;\n\n    &#125;\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","树","二叉树","镜像"]},{"title":"剑指Offer之十八--树的子结构","url":"https://java4u.cn/算法/算法/剑指Offer之十八--树的子结构/","content":"二叉树结构class TreeNode &#123;\n    int val = 0;\n    TreeNode left = null;\n    TreeNode right = null;\n\n    public TreeNode(int val) &#123;\n        this.val = val;\n    &#125;\n&#125;\n题目描述\n输入两颗二叉树A，B，判断B是不是A的子结构\n\n解析\n二叉树遍历算法的应用\n原二叉树是否具有某棵子树，只需要判断每个结点是否都在二叉树中出现即可\n第一步在树A中找到和B的根结点的值一样的结点R\n第二步再判断树A中以R为根结点的子树是不是包含和树B一样的结构\n\n递归实现//判断根结点为root1的树是否包含root2结构\npublic boolean hasSubtree(TreeNode root1,TreeNode root2) &#123;\n    //初始化标记变量为false\n    boolean hasSubtreeFlag = false;\n\n    //先判断根结点，若不包含判断左孩子，其次是右孩子\n    if(root1 != null &amp;&amp; root2 != null)&#123;\n        if(root1.val == root2.val)&#123;\n            hasSubtreeFlag = nodesValEqual(root1,root2);\n        &#125;\n        if(!hasSubtreeFlag)&#123;\n            hasSubtreeFlag = hasSubtree(root1.left,root2);\n        &#125;\n        if(!hasSubtreeFlag)&#123;\n            hasSubtreeFlag = hasSubtree(root1.right,root2);\n        &#125;\n    &#125;\n\n    return hasSubtreeFlag;\n&#125;\n\n//判断以root1为根的树上各结点值是否与root2相等\npublic  boolean nodesValEqual(TreeNode root1, TreeNode root2) &#123;\n\n    if(root2 == null)&#123;\n        return true;\n    &#125;\n    if(root1 == null)&#123;\n        return false;\n    &#125;\n    if(root1.val != root2.val)&#123;\n        return false;\n    &#125;\n\n    return nodesValEqual(root1.left,root2.left) &amp;&amp; nodesValEqual(root1.right,root2.right);\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","树","二叉树","遍历"]},{"title":"剑指Offer之十七--合并两个排序的链表","url":"https://java4u.cn/算法/算法/剑指Offer之十七--合并两个排序的链表/","content":"链表结点结构class ListNode&#123;\n    int value;\n    ListNode next = null;\n    public ListNode(int value)&#123;\n        this.value = value;\n    &#125;\n&#125;\n题目描述\n输入两个单调递增的链表，输出两个链表合成后的链表\n当然我们需要合成后的链表满足单调不减规则\n\n递归解法\n比较两个链表的开头结点，则可以确定合并后链表的第一个结点\n除合并后的结点外，再次比较两个链表的开头结点，则可以确定合并后链表的第二个结点\n以此类推，直到所有结点均成为合并后链表中的结点\n\n\npublic static ListNode merge(ListNode list1,ListNode list2) &#123;\n\n    if(list1 == null)&#123;\n        return list2;\n    &#125;\n    if(list2 == null)&#123;\n        return list1;\n    &#125;\n\n    ListNode mergeListHead = null;\n    if(list1.value &lt; list2.value)&#123;\n        mergeListHead = list1;\n        mergeListHead.next =merge(list1.next,list2);\n    &#125;else&#123;\n        mergeListHead = list2;\n        mergeListHead.next = merge(list1,list2.next);\n    &#125;\n\n    return mergeListHead;\n&#125;\n非递归解法\n初始化合并后的头结点\n遍历两个链表，取出较小的结点，加入到合并链表中\n如果长度不同，处理剩余的结点到合并链表中\n\n\npublic static ListNode merge2(ListNode list1,ListNode list2) &#123;\n\n    if(list1 == null)&#123;\n        return list2;\n    &#125;\n    if(list2 == null)&#123;\n        return list1;\n    &#125;\n\n    ListNode mergeList = null;\n    ListNode curNode = null;\n\n    //初始化第一个结点\n    if(list1.value &lt; list2.value)&#123;\n        curNode = list1;\n        list1 = list1.next;\n        curNode.next = null;\n        mergeList = curNode;\n    &#125;else&#123;\n        curNode = list2;\n        list2 = list2.next;\n        curNode.next = null;\n        mergeList = curNode;\n    &#125;\n\n    //遍历两个链表，取出较小的结点，加入到合并链表中\n    ListNode mergeNode = mergeList;\n    while(list1 != null &amp;&amp; list2 != null)&#123;\n        if(list1.value &lt; list2.value)&#123;\n            curNode = list1;\n            list1 = list1.next;\n            curNode.next = null;\n            mergeNode.next = curNode;\n            mergeNode = mergeNode.next;\n        &#125;else&#123;\n            curNode = list2;\n            list2 = list2.next;\n            curNode.next = null;\n            mergeNode.next = curNode;\n            mergeNode = mergeNode.next;\n        &#125;\n    &#125;\n\n    //处理剩余的结点\n    while(list1 != null)&#123;\n        curNode = list1;\n        list1 = list1.next;\n        curNode.next = null;\n        mergeNode.next = curNode;\n        mergeNode = mergeNode.next;\n    &#125;\n    while(list2 != null)&#123;\n        curNode = list2;\n        list2 = list2.next;\n        curNode.next = null;\n        mergeNode.next = curNode;\n        mergeNode = mergeNode.next;\n    &#125;\n\n    return mergeList;\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","排序","链表","合并"]},{"title":"剑指Offer之十五--链表中倒数第k个结点","url":"https://java4u.cn/算法/算法/剑指Offer之十五--链表中倒数第k个结点/","content":"链表结点结构class ListNode&#123;\n    int value;\n    ListNode next = null;\n    public ListNode(int value)&#123;\n        this.value = value;\n    &#125;\n&#125;\n基本解法\n遍历两次，第一次确定链表长度，第二次返回第n-k+1个结点，即为所求\n注意k不能超过链表长度，代码中要进行判断\n\n\npublic static ListNode findKthToTail(ListNode head,int k)&#123;\n    if(head == null || k &lt;= 0 )&#123;\n        return null;\n    &#125;\n\n    ListNode node = head;\n    int nodesNum = 1;\n    while(node.next != null)&#123;\n        nodesNum++;\n        node = node.next;\n    &#125;\n\n    node = head;\n    int count = 1;\n    while(k &lt;= nodesNum &amp;&amp; count != nodesNum - k + 1)&#123;\n        count++;\n        node = node.next;\n    &#125;\n    if(k &lt;= nodesNum)&#123;\n        return node;\n    &#125;\n    return null;\n&#125;\n高效解法\n前后指针，前指针先走k-1个结点，从第k个结点开始，后指针也跟着走\n当前指针的next为null时，此时后指针所在的位置就为链表的第k个结点\n同样注意还没走到第k个结点链表就结束的情况\n\n\npublic static ListNode findKthToTail2(ListNode head,int k)&#123;\n    if(head == null || k &lt;= 0)\n        return null;\n    ListNode pre = head;\n    ListNode behind = null;\n    for(int i = 0; i &lt; k - 1; i++)&#123;\n        if(pre.next != null)&#123;\n            pre = pre.next;\n        &#125;else&#123;\n            return null;\n        &#125;\n    &#125;\n\n    behind = head;\n    while(pre.next != null)&#123;\n        pre = pre.next;\n        behind = behind.next;\n    &#125;\n    return behind;\n&#125;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","查找","链表"]},{"title":"剑指Offer之十六--链表反转","url":"https://java4u.cn/算法/算法/剑指Offer之十六--链表反转/","content":"链表结点结构class ListNode&#123;\n    int value;\n    ListNode next = null;\n    public ListNode(int value)&#123;\n        this.value = value;\n    &#125;\n&#125;\n题目描述\n输入一个链表的头结点，反转该链表并输出翻转后的头结点\n\n代码实现\n遍历该链表\n保存后一个结点，以防止当前结点的next值更新后链表断开\n保存前一个结点，以便当前结点的next值更新为前一个结点\n最后一个结点将是反转之后的头结点，保存该结点返回\n\n\npublic static ListNode reverseList(ListNode head) &#123;\n\n    ListNode reverseListHead = null;\n    ListNode curNode = head;\n    ListNode preNode = null;\n    ListNode nextNode = null;\n\n    while(curNode != null)&#123;\n        nextNode = curNode.next;\n        if(nextNode == null)&#123;\n            reverseListHead = curNode;\n        &#125;\n\n        curNode.next = preNode;\n        preNode = curNode;\n        curNode = nextNode;\n\n    &#125;\n\n    return reverseListHead;\n&#125;\n\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","链表","反转"]},{"title":"剑指Offer之十四--调整数组顺序使奇数位于偶数前面","url":"https://java4u.cn/算法/算法/剑指Offer之十四--调整数组顺序使奇数位于偶数前面/","content":"基本解法\n保证奇数和奇数，偶数和偶数之间的相对位置不变\n遍历每个元素，一旦发现偶数就取出来，让它之后的元素向前移动，把取出来的元素补到最后的空位上\n类似插入排序，具体实现是外循环找奇数，内循环将该数之前的偶数移位\n\n\npublic static void reOrderArray(int array[])&#123;\n\n    if(array == null || array.length == 0)&#123;\n        return;\n    &#125;\n\n    for(int i = 1; i &lt; array.length; i++)&#123;\n        int current = array[i];\n        if(!isEven(current))&#123;        //找到奇数位置\n            int j = i - 1;            //从奇数前一个位置开始\n            for(; j &gt;= 0 &amp;&amp; isEven(array[j]); j--)&#123;    //发现偶数就移位\n                array[j + 1] = array[j];\n            &#125;\n            array[j + 1] = current;        //把奇数插入到偶数前面\n        &#125;\n    &#125;\n&#125;\n高效解法\n相对位置可以改变时，更为高效的解法\n维护两个指针，一首一尾\n首指针向后遍历，检测到偶数时暂停，尾指针向前遍历，检测到奇数时暂停\n交换首尾两个数\n继续这样的判断，直到首尾指针相遇。\n\n\npublic static void reOrderArray2(int array[])&#123;\n\n    int low = 0;\n    int high = array.length - 1;\n    while(low &lt; high)&#123;\n        while(low &lt; high &amp;&amp; !isEven(array[low]))&#123;\n            low++;\n        &#125;\n        while(low &lt; high &amp;&amp; isEven(array[high]))&#123;\n            high--;\n        &#125;\n        if(low &lt; high)&#123;\n            int temp = array[low];\n            array[low] = array[high];\n            array[high] = temp;\n        &#125;\n\n\n    &#125;\n\n&#125;\n判断一个数是否为偶数public static boolean isEven(int i)&#123;\n    return (i &amp; 0x1) == 0;\n&#125;\n\n---\n\n\n","categories":["算法"],"tags":["Java","排序","数组"]},{"title":"找出数组中重复最多的数","url":"https://java4u.cn/算法/算法/找出数组中重复最多的数/","content":"找出数组中重复最多的数public static int getRepeatMost(int a[])&#123;\n    Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;();\n\n    //记录每个元素出现的次数\n    for(int i = 0;i &lt; a.length;i++)&#123;\n        if(map.containsKey(a[i]))&#123;\n            map.put(a[i], map.get(a[i])+1);\n        &#125;else&#123;\n            map.put(a[i], 1);\n        &#125;\n    &#125;\n\n    //找出出现次数最多的元素\n    int most = 0;\n    int result = 0;\n    Set&lt;Integer&gt; set = map.keySet();\n    Iterator&lt;Integer&gt; it = set.iterator();\n    while(it.hasNext())&#123;\n        Integer key = it.next();\n        Integer value = map.get(key);\n        if(value &gt; most)&#123;\n            most = value;\n            result = key;\n        &#125;\n    &#125;\n\n\n    return result;\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n","categories":["算法"],"tags":["Java","查找","重复"]},{"title":"格雷码实现","url":"https://java4u.cn/算法/算法/格雷码/","content":"格雷码\n格雷码(Gray Code)是一个数列集合，每个数使用二进位来表示\n假设使用n位元来表示每个数字，任两个数之间只有一个位元值不同\n如果要产生n位元的格雷码，那么格雷码的个数为2^n\nn位元格雷码是基于n-1位元格雷码产生的\n\n算法\n产生 0, 1 两个字符串。\n在第一步的基础上，每一个字符串都加上0和1，但是每次只能加一个，所以得做两次。这样就变成了 00,01,11,10 （注意对称）。\n在第二步的基础上，再给每个字符串都加上0和1，同样，每次只能加一个，这样就变成了 000,001,011,010,110,111,101,100。\n这样就把3位元格雷码生成好了。\n如果要生成4位元格雷码，我们只需要在3位元格雷码上再加一层0,1就可以了： 0000,0001,0011,0010,0110,0111,0101,0100,1100,1101,1110,1010,0111,1001,1000.\n也就是说，n位元格雷码是基于n-1位元格雷码产生的。\n\nJava实现public static String[] getGray(int n) &#123;\n\n    String[] graycode = new String[(int) Math.pow(2, n)];\n\n    if(n == 1)&#123;\n        graycode[0] = &quot;0&quot;;\n        graycode[1] = &quot;1&quot;;\n        return graycode;\n    &#125;\n\n    String[] last = getGray(n - 1);\n\n    for(int i = 0;i &lt; last.length;i++)&#123;\n        graycode[i] = &quot;0&quot; + last[i];\n        graycode[graycode.length - i - 1] = &quot;1&quot; + last[i];\n\n    &#125;\n\n    return graycode;\n&#125;\n\n\n&lt;p&gt;&lt;/p&gt;\n\n\n\n","categories":["算法"],"tags":["Java","格雷码","递归"]},{"title":"八大排序算法Java实现","url":"https://java4u.cn/算法/算法/八大排序算法Java实现/","content":"冒泡排序/*\n * 冒泡排序\n * 相邻元素比较，大的元素往后调\n */\npublic static void bubbleSort(int array[])&#123;\n\n    for(int i = array.length - 1 ; i &gt;= 0 ; i--)&#123;\n\n        boolean flag = false;     //设置一趟排序是否有交换的标识\n\n        for(int j = 0 ; j &lt; i ; j++)&#123;   //一趟冒泡排序\n\n            if(array[j] &gt; array[j+1])&#123;\n                swap(array, j, j+1);\n                flag = true;    //标识发生了交换\n            &#125;\n        &#125;\n\n        if(!flag)\n            break;\n    &#125;\n&#125;\n选择排序/*\n * 选择排序\n * 每个位置选择当前元素最小的\n */\npublic static void selectSort(int array[])&#123;\n\n\n    for(int i = 0 ; i &lt; array.length-1 ; i++)&#123;\n\n        int minPosition = i;\n        int min = array[i];\n\n        for(int j = i+1 ; j &lt;array.length ; j++)&#123;\n\n            if(array[j] &lt; min)&#123;\n                min = array[j];\n                minPosition = j;\n            &#125;\n\n        &#125;\n        //若i不是当前元素最小的，则和找到的那个元素交换\n        if(i !=  minPosition)&#123;\n            array[minPosition] = array[i];\n            array[i] = min;\n        &#125;\n    &#125;\n&#125;\n插入排序/*\n * 插入排序\n * 已经有序的小序列的基础上，一次插入一个元素\n */\npublic static void insertSort(int array[])&#123;\n\n    for(int i = 1 ; i &lt; array.length ; i++)&#123;\n\n        int current = array[i];   //待排元素\n\n        int j = i;\n        for(; j &gt; 0 &amp;&amp; array[j - 1] &gt; current ; j--)&#123;\n            //向前扫描，只要发现待排元素比较小，就插入\n\n            array[j] = array[j - 1];    //移出空位\n\n        &#125;\n\n        array[j] = current;    //元素插入\n    &#125;\n&#125;\n快速排序/*\n * 快速排序\n * 两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，\n * 其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]\n * 如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j\n * 交换a[j]和a[center_index]，完成一趟快速排序\n * 枢轴采用三数取中法可以优化\n */\n//递归快速排序\npublic static void quickSort(int a[])&#123;\n    qSort(a, 0, a.length - 1);\n&#125;\n//非递归快速排序，手动利用栈来存储每次分块快排的起始点，栈非空时循环获取中轴入栈  \npublic static void quickSortNonRecursion(int array[])&#123;\n     if (array == null || array.length == 1) return;\n     //存放开始与结束索引\n     Stack&lt;Integer&gt; s = new Stack&lt;Integer&gt;(); \n     //压栈       \n     s.push(0); \n     s.push(array.length - 1); \n     //利用循环里实现\n     while (!s.empty()) &#123; \n         int right = s.pop(); \n         int left = s.pop(); \n         //如果最大索引小于等于左边索引，说明结束了\n         if (right &lt;= left) continue; \n\n         int i = partition(array, left, right); \n         if (left &lt; i - 1) &#123;\n             s.push(left);\n             s.push(i - 1);\n         &#125; \n         if (i + 1 &lt; right) &#123;\n             s.push(i+1);\n             s.push(right);\n         &#125;\n     &#125; \n&#125;\n//递归排序，利用两路划分\npublic static void qSort(int a[],int low,int high)&#123;\n    int pivot = 0;\n    if(low &lt; high)&#123;\n        //将数组一分为二\n        pivot = partition(a,low,high);\n        //对第一部分进行递归排序\n        qSort(a,low,pivot);\n        //对第二部分进行递归排序\n        qSort(a,pivot + 1,high);\n    &#125;\n&#125;\n//partition函数\npublic static int partition(int a[],int low,int high)&#123;\n\n    int pivotkey = a[low];   //选取第一个元素为枢轴记录\n    while(low &lt; high)&#123;\n        //将比枢轴记录小的交换到低端\n        while(low &lt; high &amp;&amp; a[high] &gt;= pivotkey)&#123;\n            high--;\n        &#125;\n        //采用替换而不是交换的方式操作\n        a[low] = a[high];\n        //将比枢轴记录大的交换到高端\n        while(low &lt; high &amp;&amp; a[low] &lt;= pivotkey)&#123;\n            low++;\n        &#125;\n        a[high] = a[low];\n    &#125;\n    //枢纽所在位置赋值\n    a[low] = pivotkey;\n    //返回枢纽所在的位置\n    return low;\n&#125;\n归并排序/*\n * 归并排序\n * 把序列递归地分成短序列\n * 递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),\n * 然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序\n */\n//将有二个有序数列a[first...mid]和a[mid+1...last]合并。  \npublic static void merge(int a[], int first, int mid, int last, int temp[])&#123;\n\n    int i = first,j = mid+1;\n    int k = 0;\n\n    while(i &lt;= mid &amp;&amp; j&lt;= last)&#123;\n        if(a[i]&lt;a[j])\n            temp[k++] = a[i++];\n        else\n            temp[k++] = a[j++];\n    &#125;\n\n    while(i &lt;= mid)\n        temp[k++] = a[i++];\n    while(j &lt;= last)\n        temp[k++] = a[j++];\n\n    for(i = 0 ; i &lt; k ; i++)\n        a[first+i] = temp[i];\n&#125;\n\n//递归合并排序\npublic static void mSort(int a[], int first,int last, int temp[])&#123;\n    if(first &lt; last)&#123;\n        int mid = (first + last) / 2;\n        mSort(a, first, mid, temp);\n        mSort(a, mid+1, last, temp);\n        merge(a, first, mid, last, temp);\n\n    &#125;\n&#125;\n//提供通用归并排序接口\npublic static void mergeSort(int a[])&#123;\n    int[] temp = new int[a.length];\n    mSort(a, 0, a.length-1, temp);\n&#125;\n希尔排序/*\n * 希尔排序\n * 按照不同步长对元素进行插入排序\n * 插入排序的一种\n */\npublic static void shellSort(int a[])&#123;\n    if(a == null || a.length == 0)&#123;\n        return;\n    &#125;\n    int len = a.length;\n    //初始化增量\n    int inc = len;\n    do&#123;\n        //增量变化规则\n        inc = inc / 3 + 1;\n        for(int i = inc; i &lt; len; i++)&#123;\n            //待排元素\n            int cur = a[i];\n            int j = i;\n            //向前扫描，只要发现待排元素比较小，就插入\n            for(; j &gt;= inc &amp;&amp; a[j - inc] &gt; cur; j -= inc)&#123;\n                //移除空位\n                a[j] = a[j - inc];\n            &#125;\n            //元素插入\n            a[j] = cur;\n\n        &#125;\n    &#125;while(inc &gt; 1);\n&#125;\n堆排序/*\n * 堆排序\n * 调整最大堆，交换根元素和最后一个元素。\n * 参数说明：\n *     a -- 待排序的数组\n */\npublic static void heapSort(int[] a) &#123;\n    if(a == null || a.length == 0)&#123;\n        return;\n    &#125;\n    int len = a.length;\n    //从尾部开始，调整成最大堆\n    for(int i = len / 2 - 1; i &gt;= 0; i--)&#123;\n        maxHeapDown(a, i, len - 1);\n    &#125;\n\n    //从最后一个元素开始对序列进行调整，不断缩小调整的范围直到第一个元素\n    for(int i = len - 1; i &gt;= 0; i--)&#123;\n        //交换a[0]和a[i]。交换后，a[i]是a[0..i]中最大\n        int tmp = a[0];\n        a[0] = a[i];\n        a[i] = tmp;\n        //调整a[0..i - 1]，使得a[0..i - 1]仍然是一个最大堆\n        maxHeapDown(a, 0, i - 1);\n    &#125;\n&#125;\n\n/*\n * 注：数组实现的堆中，第N个节点的左孩子的索引值是(2N+1)，右孩子的索引是(2N+2)。\n *     其中，N为数组下标索引值，如数组中第1个数对应的N为0。\n *\n * 参数说明：\n *     a -- 待排序的数组\n *     lo -- 被下调节点的起始位置(一般为0，表示从第1个开始)\n *     hi   -- 截至范围(一般为数组中最后一个元素的索引)\n */\nprivate static void maxHeapDown(int[] a, int lo, int hi)&#123;\n    //记录当前结点位置\n    int curIndex = lo;\n    //记录左孩子结点\n    int left = 2 * curIndex + 1;\n    //记录当前结点的值\n    int curVal = a[curIndex];\n\n    //保证curIndex,leftIndex,rightIndex中，curIndex对应的值最大\n    for(; left &lt;= hi; curIndex = left, left = 2 * left + 1)&#123;\n        //左右孩子中选择较大者\n        if(left &lt; hi &amp;&amp; a[left] &lt; a[left + 1])&#123;\n            left++;\n        &#125;\n        if(curVal &gt;= a[left])&#123;\n            break;\n        &#125;else&#123;\n            a[curIndex] = a[left];\n            a[left] = curVal;\n        &#125;\n    &#125;\n&#125;\n基数排序/*\n * 基数排序\n * 按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位\n */\npublic  static void radixSort(int[] array,int d)\n&#123;\n    int n=1;   //代表位数对应的数：1,10,100...\n    int k=0;   //保存每一位排序后的结果用于下一位的排序输入\n    int length=array.length;\n    int[][] bucket=new int[10][length];      //排序桶用于保存每次排序后的结果，这一位上排序结果相同的数字放在同一个桶里\n    int[] order=new int[length];    //用于保存每个桶里有多少个数字\n    while(n&lt;d)\n    &#123;\n        for(int num:array)    //将数组array里的每个数字放在相应的桶里\n        &#123;\n            int digit=(num/n)%10;\n            bucket[digit][order[digit]]=num;\n            order[digit]++;\n        &#125;\n        for(int i=0;i&lt;length;i++)      //将前一个循环生成的桶里的数据覆盖到原数组中用于保存这一位的排序结果\n        &#123;\n            if(order[i]!=0)        //这个桶里有数据，从上到下遍历这个桶并将数据保存到原数组中\n            &#123;\n                for(int j=0;j&lt;order[i];j++)\n                &#123;\n                    array[k]=bucket[i][j];\n                    k++;\n                &#125;\n            &#125;\n            order[i]=0;      //将桶里计数器置0，用于下一次位排序\n        &#125;\n        n*=10;\n        k=0;               //将k置0，用于下一轮保存位排序结果\n    &#125;\n\n&#125;\n通用的swap函数public static void swap(int array[],int i,int j)&#123;\n    int temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n&#125;\n性能比较\nwin7 64位 4G内存 jdk1.7.0_80下测试\n10万个随机数，各方法所用毫秒数\n100万个随机数，各方法所用毫秒数\n\n\n可见快速排序在大规模随机数据下是最为优秀的\n\n\n---\n\n\n","categories":["算法"],"tags":["Java","排序"]},{"title":"Java安全之对称加密、非对称加密、数字签名","url":"https://java4u.cn/Java/Java/Java安全之对称加密、非对称加密、数字签名/","content":"两种加密方式\nJava中加密分为两种方式\n一个是对称加密\n另一个是非对称加密\n\n\n对称加密是加密和解密的钥匙相同\n非对称加密是加密和解密的钥匙不同\n\n对称加密与非对称加密的区别\n对称加密称为密钥加密\n速度快\n加密和解密的钥匙必须相同\n只有通信双方才能知道密钥。\n\n\n非对称加密称为公钥加密\n算法更加复杂，速度慢，\n加密和解密钥匙不相同\n任何人都可以知道公钥，只有一个人持有私钥可以解密。\n\n\n\n对称加密解密/* \n * 对称加密 \n */  \nprivate static void secretEncrypt() throws Exception &#123;  \n    //使用Cipher的实例  \n    Cipher cipher =Cipher.getInstance(&quot;AES&quot;);  \n\n    //得到加密的钥匙  \n    SecretKey key =KeyGenerator.getInstance(&quot;AES&quot;).generateKey();  \n\n    //初始化加密操作,传递加密的钥匙  \n    cipher.init(Cipher.ENCRYPT_MODE,key);  \n\n    //将加密的钥匙写入secretKey.key文件中  \n    FileOutputStream fosKey=new FileOutputStream(&quot;secretKey.key&quot;);  \n    ObjectOutputStream oosSecretKey =new ObjectOutputStream(fosKey);  \n    oosSecretKey.writeObject(key);  \n    oosSecretKey.close();  \n    fosKey.close();  \n\n     //将加密的内容传递进去，返回加密后的二进制数据  \n    byte [] results =cipher.doFinal(&quot;liuyong666&quot;.getBytes());  \n\n    //将加密后的二进制数据写入到secretContent.dat文件中  \n    FileOutputStream fosData=new FileOutputStream(&quot;secretContent.dat&quot;);  \n    fosData.write(results);  \n    fosData.close();  \n&#125;  \n\n/* \n * 对称解密 \n */  \nprivate static void secretDecrypt() throws Exception&#123;  \n    Cipher cipher =Cipher.getInstance(&quot;AES&quot;);  \n\n    //获取文件中的key进行解密  \n    FileInputStream fisKey=new FileInputStream(&quot;secretKey.key&quot;);  \n    ObjectInputStream oisKey =new ObjectInputStream(fisKey);  \n    Key key =(Key)oisKey.readObject();  \n    oisKey.close();  \n    fisKey.close();  \n\n    //初始化解密操作,传递加密的钥匙  \n    cipher.init(Cipher.DECRYPT_MODE,key);  \n\n    //获取文件中的二进制数据  \n    FileInputStream fisDat=new FileInputStream(&quot;secretContent.dat&quot;);  \n    //获取数据第一种方式  \n    byte [] src=new byte [fisDat.available()];  \n    int len =fisDat.read(src);  \n    int total =0;  \n    while(total&lt;src.length)&#123;  \n        total +=len;  \n        len=fisDat.read(src,total,src.length-total);  \n    &#125;  \n    //执行解密  \n    byte [] result=cipher.doFinal(src);  \n    fisDat.close();  \n    System.out.println(new String(result));  \n     /*\n    //读文件中的数据第二种方式  \n    ByteArrayOutputStream baos =new ByteArrayOutputStream();  \n    copyStream(fisDat, baos);  \n     byte [] result=cipher.doFinal(baos.toByteArray());  \n    fisDat.close();  \n    baos.close();  */\n&#125;\n\n基于口令的对称加密与解密\n系统自动生成的Key不容易记忆，我们可以使用我们容易记忆的口令通过java自带的一个工具将它转换成Key，在解密的时候我们就可以通过口令进行解密。\n  private static void secretEncrypt() throws Exception &#123;  \n      //实例化工具  \n      Cipher cipher2=Cipher.getInstance(&quot;PBEWithMD5AndDES&quot;);  \n\n      //使用该工具将基于密码的形式生成Key  \n      SecretKey key2=SecretKeyFactory.getInstance(&quot;PBEWithMD5AndDES&quot;).generateSecret(new PBEKeySpec(&quot;123&quot;.toCharArray()));  \n      PBEParameterSpec parameterspec=new PBEParameterSpec(new byte[]&#123;1,2,3,4,5,6,7,8&#125;,1000);  \n\n      //初始化加密操作，同时传递加密的算法  \n      cipher2.init(Cipher.ENCRYPT_MODE,key2,parameterspec);  \n\n       //将要加密的数据传递进去，返回加密后的数据  \n      byte [] results =cipher2.doFinal(&quot;liuyong666.com&quot;.getBytes());  \n\n      //将加密后的数据写入到文件中  \n      FileOutputStream fosData=new FileOutputStream(&quot;liuyong666.com.dat&quot;);  \n      fosData.write(results);  \n      fosData.close();  \n  &#125;  \n\n  /* \n   * 基于口令的对称解密 \n   */  \n  private static void secretDecrypt() throws Exception&#123;  \n      Cipher cipher2=Cipher.getInstance(&quot;PBEWithMD5AndDES&quot;);  \n      SecretKey key2=SecretKeyFactory.getInstance(&quot;PBEWithMD5AndDES&quot;).generateSecret(new PBEKeySpec(&quot;123&quot;.toCharArray()));  \n      PBEParameterSpec parameterspec=new PBEParameterSpec(new byte[]&#123;1,2,3,4,5,6,7,8&#125;,1000);  \n      cipher2.init(Cipher.DECRYPT_MODE,key2,parameterspec);  \n      FileInputStream fisDat=new FileInputStream(&quot;liuyong666.com.dat&quot;);  \n      byte [] src=new byte [fisDat.available()];  \n      int len =fisDat.read(src);  \n      int total =0;  \n      while(total&lt;src.length)&#123;  \n          total +=len;  \n          len=fisDat.read(src,total,src.length-total);  \n      &#125;  \n      byte [] result=cipher2.doFinal(src);  \n      fisDat.close();  \n      System.out.println(new String(result));  \n  &#125;          \n\n\n非对称加密解密\n非对称加密是公钥加密，私钥来解密\n\n这个个人做用的少一点，主要针对于大型的网站大型的企业\n  private static void PublicEnrypt()throws Exception &#123;  \n      Cipher cipher =Cipher.getInstance(&quot;RSA&quot;);  \n      //实例化Key  \n      KeyPairGenerator keyPairGenerator=KeyPairGenerator.getInstance(&quot;RSA&quot;);  \n      //获取一对钥匙  \n      KeyPair keyPair=keyPairGenerator.generateKeyPair();  \n      //获得公钥  \n      Key publicKey=keyPair.getPublic();  \n      //获得私钥   \n      Key privateKey=keyPair.getPrivate();  \n      //用公钥加密  \n      cipher.init(Cipher.ENCRYPT_MODE, publicKey);  \n      byte [] result=cipher.doFinal(&quot;liuyong666&quot;.getBytes(&quot;UTF-8&quot;));  \n      //将Key写入到文件  \n      saveKey(privateKey,&quot;liuyong_private.key&quot;);  \n      //加密后的数据写入到文件  \n      saveData(result,&quot;public_encryt.dat&quot;);  \n  &#125;  \n\n  /* \n   * 私钥解密 \n   */  \n  private static void privateDecrypt() throws Exception &#123;  \n      Cipher cipher=Cipher.getInstance(&quot;RSA&quot;);  \n      //得到Key  \n      Key privateKey=readKey(&quot;liuyong_private.key&quot;);  \n      //用私钥去解密  \n      cipher.init(Cipher.DECRYPT_MODE, privateKey);  \n      //读数据源  \n      byte [] src =readData(&quot;public_encryt.dat&quot;);  \n      //得到解密后的结果  \n      byte[] result=cipher.doFinal(src);  \n      //二进制数据要变成字符串需解码  \n      System.out.println(new String(result,&quot;UTF-8&quot;));  \n  &#125;  \n\n  private static void saveData(byte[] result, String fileName) throws Exception &#123;  \n      FileOutputStream fosData=new FileOutputStream(fileName);  \n      fosData.write(result);  \n      fosData.close();  \n  &#125;  \n  public static void saveKey(Key key,String fileName)throws Exception&#123;  \n      FileOutputStream fosKey=new FileOutputStream(fileName);  \n      ObjectOutputStream oosSecretKey =new ObjectOutputStream(fosKey);  \n      oosSecretKey.writeObject(key);  \n      oosSecretKey.close();  \n      fosKey.close();  \n  &#125;  \n  private static Key readKey(String fileName) throws Exception &#123;  \n      FileInputStream fisKey=new FileInputStream(fileName);  \n      ObjectInputStream oisKey =new ObjectInputStream(fisKey);  \n      Key key=(Key)oisKey.readObject();  \n      oisKey.close();  \n      fisKey.close();  \n      return key;  \n  &#125;  \n  private static byte[] readData(String filename) throws Exception &#123;  \n      FileInputStream fisDat=new FileInputStream(filename);  \n      byte [] src=new byte [fisDat.available()];  \n      int len =fisDat.read(src);  \n      int total =0;  \n      while(total&lt;src.length)&#123;  \n          total +=len;  \n          len=fisDat.read(src,total,src.length-total);  \n      &#125;  \n      fisDat.close();  \n      return src;  \n  &#125;  \n\n\n\n数字签名\n数字签名的基础是公钥和私钥的非对称加密\n\n发送者使用私钥加密的消息摘要(签名)\n\n接收者使用公钥解密消息摘要以验证签名是否是某个人\n\n数字签名是个加密的过程，数字签名验证是个解密的过程\n\n要证明这段数据是你发过来的，并且没有被别人改过，这就需要用到数字签名，首先我们对整个文档进行md5加密得到16个字节，然后把消息摘要和文档发过去，解密者首先对发过来的文档进行解密，解密后得到一个摘要(md5)，对接收的文档进行md5加密,得到的md5结果匹配解密后的摘要，如果匹配成功的话证明没有修改过，我们使用Signature进行签名\n  /*  \n   * 使用私钥签名  \n   */    \n  private static void sign()throws Exception &#123;    \n      //实例化Key     \n      KeyPairGenerator keyPairGenerator=KeyPairGenerator.getInstance(&quot;RSA&quot;);    \n      //获取一对钥匙     \n      KeyPair keyPair=keyPairGenerator.generateKeyPair();    \n      //获得公钥     \n      PublicKey publicKey=keyPair.getPublic();    \n      //获得私钥      \n      PrivateKey privateKey=keyPair.getPrivate();    \n\n      //数字签名  \n      Signature signature =Signature.getInstance(&quot;SHA1withRSA&quot;);  \n      signature.initSign(privateKey);//用私钥签名  \n      signature.update(&quot;这里签名&quot;.getBytes());//对怎样的数据进行签名  \n      byte [] sign=signature.sign();  //获取签名的结果  \n\n      //保存公钥并写入文件中   \n      saveKey(publicKey,&quot;liuyong_private.key&quot;);    \n      //将签名后的数据写入到文件     \n      saveData(sign,&quot;public_encryt.dat&quot;);    \n  &#125;  \n\n  /*  \n   * 公钥解密  \n   */    \n  private static void verify() throws Exception &#123;    \n      Signature signture =Signature.getInstance(&quot;SHA1withRSA&quot;);  \n      //获取到公钥  \n      PublicKey publicKey=(PublicKey)readKey(&quot;liuyong_private.key&quot;);  \n      //初始化校验  \n      signture.initVerify(publicKey);  \n      //初始化签名对象  \n      signture.update(&quot;这里签名&quot;.getBytes());  \n      //读数据源     \n      byte [] sign =readData(&quot;public_encryt.dat&quot;);    \n      //返回匹配结果  \n      boolean isYouSigned=signture.verify(sign);  \n      //如果返回数据为true则数据没有发生修改，否则发生修改  \n      System.out.println(isYouSigned);  \n  &#125;   \n\n\n\n\n\n","categories":["Java"],"tags":["Java","安全","对称加密","非对称加密","数字签名"]},{"title":"Hashtable与ConcurrentHashMap区别","url":"https://java4u.cn/Java/Java/Hashtable与ConcurrentHashMap区别/","content":"ConcurrentHashMap的特点\n融合了Hashtable和HashMap二者的优势。\n\n\nHashtable是做了同步的\nHashMap未考虑同步。\nHashMap在单线程情况下效率较高\nHashtable在的多线程情况下，同步操作能保证程序执行的正确性\n\n\nHashtable每次同步执行的时候都要锁住整个结构![Hashtable与ConcurrentHashMap的锁结构](http://i.imgur.com/AAFLQpc.jpg)\n-\nConcurrentHashMap正是为了解决这个问题而诞生的\nConcurrentHashMap锁的方式是稍微细粒度的。 ConcurrentHashMap将hash表分为16个桶（默认值），诸如get,put,remove等常用操作只锁当前需要用到的桶。\n试想，原来只能一个线程进入，现在却能同时16个写线程进入（写线程才需要锁定，而读线程几乎不受限制，之后会提到），并发性的提升是显而易见的。\n\nConcurrentHashMap的迭代方式\n使用了不同于传统集合的快速失败迭代器的另一种迭代方式，我们称为弱一致迭代器。\n在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据，iterator完成后再将头指针替换为新的数据\n这样iterator线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。\n\n\n\n","categories":["Java"],"tags":["Java","Hashtable","ConcurrentHashMap"]},{"title":"JVM如何GC","url":"https://java4u.cn/Java/Java/JVM如何GC/","content":"管理对象\n引用技术算法\n\n\n给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1\n当引用失效时，计数器的值就减1，任何时刻计数器为0的对象就是不可能在被使用了\n这种算法是很简单的，而且早期很多面向对象语言中都采用这种方式，但是现在主流的Java虚拟机中并没有采用这种方式来管理对象，其原因最主要的原因是它很难解决对象之间的相互循环引用。\n\n\n可达性分析算法\n\n\n通过一系列的称谓“GC Roots”的对象作为起始点\n从这些节点开始向下搜索，搜索所有走过的路径为引用链，当一个对象到GC Roots没有任何引用链项链时，则证明此对象时不可用的!\n上面的这张图，对象object5、object6、object7虽然互相没有关联，但是它们到GC Roots是不可达的，所以它们将会被判定为是可回收的对象\n\n\n注意：Java语言中，可作为GC Roots的对象包括下面几种：\n虚拟机栈(栈帧中的本地变量表)中引用的对象\n方法区中类静态属性引用的对象\n方法区中常量引用的对象\n本地方法栈中JNI(即一般说的Native方法)引用的对象内存管理\n\n\n在程序运行过程当中，会创建大量的对象，这些对象，大部分是短周期的对象，小部分是长周期的对象\n对于短周期的对象，需要频繁地进行垃圾回收以保证无用对象尽早被释放掉\n对于长周期对象，则不需要频繁垃圾回收以确保不进行无谓地垃圾扫描检测。为解决这种矛盾，JVM的内存管理采用分代的策略：\n\n\n年轻代(Young Gen)：\n存放新创建的对象\n内存大小相对会比较小，垃圾回收会比较频繁\n年轻代分成1个Eden Space和2个Suvivor Space（命名为A和B）当对象在堆创建时，将进入年轻代的Eden Space。垃圾回收器进行垃圾回收时，扫描Eden Space和A Suvivor Space，如果对象仍然存活，则复制到B Suvivor Space，如果B Suvivor Space已经满，则复制 Old Gen。扫描A Suvivor Space时，如果对象已经经过了几次的扫描仍然存活，JVM认为其为一个Old对象，则将其移到Old Gen。扫描完毕后，JVM将Eden Space和A Suvivor Space清空，然后交换A和B的角色（即下次垃圾回收时会扫描Eden Space和BSuvivor Space。\nYoung Gen垃圾回收时，采用将存活对象复制到到空的Suvivor Space的方式来确保不存在内存碎片，采用空间换时间的方式来加速内存垃圾回收。\n\n\n年老代(Tenured Gen)：\nJVM认为比较old的对象（经过几次的Young Gen的垃圾回收后仍然存在）\n内存大小相对会比较大，垃圾回收也相对没有那么频繁（比如可能几个小时一次）\n年老代主要采用压缩的方式来避免内存碎片（将存活对象移动到内存片的一边），当然，有些垃圾回收器（比如CMS垃圾回收器）出于效率的原因，可能会不进行压缩。\n\n\n持久代(Perm Gen)：\n存放类定义、字节码和常量等很少会变更的信息\n\n\n\n造成full gc的原因\nnew了很多对象,没有即时在主动释放掉-&gt;Eden内存不够用-&gt;不断把对象往old迁移-&gt;old满了-&gt;full gc\n\n\n\n","categories":["Java"],"tags":["Java","GC","JVM"]},{"title":"JVM的内存区域划分","url":"https://java4u.cn/Java/Java/JVM的内存区域划分/","content":"Java程序具体执行的过程![Java程序具体执行的过程](http://i.imgur.com/BFRwHuk.png)\n--\n- 首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)\n- 由JVM中的类加载器加载各个类的字节码文件\n- 加载完毕之后，交由JVM执行引擎执行\n- 在整个程序执行过程中，JVM会用一段空间来存储程序执行期间需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。\n- 在Java中我们常常说到的内存管理就是针对这段空间进行管理（如何分配和回收内存空间）\n\n运行时数据区包括哪几部分？\n根据《Java虚拟机规范》的规定，运行时数据区通常包括这几个部分：\n\n\n程序计数器(Program Counter Register)\nJava栈(VM Stack)\n本地方法栈(Native Method Stack)\n方法区(Method Area)\n堆(Heap)![运行时数据区](http://i.imgur.com/5wHAar7.png)\n\n\n\n运行时数据区的每部分到底存储了哪些数据？\n程序计数器\n\n\n Program Counter Register，也有称作为PC寄存器。\n 在汇编语言中，程序计数器是指CPU中的寄存器，它保存的是程序当前执行的指令的地址（也可以说保存下一条指令的所在存储单元的地址），当CPU需要执行指令时，需要从程序计数器中得到当前需要执行的指令所在存储单元的地址，然后根据得到的地址获取到指令，在得到指令之后，程序计数器便自动加1或者根据转移指针得到下一条指令的地址，如此循环，直至执行完所有的指令。\n 虽然JVM中的程序计数器并不像汇编语言中的程序计数器一样是物理概念上的CPU寄存器，但是JVM中的程序计数器的功能跟汇编语言中的程序计数器的功能在逻辑上是等同的，也就是说是用来指示执行哪条指令的。\n 由于在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，因此，为了能够使得每个线程都在线程切换后能够恢复在切换之前的程序执行位置，每个线程都需要有自己独立的程序计数器，并且不能互相被干扰，否则就会影响到程序的正常执行次序。因此，可以这么说，程序计数器是每个线程所私有的。\n 在JVM规范中规定，如果线程执行的是非native方法，则程序计数器中保存的是当前需要执行的指令的地址；如果线程执行的是native方法，则程序计数器中的值是undefined。\n 由于程序计数器中存储的数据所占空间的大小不会随程序的执行而发生改变，因此，对于程序计数器是不会发生内存溢出现象(OutOfMemory)的。\n 线程私有\n\n\nJava栈\n\n\n虚拟机栈（Java Vitual Machine Stack），也就是我们常常所说的栈。\nJava栈是Java方法执行的内存模型。\nJava栈中存放的是一个个的栈帧，每个栈帧对应一个被调用的方法，在栈帧中包括：\n局部变量表(Local Variables)\n操作数栈(Operand Stack)\n指向当前方法所属的类的运行时常量池的引用(Reference to runtime constant pool)\n方法返回地址(Return Address)\n一些额外的附加信息\n\n\n当执行一个方法时，就会随之创建一个对应的栈帧，并将建立的栈帧压栈。当线程方法执行完毕之后，便会将栈帧出栈。\n因此可知，线程当前执行的方法所对应的栈帧必定位于Java栈的顶部。\n所以在使用递归方法的时候容易导致栈内存溢出的现象以及栈区的空间不用程序员去管理。\n对于所有的程序设计语言来说，栈这部分空间对程序员来说是不透明的。\n以下是一个Java栈的模型：![stack](http://i.imgur.com/8FZi2vE.png)\n\n–\n\n局部变量表，就是用来存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）。对于基本数据类型的变量，则直接存储它的值，对于引用类型的变量，则存的是指向对象的引用。局部变量表的大小在编译器就可以确定其大小了，因此在程序执行期间局部变量表的大小是不会改变的。\n操作数栈，栈最典型的一个应用就是用来对表达式求值。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，程序中的所有计算过程都是在借助于操作数栈来完成的。\n指向运行时常量池的引用，因为在方法执行的过程中有可能需要用到类中的常量，所以必须要有一个引用指向运行时常量。\n方法返回地址，当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。\n\n\n由于每个线程正在执行的方法可能不同，因此每个线程都会有一个自己的Java栈，互不干扰。\n线程私有\n\n\n本地方法栈\n\n\n本地方法栈与Java栈的作用和原理非常相似。\n区别只不过是Java栈是为执行Java方法服务的，而本地方法栈则是为执行本地方法（Native Method）服务的。\n在JVM规范中，并没有对本地方发展的具体实现方法以及数据结构作强制规定，虚拟机可以自由实现它。在HotSopt虚拟机中直接就把本地方法栈和Java栈合二为一。\n\n\n堆\n\n\n在C语言中，堆这部分空间是唯一一个程序员可以管理的内存区域。程序员可以通过malloc函数和free函数在堆上申请和释放空间。\nJava中的堆是用来存储对象本身的以及数组（当然，数组引用是存放在Java栈中的）。只不过和C语言中的不同，在Java中，程序员基本不用去关心空间释放的问题，Java的垃圾回收机制会自动进行处理。因此这部分空间也是Java垃圾收集器管理的主要区域。\n在JVM中只有一个堆\n线程共享\n\n\n方法区\n\n\n存储每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码\n在Class文件中除了类的字段、方法、接口等描述信息外，还有一项信息是常量池，用来存储编译期间生成的字面量和符号引用。\n重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。重要的部分就是运行时常量池，它是每一个类或接口的常量池的运行时表示形式，在类和接口被加载到JVM后，对应的运行时常量池就被创建出来。当然并非Class文件常量池中的内容才能进入运行时常量池，在运行期间也可将新的常量放入运行时常量池中，比如String的intern方法。\n在JVM规范中，没有强制要求方法区必须实现垃圾回收。很多人习惯将方法区称为“永久代”，是因为HotSpot虚拟机以永久代来实现方法区，从而JVM的垃圾收集器可以像管理堆区一样管理这部分区域，从而不需要专门为这部分设计垃圾回收机制。不过自从JDK7之后，Hotspot虚拟机便将运行时常量池从永久代移除了。\n线程共享\n\n \n---\n\n","categories":["Java"],"tags":["Java","JVM","内存区域"]},{"title":"JVM类加载过程","url":"https://java4u.cn/Java/Java/JVM类加载过程/","content":"类从加载到虚拟机到卸载\n整个生命周期包括：\n\n\n加载（Loading）\n连接（Linking）\n验证（Validation）\n准备（Preparation）\n解析（Resolution）\n\n\n初始化（Initialization）\n使用（Using）\n卸载（Unloading）\n\n加载\n虚拟机主要完成三件事\n\n\n通过一个类的全限定名来获取定义此类的二进制字节流\n将这个字节流所代表的静态存储结构转化为方法区域的运行时数据结构\n在Java堆中生成一个代表这个类的java.lang.Class对象，作为方法区域数据的访问入口\n\n验证\n作用\n\n\n保证Class文件的字节流包含的信息符合JVM规范，不会给JVM造成危害\n如果验证失败，就会抛出一个java.lang.VerifyError异常或其子类异常\n\n\n四个阶段\n\n\n文件格式验证：验证字节流文件是否符合Class文件格式的规范，并且能被当前虚拟机正确的处理\n元数据验证：是对字节码描述的信息进行语义分析，以保证其描述的信息符合Java语言的规范\n字节码验证：主要是进行数据流和控制流的分析，保证被校验类的方法在运行时不会危害虚拟机。\n符号引用验证：符号引用验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在解析阶段中发生\n\n准备\n为变量分配内存并设置类变量的初始化\n在这个阶段分配的仅为类的变量（static修饰的变量），而不包括类的实例变量。对已非final的变量，JVM会将其设置成“零值”，而不是其赋值语句的值：  pirvate static int size = 10;\n那么在这个阶段，size的值为0，而不是10。final修饰的类变量将会赋值成真实的值。\n\n解析\n将常量池内的符号引用替换成直接引用\n主要包括四种类型引用的解析：\n\n\n类或接口的解析\n字段解析\n方法解析\n接口方法解析。\n\n初始化\n在准备阶段，类变量已经经过一次初始化了\n在这个阶段，则是根据程序员通过程序制定的计划去初始化类的变量和其他资源。这些资源有static{}块，构造函数，父类的初始化等\n直到初始化阶段，才真正开始执行类中定义的Java程序代码\n\n\n\n","categories":["Java"],"tags":["Java","JVM"]},{"title":"Java的wait(), notify()和notifyAll()","url":"https://java4u.cn/Java/Java/Java的wait(), notify()和notifyAll()/","content":"官方解释\nwait(),notify()和notifyAll()都是java.lang.Object的方法：\nwait(): Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object.\nnotify(): Wakes up a single thread that is waiting on this object’s monitor.\nnotifyAll(): Wakes up all threads that are waiting on this object’s monitor.作用\n实现线程间阻塞(Blocking)\n控制进程内调度(inter-process communication)\n\n调用前提\n必须先获得锁\n必须锁定该对象\n\n不获得锁会怎样    public static void main(String[] args) throws InterruptedException &#123;\n        Object obj = new Object();\n        obj.wait();\n        obj.notifyAll();\n    &#125;\n\n抛出java.lang.IllegalMonitorStateException的异常\n\n不获得该对象的锁会怎样    public static void main(String[] args) throws InterruptedException &#123;\n        Object obj = new Object();\n        Object lock = new Object();\n        synchronized (lock) &#123;\n            obj.wait();\n            obj.notifyAll();\n    &#125;\n&#125;\n\n抛出java.lang.IllegalMonitorStateException的异常\n\n为什么必须获得该对象的锁\n没有锁，wait和notify有可能会产生竞态条件(Race Condition)\n所以，JVM通过在执行的时候抛出IllegalMonitorStateException的异常，来确保wait, notify时，获得了对象的锁，从而消除隐藏的Race Condition。\n\n\n\n","categories":["Java"],"tags":["Java","wait","notify"]},{"title":"HashMap实现原理","url":"https://java4u.cn/Java/Java/hashmap的实现/","content":"数据结构\n结合数组和链表的特性，做出的一种寻址容易，插入删除也容易的数据结构——哈希表\n最常用的——拉链法，即“链表的数组”\n\nHashMap其实也是一个线性的数组实现的,所以可以理解为其存储数据的容器就是一个线性数组。这可能让我们很不解，一个线性的数组怎么实现按键值对来存取数据呢？这里HashMap有做一些处理。\n首先HashMap里面实现一个静态内部类Entry，其重要的属性有 key , value, next，从属性key,value我们就能很明显的看出来Entry就是HashMap键值对实现的一个基础bean\n我们上面说到HashMap的基础就是一个线性数组，这个数组就是Entry[]，Map里面的内容都保存在Entry[]里面。\n\nHashMap的存取实现\nHashMap使用的小算法\n  //存储时:\n  int hash = key.hashCode();\n  int index = hash % Entry[].length;\n  Entry[index] = value;\n\n  //取值时:\n  int hash = key.hashCode();\n  int index = hash % Entry[].length;\n  return Entry[index];\n\n如果两个key通过hash%Entry[].length得到的index相同，会不会有覆盖的危险？\n\n\n\n不会。Entry类里面有一个next属性，作用是指向下一个Entry。\nindex=i的地方可以存储多个键值对,他们通过next这个属性链接在一起。\n数组中存储的是新插入的元素，链表头\n\n\n优化\n\n\nEntry[]的长度一定后，随着map里面数据的越来越长，这样同一个index的链就会很长，会不会影响性能？\nHashMap里面设置一个因素（也称为因子），随着map的size越来越大，Entry[]会以一定的规则加长长度。\n\n\n\n解决hash冲突的办法\n开放定址法（线性探测再散列，二次探测再散列，伪随机探测再散列)\n再哈希法\n链地址法\n建立一个公共溢出区\n\n\nJava中HashMap的解决办法就是采用的链地址法。\n\n\n\n","categories":["Java"],"tags":["Java","HashMap"]},{"title":"linux系统进程间通信的方式","url":"https://java4u.cn/Linux/Linux/linux系统进程间通信的方式/","content":"管道( pipe )：\n一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。\n\n命名管道 (named pipe) ：\n半双工的通信方式，但是它允许无亲缘关系进程间的通信。\n\n信号量( semophore ) ：\n信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源\n因此，主要作为进程间以及同一进程内不同线程之间的同步手段\n\n消息队列( message queue ) ：\n消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。\n消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n\n信号 ( sinal ) ：\n信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。\n\n共享内存( shared memory ) ：\n共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。\n\n套接字( socket ) ：\n套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同主机间的进程通信。\n\n\n\n","categories":["Linux"],"tags":["Linux","进程通信"]},{"title":"MySQL数据库三种常用存储引擎特性对比","url":"https://java4u.cn/数据库/数据库/mysql_compare/","content":"什么叫存储引擎？\nMySQL中的数据用各种不同的技术存储在文件（或内存）中，这些技术中的每一种技术都使用不同的存储机制，索引技巧，锁定水平并且最终提供广泛的不同功能和能力。\n在MySQL中将这些不同的技术及配套的相关功能称为存储引擎。\n\nMySQL存储引擎特点\n不仅可以同时使用多种存储引擎，\n而且每种存储引擎和MySQL之间使用插件方式这种非常松的耦合关系。\n\nMyISAM\n特性：\n\n\n不支持事务：MyISAM存储引擎不支持事务，所以对事务有要求的业务场景不能使用\n表级锁定：其锁定机制是表级索引，这虽然可以让锁定的实现成本很小但是也同时大大降低了其并发性能\n读写互相阻塞：不仅会在写入的时候阻塞读取，MyISAM还会在读取的时候阻塞写入，但读本身并不会阻塞另外的读\n只会缓存索引：MyISAM可以通过key_buffer缓存以大大提高访问性能减少磁盘IO，但是这个缓存区只会缓存索引，而不会缓存数据\n\n\n适用场景\n\n\n不需要事务支持（不支持）\n并发相对较低（锁定机制问题）\n数据修改相对较少（阻塞问题）\n以读为主\n数据一致性要求不是非常高\n\n\n最佳实践\n\n\n尽量索引（缓存机制）\n调整读写优先级，根据实际需求确保重要操作更优先\n启用延迟插入改善大批量写入性能\n尽量顺序操作让insert数据都写入到尾部，减少阻塞\n分解大的操作，降低单个操作的阻塞时间\n降低并发数，某些高并发场景通过应用来进行排队机制\n对于相对静态的数据，充分利用Query Cache可以极大的提高访问效率\nMyISAM的Count只有在全表扫描的时候特别高效，带有其他条件的count都需要进行实际的数据访问\n\nInnoDB\n特性\n\n\n具有较好的事务支持：支持4个事务隔离级别，支持多版本读\n行级锁定：通过索引实现，全表扫描仍然会是表锁，注意间隙锁的影响\n读写阻塞与事务隔离级别相关\n具有非常高效的缓存特性：能缓存索引，也能缓存数据\n整个表和主键以Cluster方式存储，组成一颗平衡树\n所有Secondary Index都会保存主键信息\n\n\n适用场景\n\n\n需要事务支持（具有较好的事务特性）\n行级锁定对高并发有很好的适应能力，但需要确保查询是通过索引完成\n数据更新较为频繁的场景\n数据一致性要求较高\n硬件设备内存较大，可以利用InnoDB较好的缓存能力来提高内存利用率，尽可能减少磁盘 IO\n\n\n最佳实践\n\n\n主键尽可能小，避免给Secondary index带来过大的空间负担\n避免全表扫描，因为会使用表锁\n尽可能缓存所有的索引和数据，提高响应速度\n在大批量小插入的时候，尽量自己控制事务而不要使用autocommit自动提交\n合理设置innodb_flush_log_at_trx_commit参数值，不要过度追求安全性\n避免主键更新，因为这会带来大量的数据移动\n\nNDBCluster\n特性\n\n\n分布式：分布式存储引擎，可以由多个NDBCluster存储引擎组成集群分别存放整体数据的一部分\n支持事务：和Innodb一样，支持事务\n可与mysqld不在一台主机：可以和mysqld分开存在于独立的主机上，然后通过网络和mysqld通信交互\n内存需求量巨大：新版本索引以及被索引的数据必须存放在内存中，老版本所有数据和索引必须存在与内存中\n\n\n适用场景\n\n\n具有非常高的并发需求\n对单个请求的响应并不是非常的critical\n查询简单，过滤条件较为固定，每次请求数据量较少，又不希望自己进行水平Sharding\n\n\n最佳实践\n\n\n尽可能让查询简单，避免数据的跨节点传输\n尽可能满足SQL节点的计算性能，大一点的集群SQL节点会明显多余Data节点\n在各节点之间尽可能使用万兆网络环境互联，以减少数据在网络层传输过程中的延时注：以上三个存储引擎是目前相对主流的存储引擎，还有其他类似如：Memory，Merge，CSV，Archive等存储引擎的使用场景都相对较少。\n\n\n---\n\n\n","categories":["数据库"],"tags":["数据库","MySQL","存储引擎"]},{"title":"事务隔离级别","url":"https://java4u.cn/数据库/数据库/transaction_isolate_level/","content":"简述4个等级的事务隔离级别，在相同数据环境下，使用相同的输入，执行相同的工作，根据不同的隔离级别，可以导致不同的结果。不同事务隔离级别能够解决的数据并发问题的能力是不同的。\nSERIALIZABLE（串行化）\n不会出现任何并发问题，因为它是对同一数据的访问是串行的，非并发访问的；\n性能最差；\n\nREPEATABLE READ（可重复读）（MySQL）\n防止脏读和不可重复读，不能处理幻读问题；\n性能比SERIALIZABLE好\n\nREAD COMMITTED（读已提交数据）（Oracle）\n防止脏读，没有处理不可重复读，也没有处理幻读；\n性能比REPEATABLE READ好\n\nREAD UNCOMMITTED（读未提交数据）\n可能出现任何事务并发问题\n性能最好\n\n\n\n\n\n","categories":["数据库"],"tags":["事务","MySQL"]},{"title":"排序算法稳定性","url":"https://java4u.cn/算法/算法/排序算法/","content":"定义\n排序前后两个相等的数相对位置不变，则稳定\n\n稳定性的好处\n从一个键上排序，然后再从另一个键上排序，第一个键排序的结果可以为第二个键排序所用\n\n各排序算法的稳定性\n堆排序、快速排序、希尔排序、直接选择排序不是稳定的排序算法\n基数排序、冒泡排序、直接插入排序、折半插入排序、归并排序是稳定的排序算法\n\n冒泡排序\n小的元素往前调或者把大的元素往后调\n比较是相邻的两个元素比较，交换也发生在这两个元素之间\n稳定排序算法\n\n选择排序\n每个位置选择当前元素最小的\n在一趟选择中，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。\n举个例子，序列5 8 5 2 9， 我们知道第一遍选择第1个元素5会和2交换，那么原序列中2个5的相对前后顺序就被破坏了\n不稳定的排序算法\n\n插入排序\n已经有序的小序列的基础上，一次插入一个元素\n想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置\n如果碰见一个和插入元素相 等的，那么插入元素把想插入的元素放在相等元素的后面\n相等元素的前后顺序没有改变\n稳定排序算法\n\n快速排序\n两个方向，左边的i下标一直往右走，当a[i] &lt;= a[center_index]，其中center_index是中枢元素的数组下标，一般取为数组第0个元素。而右边的j下标一直往左走，当a[j] &gt; a[center_index]\n如果i和j都走不动了，i &lt;= j, 交换a[i]和a[j],重复上面的过程，直到i&gt;j\n交换a[j]和a[center_index]，完成一趟快速排序\n在中枢元素和a[j]交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 5 3 3 4 3 8 9 10 11， 现在中枢元素5和3(第5个元素，下标从1开始计)交换就会把元素3的稳定性打乱\n不稳定发生在中枢元素和a[j] 交换的时刻\n不稳定的排序算法\n\n归并排序\n把序列递归地分成短序列，递归出口是短序列只有1个元素(认为直接有序)或者2个序列(1次比较和交换),然后把各个有序的短序列合并成一个有序的长序列，不断合并直到原序列全部排好序\n合并过程中我们可以保证如果两个当前元素相等时，我们把处在前面的序列的元素保存在结 果序列的前面，这样就保证了稳定性\n稳定排序算法\n\n基数排序\n按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位\n有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优 先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前\n用于整数\n需要较多的存储空间\n基于分别排序，分别收集\n稳定排序算法\n\n希尔排序(shell)\n按照不同步长对元素进行插入排序\n当刚开始元素很无序的时候，步长最大，所以插入排序的元素个数很少，速度很快\n当元素基本有序了，步长很小， 插入排序对于有序的序列效率很高\n所以，希尔排序的时间复杂度会比o(n^2)好一些\n由于多次插入排序，我们知道一次插入排序是稳定的，不会改变相同元 素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱\n不稳定的排序算法\n\n堆排序\n是选择排序的一种\n堆的结构是节点i的孩子为2*i和2*i+1节点，大顶堆要求父节点大于等于其2个子节点，小顶堆要求父节点小于等于其2个子节点，是完全二叉树\n在一个长为n 的序列，堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n /2-1, n/2-2, …1这些个父节点选择元素时，就会破坏稳定性。有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没 有交换，那么这2个相同的元素之间的稳定性就被破坏了\n不稳定的排序算法\n\n各排序算法的优劣\n\n---\n\n\n","categories":["算法"],"tags":["排序","算法"]},{"title":"TCP中三次握手与四次挥手","url":"https://java4u.cn/网络/网络/TCP中三次握手与四次挥手/","content":"TCP(Transmission Control Protocol)　传输控制协议\n三次握手\nTCP是主机对主机层的传输控制协议，提供可靠的连接服务，采用三次握手确认建立一个连接:\n\n\n位码即tcp标志位,有6种标示:\nSYN(synchronous建立联机)\nACK(acknowledgement 确认)\nPSH(push传送)\nFIN(finish结束)\nRST(reset重置)\nURG(urgent紧急)\nSequence number(顺序号码)\nAcknowledge number(确认号码)\n\n\n各个状态的意义如下： \nLISTEN - 侦听来自远方TCP端口的连接请求； \nSYN-SENT -在发送连接请求后等待匹配的连接请求； \nSYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； \nESTABLISHED- 代表一个打开的连接，数据可以传送给用户； \nFIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；\nFIN-WAIT-2 - 从远程TCP等待连接中断请求； \nCLOSE-WAIT - 等待从本地用户发来的连接中断请求； \nCLOSING -等待远程TCP对连接中断的确认； \nLAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； \nTIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； \nCLOSED - 没有任何连接状态；\n\n\n过程\n第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。\n第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。\n第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1）。此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。\n\n\n完成三次握手，客户端与服务器开始传送数据。\n\n四次挥手\nTCP连接是全双工的，因此每个方向都必须单独进行关闭。\n这个原则是当一方完成它的数据发送任务后就能发送一个FIN来终止这个方向的连接。\n收到一个 FIN只意味着这一方向上没有数据流动，一个TCP连接在收到一个FIN后仍能发送数据。\n首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。\nTCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。\n过程\n客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 \n服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 \n服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 \n客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 \n\n\n\n\n\n &lt;p&gt;&lt;/p&gt;\n\n\n","categories":["网络"],"tags":["网络","TCP"]}]